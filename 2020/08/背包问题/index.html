<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>背包问题 | Jesse's Blog</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=generator content="Hugo 0.74.3"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link href=/dist/css/app.4fc0b62e4b82c997bb0041217cd6b979.css rel=stylesheet><link rel="shortcut icon" href=/images/favicon.svg type=image/x-icon><meta property="og:title" content="背包问题"><meta property="og:description" content="0-1 背包 有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 cost[i]， 价值是 value[i]。求解将哪些物品装入背包可使价值总和最"><meta property="og:type" content="article"><meta property="og:url" content="https://jesse996.github.io/2020/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"><meta property="article:published_time" content="2020-08-10T22:48:24+08:00"><meta property="article:modified_time" content="2020-08-10T22:48:24+08:00"><meta itemprop=name content="背包问题"><meta itemprop=description content="0-1 背包 有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 cost[i]， 价值是 value[i]。求解将哪些物品装入背包可使价值总和最"><meta itemprop=datePublished content="2020-08-10T22:48:24+08:00"><meta itemprop=dateModified content="2020-08-10T22:48:24+08:00"><meta itemprop=wordCount content="2555"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="背包问题"><meta name=twitter:description content="0-1 背包 有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 cost[i]， 价值是 value[i]。求解将哪些物品装入背包可使价值总和最"></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">Jesse's Blog</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/about/ title="About page">About</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/post/ title="Posts page">Posts</a></li></ul><a href=https://github.com/jesse996/ target=_blank class="link-transition github link dib z-999 pt3 pt0-l mr1" title="Github link" rel=noopener aria-label="follow on Github——Opens in a new window"><svg height="32" style="enable-background:new 0 0 512 512" viewBox="0 0 512 512" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M256 32C132.3 32 32 134.8 32 261.7c0 101.5 64.2 187.5 153.2 217.9 11.2 2.1 15.3-5 15.3-11.1.0-5.5-.2-19.9-.3-39.1-62.3 13.9-75.5-30.8-75.5-30.8-10.2-26.5-24.9-33.6-24.9-33.6-20.3-14.3 1.5-14 1.5-14 22.5 1.6 34.3 23.7 34.3 23.7 20 35.1 52.4 25 65.2 19.1 2-14.8 7.8-25 14.2-30.7-49.7-5.8-102-25.5-102-113.5.0-25.1 8.7-45.6 23-61.6-2.3-5.8-10-29.2 2.2-60.8.0.0 18.8-6.2 61.6 23.5 17.9-5.1 37-7.6 56.1-7.7 19 .1 38.2 2.6 56.1 7.7 42.8-29.7 61.5-23.5 61.5-23.5 12.2 31.6 4.5 55 2.2 60.8 14.3 16.1 23 36.6 23 61.6.0 88.2-52.4 107.6-102.3 113.3 8 7.1 15.2 21.1 15.2 42.5.0 30.7-.3 55.5-.3 63 0 6.1 4 13.3 15.4 11C415.9 449.1 480 363.1 480 261.7 480 134.8 379.7 32 256 32z"/></svg><span class=new-window><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" width="8" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></span></a></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class=mt3><a href="https://www.facebook.com/sharer.php?u=https://jesse996.github.io/2020/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" class="facebook no-underline" aria-label="share on Facebook"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765 50.32h6.744V33.998h4.499l.596-5.624h-5.095l.007-2.816c0-1.466.14-2.253 2.244-2.253h2.812V17.68h-4.5c-5.405.0-7.307 2.729-7.307 7.317v3.377h-3.369v5.625h3.369V50.32zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></a><a href="https://twitter.com/share?url=https://jesse996.github.io/2020/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/&text=%e8%83%8c%e5%8c%85%e9%97%ae%e9%a2%98" class="twitter no-underline" aria-label="share on Twitter"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></a><a href="https://www.linkedin.com/shareArticle?mini=true&url=https://jesse996.github.io/2020/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/&title=%e8%83%8c%e5%8c%85%e9%97%ae%e9%a2%98" class="linkedin no-underline" aria-label="share on LinkedIn"><svg height="32" style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30C64 50.568 50.568 64 34 64zM26.354 48.137V27.71h-6.789v20.427H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></a></div><h1 class="f1 athelas mt3 mb1">背包问题</h1><time class="f6 mv4 dib tracked" datetime=2020-08-10T22:48:24+08:00>August 10, 2020</time>
<span class="f6 mv4 dib tracked">- 6 minutes read</span>
<span class="f6 mv4 dib tracked">- 2555 words</span></header><div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h1 id=0-1-背包>0-1 背包</h1><blockquote><p>有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 cost[i]， 价值是 value[i]。求解将哪些物品装入背包可使价值总和最大</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>//初始化
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> v <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#75715e>//背包体积
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> n <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;<span style=color:#75715e>//物品个数,必须等于cost和value的长度
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> cost <span style=color:#f92672>=</span> vec<span style=color:#f92672>!</span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>];<span style=color:#75715e>//物品花费
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> value <span style=color:#f92672>=</span> vec<span style=color:#f92672>!</span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>7</span>];<span style=color:#75715e>//物品价值
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> f <span style=color:#f92672>=</span> vec<span style=color:#f92672>!</span>[<span style=color:#ae81ff>0</span>; v <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];

<span style=color:#75715e>// 0 &lt;= i &lt; n
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span>..n {
    zoro_one_pack(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> f, cost[i], value[i], v);
}
<span style=color:#75715e>//最后价值总和最大的值就是f[v]
</span></code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>zoro_one_pack</span>(f: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>, cost: <span style=color:#66d9ef>usize</span>, value: <span style=color:#66d9ef>usize</span>, v: <span style=color:#66d9ef>usize</span>) {
    <span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> (cost..<span style=color:#f92672>=</span>v).rev() {
        f[j] <span style=color:#f92672>=</span> std::cmp::max(f[j], f[j <span style=color:#f92672>-</span> cost] <span style=color:#f92672>+</span> value);
    }
}
</code></pre></div><p><strong><em>注意：</em></strong></p><p>如果题目要求 <strong>恰好装满背包</strong> ,则除了<code>f[0]</code>设为 0，其余都设为 $-∞$，如果<strong>不</strong>要求恰好装满，则<code>f</code>全初始化为 0。</p><h3 id=_一个常数优化_><em>一个常数优化</em></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>//伪代码
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span>..n {
    <span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> (cpm::max(cost[i],v<span style=color:#f92672>-</span>(cost[i]<span style=color:#f92672>+</span>..<span style=color:#f92672>+</span>cost[n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]))..<span style=color:#f92672>=</span>v).rev() {
        f[j] <span style=color:#f92672>=</span> std::cmp::max(f[j], f[j <span style=color:#f92672>-</span> cost[i]] <span style=color:#f92672>+</span> value[i]);
    }
}
</code></pre></div><h1 id=完全背包>完全背包</h1><blockquote><p>有 <code>N</code> 种物品和一个容量为<code>V</code> 的背包，每种物品都有<strong>无限件</strong>可用。放入第 i 种物品的费用是 <code>cost[i]</code>，价值是 <code>value[i]</code>。求解：将哪些物品装入背包，可使这些物品的耗费的费用总 和不超过背包容量，且价值总和最大</p></blockquote><p>思路是转化成<strong>0-1 背包：将一种物品拆成多件只能选 0 件或 1 件的 01 背包中的物品。</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>//初始化
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> v <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#75715e>//背包体积
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> n <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;<span style=color:#75715e>//物品个数,必须等于cost和value的长度
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> cost <span style=color:#f92672>=</span> vec<span style=color:#f92672>!</span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>];<span style=color:#75715e>//物品花费
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> value <span style=color:#f92672>=</span> vec<span style=color:#f92672>!</span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>7</span>];<span style=color:#75715e>//物品价值
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> f <span style=color:#f92672>=</span> vec<span style=color:#f92672>!</span>[<span style=color:#ae81ff>0</span>; v <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];

<span style=color:#75715e>// 0 &lt;= i &lt; n
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span>..n {
    zoro_one_pack(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> f, cost[i], value[i], v);
}
<span style=color:#75715e>//最后价值总和最大的值就是f[v]
</span></code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>complete_pack</span>(f: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>, cost: <span style=color:#66d9ef>usize</span>, value: <span style=color:#66d9ef>usize</span>, v: <span style=color:#66d9ef>usize</span>) {
    <span style=color:#75715e>//就是将0-1背包中内层循环次序反转
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> cost..<span style=color:#f92672>=</span>v {
        f[j] <span style=color:#f92672>=</span> std::cmp::max(f[j], f[j <span style=color:#f92672>-</span> cost] <span style=color:#f92672>+</span> value);
    }
}
</code></pre></div><h1 id=多重背包>多重背包</h1><blockquote><p>有 <code>N</code> 种物品和一个容量为 <code>V</code> 的背包。第 i 种物品最多有 <code>M[i]</code> 件可用，每件耗费的空间是 <code>cost[i]</code>，价值是 <code>value[i]</code>。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超 过背包容量，且价值总和最大</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>multiple_pack</span>(f: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>, cost: <span style=color:#66d9ef>usize</span>, value: <span style=color:#66d9ef>usize</span>, v: <span style=color:#66d9ef>usize</span>, <span style=color:#66d9ef>mut</span> m: <span style=color:#66d9ef>usize</span>) {
    <span style=color:#66d9ef>if</span> cost <span style=color:#f92672>*</span> m <span style=color:#f92672>&gt;=</span> v {
        complete_pack(f, cost, value, v);
        <span style=color:#66d9ef>return</span>;
    }
    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
    <span style=color:#66d9ef>while</span> k <span style=color:#f92672>&lt;</span> m {
        zoro_one_pack(f, k <span style=color:#f92672>*</span> cost, k <span style=color:#f92672>*</span> value, v);
        m <span style=color:#f92672>-=</span> k;
        k <span style=color:#f92672>*=</span> <span style=color:#ae81ff>2</span>;
    }
    zoro_one_pack(f, m <span style=color:#f92672>*</span> cost, m <span style=color:#f92672>*</span> value, v)
}
</code></pre></div><h3 id=可行性问题>可行性问题</h3><blockquote><p>当问题是“<strong>每种有若干件的物品能否填满给定容量的背包</strong>”，只须考虑填满背包的可行性，不需考虑每件物品的价值时，多重背包问题同样有 O(VN) 复杂度的算法</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>multiple_pack_ok</span>() {
		<span style=color:#75715e>//也可以用硬币模型来理解。v代表硬币的总价值，n代表硬币的种类，
</span><span style=color:#75715e></span>    <span style=color:#75715e>//m是每个硬币的数量，cost代表每种硬币的价值
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> v <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
    <span style=color:#66d9ef>let</span> n <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
    <span style=color:#66d9ef>let</span> cost <span style=color:#f92672>=</span> vec<span style=color:#f92672>!</span>[<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>3</span>];
    <span style=color:#66d9ef>let</span> m <span style=color:#f92672>=</span> vec<span style=color:#f92672>!</span>[<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>6</span>];
    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> f <span style=color:#f92672>=</span> vec<span style=color:#f92672>!</span>[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; v <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];
    f[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span>..n {
        <span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span>..<span style=color:#f92672>=</span>v {
            <span style=color:#66d9ef>if</span> f[j] <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> {
                f[j] <span style=color:#f92672>=</span> m[i];
            }
						<span style=color:#75715e>//else {
</span><span style=color:#75715e></span>            <span style=color:#75715e>//    f[j] = -1; 应为默认初始化就是-1
</span><span style=color:#75715e></span>            <span style=color:#75715e>//}
</span><span style=color:#75715e></span>        }
        <span style=color:#66d9ef>if</span> v <span style=color:#f92672>&lt;</span> cost[i] {
            <span style=color:#66d9ef>break</span>;
        }
        <span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span>..<span style=color:#f92672>=</span>(v <span style=color:#f92672>-</span> cost[i]) {
            <span style=color:#66d9ef>if</span> f[j] <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> {
                f[j <span style=color:#f92672>+</span> cost[i]] <span style=color:#f92672>=</span> std::cmp::max(f[j <span style=color:#f92672>+</span> cost[i]], f[j] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
            }
        }
    }
}
</code></pre></div><p><code>f[i][j]</code>表示使用前<code>i</code>个物品，填充容量为<code>j</code>的背包，第<code>i</code>个物品最多能够剩余多少个，如果无法填充容量为<code>j</code>的背包，则值为<code>-1</code></p><ol><li>首先，<code>f[i - 1][j]</code> 代表前 <code>i - 1</code> 件物品凑面值 <code>j</code>，如果其值大于等于 <code>0</code> 即状态合法可以凑出<code>j</code>，就说明接下来不需要第<code>i</code>种硬币就能凑出<code>j</code>，所以剩余的硬币数就是<code>m[i]</code>了。</li><li>如果<code>f[i - 1][j]</code>小于<code>0</code>，说明前<code>i-1</code>种凑不出来<code>j</code>。加上第<code>i</code>个硬币可能面值太大，也可能正好，所以先取 <code>-1</code>待定。</li><li><code>f[i][j + cost[i]] = std::cmp::max(f[i][j + cost[i]], f[i][j] - 1);</code> 如果能凑成<code>j+cost[i]</code>,那么就把硬币数量<code>-1</code>，如果不行，就维持<code>-1</code>的状态。</li></ol><p>然后把二维数组改为一位数组。</p><h1 id=混合背包>混合背包</h1><p>就是上面三种背包混合在一起</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>//伪代码：
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span>..n{
	<span style=color:#66d9ef>if</span> i <span style=color:#960050;background-color:#1e0010>是</span><span style=color:#ae81ff>01</span><span style=color:#960050;background-color:#1e0010>背包</span>{
		zero_one_pack(..);
	}<span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> i <span style=color:#960050;background-color:#1e0010>是完全背包</span>{
		complete_pack(..);
	}<span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> i <span style=color:#960050;background-color:#1e0010>是多重背包</span>{
		multiple_pack(..);
	}
}
</code></pre></div><p><a href=https://zhuanlan.zhihu.com/p/56183941>男人八题之多重背包问题</a></p><h1 id=二维背包>二维背包</h1><blockquote><p>对于每件物品，具有两种不同的费用，选择这件物品必须同时付出这两种费用。对于每种费用都有一个可付出的最大值（背包容量）。问怎样 选择物品可以得到最大的价值。</p></blockquote><blockquote><p>设第 i 件物品所需的两种费用分别为 Ci 和 Di。两种费用可付出的最大值（也即两种背包容量）分别为 V 和 U。物品的价值为 Wi</p></blockquote><p>状态转移方程如下：</p><p><code>F[i, v, u] = max{F[i − 1, v, u], F[i − 1, v − Ci, u − Di] +Wi}</code></p><p>有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取 U 件物品。
这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为 1，可以 付出的最大件数费用为 U</p><h1 id=分组背包>分组背包</h1><blockquote><p>有 N 件物品和一个容量为 V 的背包。第 i 件物品的费用是 Ci，价值是 Wi。这些物品被划分为 K 组，<strong>每组中的物品互相冲突，最多选一件</strong>。求解将哪些物品装入背包 可使这些物品的费用总和不超过背包容量，且价值总和最大</p></blockquote><p>设 F[k, v] 表示前 k 组物品花费费用 v 能取得的最大权值，则有：</p><p><code>F[k, v] = max{F[k − 1, v], F[k − 1, v − Ci] + Wi | item i ∈ group k}</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>group_pack</span>(f: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>, v: <span style=color:#66d9ef>usize</span>, cost: <span style=color:#66d9ef>&amp;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>, value: <span style=color:#66d9ef>&amp;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>) {
    <span style=color:#66d9ef>let</span> group <span style=color:#f92672>=</span> cost.len();
    <span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> (<span style=color:#ae81ff>0</span>..<span style=color:#f92672>=</span>v).rev() {
        <span style=color:#66d9ef>for</span> k <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span>..group {
            <span style=color:#66d9ef>if</span> j <span style=color:#f92672>&lt;</span> cost[k] {
                <span style=color:#66d9ef>break</span>;
            }
            f[j] <span style=color:#f92672>=</span> cmp::max(f[j], f[j <span style=color:#f92672>-</span> cost[k]] <span style=color:#f92672>+</span> value[k]);
        }
    }
}

<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_group</span>() {
    <span style=color:#66d9ef>let</span> v <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
    <span style=color:#66d9ef>let</span> n <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
    <span style=color:#66d9ef>let</span> cost <span style=color:#f92672>=</span> vec<span style=color:#f92672>!</span>[vec<span style=color:#f92672>!</span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>], vec<span style=color:#f92672>!</span>[<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>], vec<span style=color:#f92672>!</span>[<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>]]; <span style=color:#75715e>//三组
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> value <span style=color:#f92672>=</span> vec<span style=color:#f92672>!</span>[vec<span style=color:#f92672>!</span>[<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>2</span>], vec<span style=color:#f92672>!</span>[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>5</span>], vec<span style=color:#f92672>!</span>[<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>4</span>]]; <span style=color:#75715e>//
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> f <span style=color:#f92672>=</span> vec<span style=color:#f92672>!</span>[<span style=color:#ae81ff>0</span>; v <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];

    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span>..n {
        group_pack(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> f, v, <span style=color:#f92672>&amp;</span>cost[i], <span style=color:#f92672>&amp;</span>value[i]);
    }
    dbg<span style=color:#f92672>!</span>(<span style=color:#f92672>&amp;</span>f[v]);
}
</code></pre></div><h1 id=有依赖的背包问题>有依赖的背包问题</h1><blockquote><p>也就是说，物品 i 依赖于物品 j，表示若选物品 i，则必须选物品 j。</p></blockquote><p>可以对主件 k 的“附件集合”先进行一次 01 背包，得到费用依次为 0. . .V − Ck 所有这些值时相应的最 大价值 Fk[0 . . . V − Ck]。那么，这个主件及它的附件集合相当于 V − Ck + 1 个物品的 物品组，其中费用为 v 的物品的价值为 Fk[v −Ck] +Wk，v 的取值范围是 Ck ≤ v ≤ V。 也就是说，原来指数级的策略中，有很多策略都是冗余的，通过一次 01 背包后，将主件 k 及其附件转化为 V −Ck + 1 个物品的物品组，就可以直接应用分组背包的算法解决问题了</p><p><a href=https://zhuanlan.zhihu.com/p/85783138>背包问题总结（下）</a></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp> <span style=color:#ae81ff>1</span>  <span style=color:#75715e>/*
</span><span style=color:#75715e> 2 即物品间存在依赖，比如i依赖于j，表示若选物品i，则必须选物品j
</span><span style=color:#75715e> 3 http://acm.hdu.edu.cn/showproblem.php?pid=3449
</span><span style=color:#75715e> 4 有很多个箱子，想买箱子中的物品必须先买下箱子，典型的依赖背包
</span><span style=color:#75715e> 5 将不依赖其他物品的物品称为主件，依赖其他物品的物品称为附件
</span><span style=color:#75715e> 6 我们有n个箱子，箱子里面的物品个数为cnt[i]
</span><span style=color:#75715e> 7 那么箱子称为主件，箱子里面的物品称为附件
</span><span style=color:#75715e> 8 那么考虑一个主件和它附件的集合，那么有2^n+1种策略，每种策略都是互斥的。所以它是分组背包问题。
</span><span style=color:#75715e> 9 但是不能像一般的分组背包那样处理，因为组内有2^n+1种。
</span><span style=color:#75715e>10 但是考虑到费用相同时，只选择价值最大的。所以可以对组内的附件进行01背包，得到费用依次为v-c[i]...0的最大价值
</span><span style=color:#75715e>11 dp2[v-c[i]...0]
</span><span style=color:#75715e>12
</span><span style=color:#75715e>13 */</span>
<span style=color:#ae81ff>14</span> <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#f92672>&lt;</span>stdio.h<span style=color:#f92672>&gt;</span>
<span style=color:#ae81ff>15</span> <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#f92672>&lt;</span>string.h<span style=color:#f92672>&gt;</span>
<span style=color:#ae81ff>16</span> <span style=color:#66d9ef>int</span> dp[<span style=color:#ae81ff>100000</span><span style=color:#f92672>+</span><span style=color:#ae81ff>10</span>],dp2[<span style=color:#ae81ff>100000</span><span style=color:#f92672>+</span><span style=color:#ae81ff>10</span>];
<span style=color:#ae81ff>17</span> <span style=color:#66d9ef>int</span> box[<span style=color:#ae81ff>55</span>],cnt[<span style=color:#ae81ff>55</span>],price[<span style=color:#ae81ff>55</span>][<span style=color:#ae81ff>11</span>],value[<span style=color:#ae81ff>55</span>][<span style=color:#ae81ff>11</span>];
<span style=color:#ae81ff>18</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>max</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>a, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>b)
<span style=color:#ae81ff>19</span> {
<span style=color:#ae81ff>20</span>     <span style=color:#66d9ef>return</span> a <span style=color:#f92672>&lt;</span> b <span style=color:#f92672>?</span> b : a;
<span style=color:#ae81ff>21</span> }
<span style=color:#ae81ff>22</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
<span style=color:#ae81ff>23</span> {
<span style=color:#ae81ff>24</span>     <span style=color:#66d9ef>int</span> n,v,i,j,k;
<span style=color:#ae81ff>25</span>     <span style=color:#66d9ef>while</span>(scanf(<span style=color:#e6db74>&#34;%d%d&#34;</span>,<span style=color:#f92672>&amp;</span>n,<span style=color:#f92672>&amp;</span>v)<span style=color:#f92672>!=</span>EOF)
<span style=color:#ae81ff>26</span>     {
<span style=color:#ae81ff>27</span>         memset(dp,<span style=color:#ae81ff>0</span>,<span style=color:#66d9ef>sizeof</span>(dp));
<span style=color:#ae81ff>28</span>         <span style=color:#66d9ef>for</span>(i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; i<span style=color:#f92672>&lt;=</span>n; <span style=color:#f92672>++</span>i)
<span style=color:#ae81ff>29</span>         {
<span style=color:#ae81ff>30</span>             scanf(<span style=color:#e6db74>&#34;%d%d&#34;</span>,<span style=color:#f92672>&amp;</span>box[i],<span style=color:#f92672>&amp;</span>cnt[i]);
<span style=color:#ae81ff>31</span>             memcpy(dp2,dp,<span style=color:#66d9ef>sizeof</span>(dp));
<span style=color:#ae81ff>32</span>             <span style=color:#66d9ef>for</span>(j<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; j<span style=color:#f92672>&lt;=</span>cnt[i]; <span style=color:#f92672>++</span>j)
<span style=color:#ae81ff>33</span>             {
<span style=color:#ae81ff>34</span>                 scanf(<span style=color:#e6db74>&#34;%d%d&#34;</span>,<span style=color:#f92672>&amp;</span>price[i][j],<span style=color:#f92672>&amp;</span>value[i][j]);
<span style=color:#ae81ff>35</span>                 <span style=color:#66d9ef>for</span>(k<span style=color:#f92672>=</span>v<span style=color:#f92672>-</span>box[i]; k<span style=color:#f92672>&gt;=</span>price[i][j]; <span style=color:#f92672>--</span>k)<span style=color:#75715e>//附件进行01背包，每个dp2[k]对于组内的一种策略
</span><span style=color:#75715e></span><span style=color:#ae81ff>36</span>                     dp2[k] <span style=color:#f92672>=</span> max(dp2[k],dp2[k<span style=color:#f92672>-</span>price[i][j]]<span style=color:#f92672>+</span>value[i][j]);
<span style=color:#ae81ff>37</span>             }
<span style=color:#ae81ff>38</span>             <span style=color:#66d9ef>for</span>(k<span style=color:#f92672>=</span>box[i];k<span style=color:#f92672>&lt;=</span>v; <span style=color:#f92672>++</span>k)
<span style=color:#ae81ff>39</span>                 dp[k] <span style=color:#f92672>=</span> max(dp[k],dp2[k<span style=color:#f92672>-</span>box[i]]);<span style=color:#75715e>//当容量为k时，取第i组的物品时得到的最大值和不取比较哪个大
</span><span style=color:#75715e></span><span style=color:#ae81ff>40</span>         }
<span style=color:#ae81ff>41</span>         printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,dp[v]);
<span style=color:#ae81ff>42</span>     }
<span style=color:#ae81ff>43</span>     <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
<span style=color:#ae81ff>44</span> }
</code></pre></div><ul class=pa0></ul><div class="mt6 instapaper_ignoref"><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"Jesse"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://jesse996.github.io/>&copy; Jesse's Blog 2020</a><div><a href=https://github.com/jesse996/ target=_blank class="link-transition github link dib z-999 pt3 pt0-l mr1" title="Github link" rel=noopener aria-label="follow on Github——Opens in a new window"><svg height="32" style="enable-background:new 0 0 512 512" viewBox="0 0 512 512" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M256 32C132.3 32 32 134.8 32 261.7c0 101.5 64.2 187.5 153.2 217.9 11.2 2.1 15.3-5 15.3-11.1.0-5.5-.2-19.9-.3-39.1-62.3 13.9-75.5-30.8-75.5-30.8-10.2-26.5-24.9-33.6-24.9-33.6-20.3-14.3 1.5-14 1.5-14 22.5 1.6 34.3 23.7 34.3 23.7 20 35.1 52.4 25 65.2 19.1 2-14.8 7.8-25 14.2-30.7-49.7-5.8-102-25.5-102-113.5.0-25.1 8.7-45.6 23-61.6-2.3-5.8-10-29.2 2.2-60.8.0.0 18.8-6.2 61.6 23.5 17.9-5.1 37-7.6 56.1-7.7 19 .1 38.2 2.6 56.1 7.7 42.8-29.7 61.5-23.5 61.5-23.5 12.2 31.6 4.5 55 2.2 60.8 14.3 16.1 23 36.6 23 61.6.0 88.2-52.4 107.6-102.3 113.3 8 7.1 15.2 21.1 15.2 42.5.0 30.7-.3 55.5-.3 63 0 6.1 4 13.3 15.4 11C415.9 449.1 480 363.1 480 261.7 480 134.8 379.7 32 256 32z"/></svg><span class=new-window><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" width="8" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></span></a></div></div></footer><script src=/dist/js/app.3fc0f988d21662902933.js></script></body></html>