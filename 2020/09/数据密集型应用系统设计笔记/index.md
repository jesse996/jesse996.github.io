# 数据密集型应用系统设计笔记


## 第一章 可靠、可扩展与可维护的应用系统

### 可靠性

指即使发生故障，系统也可以正常运行。

### 可扩展性

指负载增加时，有效保持系统性能的相关技术策略。

### 可维护性

意味着很多方面，本质是为了让工程和运营团队更为轻松。

## 第二章 数据模型与查询语言

读时模式：数据的结构时隐形的，只在读取时才解释。NoSQL。

写时模式：关系型数据库的一种传统方法，模式时显式的，并且数据库确保数据写入时都必须遵循。

读时模式类似动态类型检查，写时模式类似静态类型检查。

对文档进行更新时，通常会更新整个文档，而只有修改量不改变源文档大小时，原地覆盖更新才有效。因此，通常建议文档应该尽量小且避免写入时增加文档大小。

SQL 是一种声明式查询语言。CSS 也是声明式语言。

多对多关系是不同数据结构之间重要区别特征。如果数据大多是一对多关系或者记录之间没有关系，那么文档模型是合适的。

关系模型能够处理简单的多对多关系，但是随着数据之间的关联越来越复杂，将数据模型转换为图模型会更加自然

图由两种对象组成：顶点和边。

图强大的用途在于，提供了单个数据存储区保存完全不同类型对象的一致性方式。（顶点之间为不同类型，边之间为不同类型）

可以将图存储看作由两个关系表组成，一个用于定点，一个用于边。

Cypher 查询语言：一种用于属性图的声明式查询语言

如果把图数据放在关系结构中，也可以用 SQL 查询，只是存在一些困难。

三元存储模式几乎等同于属性图模型。  
在三元存储中，所有信息都是以非常简单的三部分形式存储（主体，谓语，客体）。主体相当于图中顶点，而客体是以下两种之一：

1. 原始数据类型中的值，如字符串或数字。这种情况下，谓语和客体相当于键和值。
2. 图中另一个顶点。此时，谓语是途中的边，主体是尾部顶点，客体是头部顶点。

SPARQL 查询语言：采用 RDF 数据模型的三元存储查询语言。它比 Cypher 更早，并且由于 Cypher 的模式匹配是借用 SPARQL 的，所以二者看起来很相似。

图数据库和网络模型的比较：

-   在 CODASYL 中，数据库有一个模式来指定哪种记录类型可以嵌套在其他记录类型中。在图数据库中则没有这种限制。
-   在 CODASYL 中，获取特定记录的唯一方法时遍历其中一条访问路径。在图数据库中，则可以通过顶点的唯一 ID 直接引用该顶点，也可以使用索引查找满足特定值的那些顶点。
-   在 CODASYL 中，记录的子记录是有序的，而图数据库中，顶点和边不是有序的。
-   在 CODASYL 中，所有的查询都是命令式的，图数据库可以用命令式，也可以用声明式，如 Cypher 和 SPARQL

### Datalog 基础

Datalog 是比 SPARQL 和 Cypher 更古老的语言。Datalog 的数据模型类似于三元存储模式，但更为通用一些。它采用`谓语（主体，客体）`

## 第三章 数据存储于检索

首先实现一个简单的文本键值对数据库。

许多数据库内部都使用日志，日志是一个仅支持追加更新的数据文件。

_日志通常指的是应用程序的运行输出日志，来记录发生了什么事。这里则是一个更为通用的含义，表示一个仅能追加的记录序列集合，它可能是人类不可读的，可能是二进制格式的而只能被其他程序来读取。_

如果日志保存了大量的记录，那个读性能会很慢。查找开销是 O(n)。

为了高效查找，引入了索引。但这会降低写的速度，所以需要权衡。

### 哈希索引

保存内存中的 hashmap，每当在文件中追加新的键值对时，还要更新 hashmap 来反映刚刚写入的数据的偏移。

只追加到一个文件，如何避免最终用尽磁盘空间？  
一个好的方法是将日志分解成一定大小的段，当文件达到一定大小时就关闭它，并将后续写入到新的段文件中。然后可以再这些段上执行压缩。压缩意味着丢弃重复的键，只保留最近的键。

可以再执行压缩的同时将多个段合并在一起。由于段在写入后不会再进行修改，合并的段会被写入到另一个文件。

在压缩和合并时，继续用旧的段文件读取和写入。合并完成后，删除旧的段文件。

每个段都有自己的哈希表。先检查最新段的 hashmap，如果不存在，检查第二新的，以此类推。

#### 文件格式

CSV 不是日志的最佳格式。更快更简单的方法时使用二进制格式。首先以字节为单位记录字符串的长度，之后跟上原始字符串（不需要转义）

#### 删除记录

在数据文件中追加一个特殊的删除记录（墓碑），之后在合并段阶段删除。

#### 崩溃恢复

将 hashmap 的快照存储在磁盘上

#### 部分写入的记录

文件包含校验值

#### 并发控制

只有一个写线程，多个读线程

---

#### 哈希表索引也有其局限

-   哈希表必须全部放入内存，如果有大量的 key，就没那么幸运了
-   区间查询效率不高

### SSTable 和 LSM-Tree

如果要求键值对的顺序按键排序，这种格式称为排序字符串表，即 SSTable。

相比于哈希表索引日志段，有以下优点：

1. 合并段更加简单高效。因为是有序的，可以用类似合并排序算法。当多个段包含相同的键时，保留最新段的值。
2. 不再需要在内存中保存所有键的索引。因为是有序的，可以对于段文件中的每几千字节，保存一个键就够了。稀疏的索引
3. 由于读请求往往需要扫描请求范围内的多个键值对，可以考虑将这些记录保存到一个块中并在写磁盘之前将其压缩。然后稀疏内存索引的一个条目指向压缩块的开头。

### 构建和维护 SSTable

存储引擎的基本工作流程如下：

-   当写入时，将其添加到内存中的平衡树数据结构中（如红黑树）。这个内存中的树有时被称为内存表。
-   当内存表大于某个阈值（通常为几兆字节）时，将其作为 SSTable 文件写入磁盘。写入的同时可以继续添加到一个新的内存表
-   为了处理读请求，首先尝试在内存表中查找键，然后是最新的磁盘段文件，然后是次新，直到找到目标
-   后台进程周期性的执行合并与压缩过程，以合并多个段文件，并丢弃那些已被覆盖或删除的值

基于合并和压缩排序文件原理的存储引擎通常都被称为 LSM 存储引擎。

### 性能优化

当查找数据库中某个不存在的键时，LSM-Tree 算法可能很慢。为优化这种访问，使用额外的布隆过滤器。布隆过滤器是内存高效的数据结构，用于近似计算集合的内容。如果数据库中不存在某个键，它能很快告诉你结果，从而节省不必要的磁盘读取。

有不同策略，会影响甚至决定 SSTable 压缩和合并时的具体顺序和时机，最常见的有两种：

-   大小分级：较新和较小的 SSTable 被连续合并到较旧和较大的 SSTable
-   分层压缩：键的范围分裂成多个更小的 SSTable，旧数据被移动到单独的“层级”，这样压缩可以逐步进行并节省磁盘空间

### B-trees

它是几乎所有关系型数据库中的标准索引实现，许多非关系型数据库也经常使用。

同 SSTable 一样，B-tree 保留按键排序的键值对。B-tree 将数据库分解成固定大小的块或页，传统上大小为 4KB（有时更大），页是内部读写最小单位。磁盘也是以固定大小的块排列。

么个页面都用地址或位置进行标识，可以让一个页面引用另一个页面，类似指针，不过指向是磁盘地址，而不是内存。

一个页包含的子叶数量称为分支因子，通常有几百个。

B-tree 底层的基本写操作时使用新数据覆盖磁盘页上吗旧页。它假设覆盖不会改变页的磁盘存储位置，这与日志文件索引（如 LSM-Tree）仅追加更新文件形成鲜明对比

某些操作需要覆盖多个不同的页。例如，如果插入导致页溢出，因而需分裂页，那么需要写两个分裂的页，并且覆盖其父页以更新对两个子页的引用

为了能使数据库能从崩溃中恢复，常见的 B-tree 的实现需要支持磁盘上的额外的数据结构：预写日志（write-ahead log,WAL），也称重做日志。仅支持追加的文件，先更新 WAL 再修改树本身。

#### 优化 B-tree

-   一些数据库不使用覆盖页和维护 WAL 来进行崩溃恢复，而是使用写时复制方案。修改的页被写入不同的位置，树中父页的新版本被创建，并指向新的位置。

-   保存键的缩略信息。
-   相邻子页按顺序保存在磁盘上
-   添加额外的指针到树种。例如每个叶子页面可能会向左或向右引用其同级的兄弟页，这样可以顺序扫描键，而不用跳回到父页。

#### LSM-tree 优点

-   有较低的写放大，能承受更高的写入吞吐量
-   更好的压缩，因此通常磁盘上的文件比 B-tree 小很多

#### LSM-tree 缺点

-   压缩过程会干扰正在进行的读写操作，容易发生读写请求等待的情况。而 B-tree 的响应延时则更具确定性。
-   磁盘的有限写入带宽需要在初始写入和后台运行的压缩线程之间所共享，可能会发生压缩无法匹配写入速率的情况，这种情况下，磁盘上未合并段的数量不断增加，导致磁盘空间不足。

#### 在索引中存储值

索引中的键时查询搜索的对象，而值是以下两类之一：

1. 实际行（文档，顶点）
2. 对其他地方存储的行的引用。

第二种情况下，存储行的具体位置被称为堆文件，它不以特定的顺序存储数据。

聚集索引：将索引行直接存储在索引中。mysql 的 InnoDB 存储引擎中，表的主键始终是聚集索引，二级索引引用主键，而不是堆文件位置。

覆盖索引：支持只通过索引回答某些简单的查询，包含一部分列。

级联索引：将一列追加到另一列，将几个简单的字段组合成一个键，例如`lastname,firstname`组成和`lastname-firstname`，由于排列，索引可以用于找特定`lastname`的人，或特定`lastname-firstname`的人，而不能找特定`firstname`的人。

OLTP：在线事务处理。根据用户的输入插入或更新记录。
OLAP：在线分析处理。数据分析，需要扫描大量的行，每个记录只读取少数几列，并计算汇总统计信息。

数据仓库包含公司所有 OLTP 系统的只读副本。从 OLTP 数据库中提取数据，转换为分析友好的模式，执行必要的清理，然后加载到数据仓库中。过程称为提取-转换-加载。

### 星型与雪花型分析模式

与 OLTP 使用了多种不同数据模型不同，分析型业务的数据模型要少很多。许多数据仓库使用星型模型，也称为维度建模。

“星型模式”来源自当表关系可视化时，事实表位于中间，被一系列维度表包围；这些表的链接就像星星的光芒。

该模式的一个变体称为雪花模式，其中维度进一步细分为子空间。

### 列式存储

在大多数 OLTP 数据库中，存储以面向行的方式布局：来自表的一行的所有值彼此相邻存储。文档数据库也是类似。

面向列的存储的想法很简单：不需要讲一行中的所有值存储在一起，而是将每列中的所受值存储在一起。

#### 列压缩

用位图表示，位图也可以进行游程编码。

列存储的写操作时用 LSM-tree。

####物化视图
缓存查询最常用的一些计数或总和。

在 SQL 中，视图（标准视图、虚拟视图）是基于 SQL 语句的结果集的可视化的表。

视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。

视图总是显示最近的数据。每当用户查询视图时，数据库引擎通过使用 SQL 语句来重建数据。

不同的是，物化视图是查询结果的实际副本，并被写到磁盘，而虚拟视图只是用于编写查询的快捷方式。

在 OLTP 中不长使用物化视图，而对于大量读密集的数据仓库，物化事务则更有意义。

## 第四章 数据编码与演化

为了使系统继续顺利运行，需要保持双向的兼容性：

-   向后兼容
    较新的代码可以读取由旧代码编写的数据
-   向前兼容
    较旧的代码可以读取由较新代码编写的数据

使用语言内置的编码方案通常不是个好主意。

### JSON

-   对处理大数字有问题，可以用数字加字符串一起来表示
-   对 Unicode 支持很好，但不支持二进制字符串，所以通常用 Base64 将二进制数据编码为文本来解决。数据大小增加了 33%
-   由可选的模式支持。

### 二进制编码

#### Thrift 和 Protocol Buffers

Thrift 和 Protocol Buffers 是两种二进制编码库，相比于直接用 JSON 更省空间

每个字段由其标签号标识，并使用数据类型进行标识。

#### Avro

Apache Avro 是另一种二进制编码格式，也使用模式来指定编码的数据结构，它有两种模式语言：Avro IDL 用于人工编辑，另一种基于 JSON 更易于机器读取。

Avro 模式中没有标签编号，编码是最紧凑的。编码数据中没有任何内容告诉你它是什么类型。解析二进制数据时，按照他们出现在模式中的顺序便利这些字段，然后直接采用模式告诉你的每个字段的数据类型。这意味着读取数据的代码使用与写入数据的代码完全相同的模式才可以正确解析数据。

编码时，它使用所知道的模式的任何版本 来编码数据，这被称为写模式。

解码时，它期望数据符合某个模式，即读模式。

Avro 的关键思想是写模式和读模式不必是完全一样的，它们只需要保持兼容。

为了保持兼容性，只能添加或删除具有默认值的字段。更改字段名称是向后兼容的，但不能向前兼容。

Avro 对动态生成的模式更友好

### 数据流的几种模型

-   数据库
    写入数据库的进程对数据进行编码，读数据库的进程进行解码
-   RPC 和 REST API
    客户端对请求进行编码，服务器对请求进行解码并对响应进行编码，客户端最终对响应解码
-   异步消息传递（使用消息代理或 Actor）
    节点之间通过狐仙发送消息进行通信，信息由发送者编码并由接受者解码

## 第五章 数据复制

### 主从复制

只有主节点能写，读可以在主或从节点。主节点先写，然后将日志或更改发送给从节点，完成复制。

复制分为同步复制和异步复制

