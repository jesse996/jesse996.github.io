# 数据密集型应用系统设计笔记


## 第一章

### 可靠性

指即使发生故障，系统也可以正常运行。

### 可扩展性

指负载增加时，有效保持系统性能的相关技术策略。

### 可维护性

意味着很多方面，本质是为了让工程和运营团队更为轻松。

## 第二章

读时模式：数据的结构时隐形的，只在读取时才解释。NoSQL。

写时模式：关系型数据库的一种传统方法，模式时显式的，并且数据库确保数据写入时都必须遵循。

读时模式类似动态类型检查，写时模式类似静态类型检查。

对文档进行更新时，通常会更新整个文档，而只有修改量不改变源文档大小时，原地覆盖更新才有效。因此，通常建议文档应该尽量小且避免写入时增加文档大小。

SQL 是一种声明式查询语言。CSS 也是声明式语言。

多对多关系是不同数据结构之间重要区别特征。如果数据大多是一对多关系或者记录之间没有关系，那么文档模型是合适的。

关系模型能够处理简单的多对多关系，但是随着数据之间的关联越来越复杂，将数据模型转换为图模型会更加自然

图由两种对象组成：顶点和边。

图强大的用途在于，提供了单个数据存储区保存完全不同类型对象的一致性方式。（顶点之间为不同类型，边之间为不同类型）

可以将图存储看作由两个关系表组成，一个用于定点，一个用于边。

Cypher 查询语言：一种用于属性图的声明式查询语言

如果把图数据放在关系结构中，也可以用 SQL 查询，只是存在一些困难。

三元存储模式几乎等同于属性图模型。  
在三元存储中，所有信息都是以非常简单的三部分形式存储（主体，谓语，客体）。主体相当于图中顶点，而客体是以下两种之一：

1. 原始数据类型中的值，如字符串或数字。这种情况下，谓语和客体相当于键和值。
2. 图中另一个顶点。此时，谓语是途中的边，主体是尾部顶点，客体是头部顶点。

SPARQL 查询语言：采用 RDF 数据模型的三元存储查询语言。它比 Cypher 更早，并且由于 Cypher 的模式匹配是借用 SPARQL 的，所以二者看起来很相似。

图数据库和网络模型的比较：

-   在 CODASYL 中，数据库有一个模式来指定哪种记录类型可以嵌套在其他记录类型中。在图数据库中则没有这种限制。
-   在 CODASYL 中，获取特定记录的唯一方法时遍历其中一条访问路径。在图数据库中，则可以通过顶点的唯一 ID 直接引用该顶点，也可以使用索引查找满足特定值的那些顶点。
-   在 CODASYL 中，记录的子记录是有序的，而图数据库中，顶点和边不是有序的。
-   在 CODASYL 中，所有的查询都是命令式的，图数据库可以用命令式，也可以用声明式，如 Cypher 和 SPARQL

### Datalog 基础

Datalog 是比 SPARQL 和 Cypher 更古老的语言。Datalog 的数据模型类似于三元存储模式，但更为通用一些。它采用`谓语（主体，客体）`

## 第三章 数据存储于检索

首先实现一个简单的文本键值对数据库。

许多数据库内部都使用日志，日志是一个仅支持追加更新的数据文件。

_日志通常指的是应用程序的运行输出日志，来记录发生了什么事。这里则是一个更为通用的含义，表示一个仅能追加的记录序列集合，它可能是人类不可读的，可能是二进制格式的而只能被其他程序来读取。_

如果日志保存了大量的记录，那个读性能会很慢。查找开销是 O(n)。

为了高效查找，引入了索引。但这会降低写的速度，所以需要权衡。

### 哈希索引

保存内存中的 hashmap，每当在文件中追加新的键值对时，还要更新 hashmap 来反映刚刚写入的数据的偏移。

只追加到一个文件，如何避免最终用尽磁盘空间？  
一个好的方法是将日志分解成一定大小的段，当文件达到一定大小时就关闭它，并将后续写入到新的段文件中。然后可以再这些段上执行压缩。压缩意味着丢弃重复的键，只保留最近的键。

可以再执行压缩的同时将多个段合并在一起。由于段在写入后不会再进行修改，合并的段会被写入到另一个文件。

在压缩和合并时，继续用旧的段文件读取和写入。合并完成后，删除旧的段文件。

每个段都有自己的哈希表。先检查最新段的 hashmap，如果不存在，检查第二新的，以此类推。

#### 文件格式

CSV 不是日志的最佳格式。更快更简单的方法时使用二进制格式。首先以字节为单位记录字符串的长度，之后跟上原始字符串（不需要转义）

#### 删除记录

在数据文件中追加一个特殊的删除记录（墓碑），之后在合并段阶段删除。

#### 崩溃恢复

将 hashmap 的快照存储在磁盘上

#### 部分写入的记录

文件包含校验值

#### 并发控制

只有一个写线程，多个读线程

---

#### 哈希表索引也有其局限

-   哈希表必须全部放入内存，如果有大量的 key，就没那么幸运了
-   区间查询效率不高

### SSTable 和 LSM-Tree

如果要求键值对的顺序按键排序，这种格式称为排序字符串表，即 SSTable。

相比于哈希表索引日志段，有以下优点：

1. 合并段更加简单高效。因为是有序的，可以用类似合并排序算法。当多个段包含相同的键时，保留最新段的值。
2. 不再需要在内存中保存所有键的索引。因为是有序的，可以对于段文件中的每几千字节，保存一个键就够了。稀疏的索引
3. 由于读请求往往需要扫描请求范围内的多个键值对，可以考虑将这些记录保存到一个块中并在写磁盘之前将其压缩。然后稀疏内存索引的一个条目指向压缩块的开头。

### 构建和维护 SSTable

存储引擎的基本工作流程如下：

-   当写入时，将其添加到内存中的平衡树数据结构中（如红黑树）。这个内存中的树有时被称为内存表。
-   当内存表大于某个阈值（通常为几兆字节）时，将其作为 SSTable 文件写入磁盘。写入的同时可以继续添加到一个新的内存表
-   为了处理读请求，首先尝试在内存表中查找键，然后是最新的磁盘段文件，然后是次新，直到找到目标
-   后台进程周期性的执行合并与压缩过程，以合并多个段文件，并丢弃那些已被覆盖或删除的值

基于合并和压缩排序文件原理的存储引擎通常都被称为 LSM 存储引擎。

### 性能优化

当查找数据库中某个不存在的键时，LSM-Tree 算法可能很慢。为优化这种访问，使用额外的布隆过滤器。布隆过滤器是内存高效的数据结构，用于近似计算集合的内容。如果数据库中不存在某个键，它能很快告诉你结果，从而节省不必要的磁盘读取。

有不同策略，会影响甚至决定 SSTable 压缩和合并时的具体顺序和时机，最常见的有两种：

-   大小分级：较新和较小的 SSTable 被连续合并到较旧和较大的 SSTable
-   分层压缩：键的范围分裂成多个更小的 SSTable，旧数据被移动到单独的“层级”，这样压缩可以逐步进行并节省磁盘空间

### B-trees

