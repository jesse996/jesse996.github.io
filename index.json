[{"categories":null,"content":" 素食则气不浊，独宿则神不浊，默坐则心不浊，读书则口不浊。 –——曾国藩 日子是一天天地走，书要一页页地读。 ——毕淑敏 记录一下自己读过的书 2020 加密与解密 机器学习 统计学习方法 机器学习理论引导 windows 程序设计（珍藏版） C++反汇编与逆向分析技术揭秘 架构修炼之道 码出高效：Java 开发手册 阿里巴巴 Java 开发手册（泰山版） 深入理解计算机系统（原书第 3 版） DirectX 12 3D 游戏开发实战 算法（第四版） Spring Cloud Alibaba 微服务原理与实战 深入理解 Spring Cloud 与微服务构建 C++ primer 第五版 2019 编码：隐匿在计算机软硬件背后的语言（美.佩措尔德） Java 编程思想 JavaScript 高级程序设计 JavaScript 忍者秘籍 高性能 JavaScript CSS 世界 新时期的 Node.js 入门 Spring Boot 编程思想 汇编语言 第三版 王爽 手把手教你学 51 单片机-C 语言版 C++ Primer Plus 第六版 2018 第一行代码 Android 第二版 Java 编程思想 数据结构教程 ","date":"2020-08-11","objectID":"/books/:0:0","tags":null,"title":"书单","uri":"/books/"},{"categories":null,"content":"天蝎男，爱羽毛球。 技能点： 前端：Vue+React 后端：Java，Spring Boot，Rust，Nodejs Qt 单片机 Win32 编程 x86 汇编 逆向 ","date":"2020-08-11","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":["算法"],"content":"0-1 背包 有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 cost[i]， 价值是 value[i]。求解将哪些物品装入背包可使价值总和最大 //初始化 letv=2;//背包体积 letn=4;//物品个数,必须等于cost和value的长度 letcost=vec![1,2,3,4];//物品花费 letvalue=vec![1,3,5,7];//物品价值 letmutf=vec![0;v+1];// 0 \u003c= i \u003c n foriin0..n{zoro_one_pack(\u0026mutf,cost[i],value[i],v);}//最后价值总和最大的值就是f[v] fn zoro_one_pack(f: \u0026mutVec\u003cusize\u003e,cost: usize,value: usize,v: usize){forjin(cost..=v).rev(){f[j]=std::cmp::max(f[j],f[j-cost]+value);}} 注意： 如果题目要求 恰好装满背包 ,则除了f[0]设为 0，其余都设为 $-∞$，如果不要求恰好装满，则f全初始化为 0。 ","date":"2020-08-10","objectID":"/2020/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:0:0","tags":["算法","背包问题"],"title":"背包问题","uri":"/2020/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"一个常数优化 //伪代码 foriin0..n{forjin(cpm::max(cost[i],v-(cost[i]+..+cost[n-1]))..=v).rev(){f[j]=std::cmp::max(f[j],f[j-cost[i]]+value[i]);}} 完全背包 有 N 种物品和一个容量为V 的背包，每种物品都有无限件可用。放入第 i 种物品的费用是 cost[i]，价值是 value[i]。求解：将哪些物品装入背包，可使这些物品的耗费的费用总 和不超过背包容量，且价值总和最大 思路是转化成0-1 背包：将一种物品拆成多件只能选 0 件或 1 件的 01 背包中的物品。 //初始化 letv=2;//背包体积 letn=4;//物品个数,必须等于cost和value的长度 letcost=vec![1,2,3,4];//物品花费 letvalue=vec![1,3,5,7];//物品价值 letmutf=vec![0;v+1];// 0 \u003c= i \u003c n foriin0..n{zoro_one_pack(\u0026mutf,cost[i],value[i],v);}//最后价值总和最大的值就是f[v] fn complete_pack(f: \u0026mutVec\u003cusize\u003e,cost: usize,value: usize,v: usize){//就是将0-1背包中内层循环次序反转 forjincost..=v{f[j]=std::cmp::max(f[j],f[j-cost]+value);}} 多重背包 有 N 种物品和一个容量为 V 的背包。第 i 种物品最多有 M[i] 件可用，每件耗费的空间是 cost[i]，价值是 value[i]。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超 过背包容量，且价值总和最大 fn multiple_pack(f: \u0026mutVec\u003cusize\u003e,cost: usize,value: usize,v: usize,mutm: usize){ifcost*m\u003e=v{complete_pack(f,cost,value,v);return;}letmutk=1;whilek\u003cm{zoro_one_pack(f,k*cost,k*value,v);m-=k;k*=2;}zoro_one_pack(f,m*cost,m*value,v)} ","date":"2020-08-10","objectID":"/2020/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:0:1","tags":["算法","背包问题"],"title":"背包问题","uri":"/2020/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"可行性问题 当问题是“每种有若干件的物品能否填满给定容量的背包”，只须考虑填满背包的可行性，不需考虑每件物品的价值时，多重背包问题同样有 O(VN) 复杂度的算法 fn multiple_pack_ok(){//也可以用硬币模型来理解。v代表硬币的总价值，n代表硬币的种类， //m是每个硬币的数量，cost代表每种硬币的价值 letv=2;letn=4;letcost=vec![5,4,9,3];letm=vec![2,1,4,6];letmutf=vec![-1;v+1];f[0]=0;foriin0..n{forjin0..=v{iff[j]\u003e=0{f[j]=m[i];}//else { // f[j] = -1; 应为默认初始化就是-1 //} }ifv\u003ccost[i]{break;}forjin0..=(v-cost[i]){iff[j]\u003e=0{f[j+cost[i]]=std::cmp::max(f[j+cost[i]],f[j]-1);}}}} f[i][j]表示使用前i个物品，填充容量为j的背包，第i个物品最多能够剩余多少个，如果无法填充容量为j的背包，则值为-1 首先，f[i - 1][j] 代表前 i - 1 件物品凑面值 j，如果其值大于等于 0 即状态合法可以凑出j，就说明接下来不需要第i种硬币就能凑出j，所以剩余的硬币数就是m[i]了。 如果f[i - 1][j]小于0，说明前i-1种凑不出来j。加上第i个硬币可能面值太大，也可能正好，所以先取 -1待定。 f[i][j + cost[i]] = std::cmp::max(f[i][j + cost[i]], f[i][j] - 1); 如果能凑成j+cost[i],那么就把硬币数量-1，如果不行，就维持-1的状态。 然后把二维数组改为一位数组。 混合背包 就是上面三种背包混合在一起 //伪代码： foriin0..n{ifi是01背包{zero_one_pack(..);}elseifi是完全背包{complete_pack(..);}elseifi是多重背包{multiple_pack(..);}} 男人八题之多重背包问题 二维背包 对于每件物品，具有两种不同的费用，选择这件物品必须同时付出这两种费用。对于每种费用都有一个可付出的最大值（背包容量）。问怎样 选择物品可以得到最大的价值。 设第 i 件物品所需的两种费用分别为 Ci 和 Di。两种费用可付出的最大值（也即两种背包容量）分别为 V 和 U。物品的价值为 Wi 状态转移方程如下： F[i, v, u] = max{F[i − 1, v, u], F[i − 1, v − Ci, u − Di] +Wi} 有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取 U 件物品。 这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为 1，可以 付出的最大件数费用为 U 分组背包 有 N 件物品和一个容量为 V 的背包。第 i 件物品的费用是 Ci，价值是 Wi。这些物品被划分为 K 组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包 可使这些物品的费用总和不超过背包容量，且价值总和最大 设 F[k, v] 表示前 k 组物品花费费用 v 能取得的最大权值，则有： F[k, v] = max{F[k − 1, v], F[k − 1, v − Ci] + Wi | item i ∈ group k} fn group_pack(f: \u0026mutVec\u003cusize\u003e,v: usize,cost: \u0026Vec\u003cusize\u003e,value: \u0026Vec\u003cusize\u003e){letgroup=cost.len();forjin(0..=v).rev(){forkin0..group{ifj\u003ccost[k]{break;}f[j]=cmp::max(f[j],f[j-cost[k]]+value[k]);}}}fn test_group(){letv=4;letn=3;letcost=vec![vec![1,2],vec![3,4],vec![5,6]];//三组 letvalue=vec![vec![3,2],vec![1,5],vec![2,4]];// letmutf=vec![0;v+1];foriin0..n{group_pack(\u0026mutf,v,\u0026cost[i],\u0026value[i]);}dbg!(\u0026f[v]);} 有依赖的背包问题 也就是说，物品 i 依赖于物品 j，表示若选物品 i，则必须选物品 j。 可以对主件 k 的“附件集合”先进行一次 01 背包，得到费用依次为 0. . .V − Ck 所有这些值时相应的最 大价值 Fk[0 . . . V − Ck]。那么，这个主件及它的附件集合相当于 V − Ck + 1 个物品的 物品组，其中费用为 v 的物品的价值为 Fk[v −Ck] +Wk，v 的取值范围是 Ck ≤ v ≤ V。 也就是说，原来指数级的策略中，有很多策略都是冗余的，通过一次 01 背包后，将主件 k 及其附件转化为 V −Ck + 1 个物品的物品组，就可以直接应用分组背包的算法解决问题了 背包问题总结（下） /* 即物品间存在依赖，比如i依赖于j，表示若选物品i，则必须选物品j http://acm.hdu.edu.cn/showproblem.php?pid=3449 有很多个箱子，想买箱子中的物品必须先买下箱子，典型的依赖背包 将不依赖其他物品的物品称为主件，依赖其他物品的物品称为附件 我们有n个箱子，箱子里面的物品个数为cnt[i] 那么箱子称为主件，箱子里面的物品称为附件 那么考虑一个主件和它附件的集合，那么有2^n+1种策略，每种策略都是互斥的。所以它是分组背包问题。 但是不能像一般的分组背包那样处理，因为组内有2^n+1种。 但是考虑到费用相同时，只选择价值最大的。所以可以对组内的附件进行01背包，得到费用依次为v-c[i]...0的最大价值 dp2[v-c[i]...0] */ #include \u003cstdio.h\u003e #include \u003cstring.h\u003e int dp[100000+10],dp2[100000+10]; int box[55],cnt[55],price[55][11],value[55][11]; inline int max(const int \u0026a, const int \u0026b) { return a \u003c b ? b : a; } int main() { int n,v,i,j,k; while(scanf(\"%d%d\",\u0026n,\u0026v)!=EOF) { memset(dp,0,sizeof(dp)); for(i=1; i\u003c=n; ++i) { scanf(\"%d%d\",\u0026box[i],\u0026cnt[i]); memcpy(dp2,dp,sizeof(dp)); for(j=1; j\u003c=cnt[i]; ++j) { scanf(\"%d%d\",\u0026price[i][j],\u0026value[i][j]); for(k=v-box[i]; k\u003e=price[i][j]; --k)//附件进行01背包，每个dp2[k]对于组内的一种策略 dp2[k] = max(dp2[k],dp2[k-price[i][j]]+value[i][j]); } for(k=box[i];k\u003c=v; ++k) dp[k] = max(dp[k],dp2[k-box[i]]);//当容量为k时，取第i组的物品时得到的最大值和不取比较哪个大 } printf(\"%d\\n\",dp[v]); } return 0; } ","date":"2020-08-10","objectID":"/2020/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:0:2","tags":["算法","背包问题"],"title":"背包问题","uri":"/2020/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"图 ","date":"2020-07-19","objectID":"/2020/07/%E7%AE%97%E6%B3%95/:0:0","tags":["算法"],"title":"算法","uri":"/2020/07/%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"无向图 图的表示方法：邻接表 dfs 和 bfs 的区别：dfs 是用栈，bfs 用队列 //连通图 public class CC { private boolean[] marked; private int[] id; private int count; public CC(Graph G) { marked = new boolean[G.V()]; id = new int[G.V()]; for (int s = 0; s \u003c G.V(); s++) { dfs(G, s); count++; } } private void dfs(Graph G, int v) { marked[v] = true; id[v] = count; for (int w : G.adj(v)) if (!marked[w]) dfs(G, w); } } ","date":"2020-07-19","objectID":"/2020/07/%E7%AE%97%E6%B3%95/:1:0","tags":["算法"],"title":"算法","uri":"/2020/07/%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"有向图 有向无环图(DAG): 不含有向环的有向图 当且仅当一副有向图是无环图时它才能进行拓扑排序 有向图中基于 dfs 的顶点排序：前序、后续、逆后续 前序和后续用队列，逆后续用栈 一副有向无环图的拓扑排序就是所有顶点的逆后续排列（要先判断有没有环） 强连通 ：两个顶点互联可达，则这两个顶点是强连通。若一个图任意两顶点都是强连通，则这幅有向图也是强连通的。 计算强连通分量的 Kosaraju 算法：先使用 dfs 查找 G 的反向图，得到所有顶点的逆后续，再用 dfs 处理，即可得到强连通分量 //强连通分量 public class KosarajuSCC { private boolean[] marked; private int[] id; private int count; public KosarajuSCC(Digraph G) { marked = new boolean[G.V()]; id = new int[G.V()]; DepthFirstOrder order=new DepthFirstOrder(G.reverse()); for (int s:order.reversePost()) { dfs(G, s); count++; } } private void dfs(Digraph G, int v) { marked[v] = true; id[v] = count; for (int w : G.adj(v)) if (!marked[w]) dfs(G, w); } } ","date":"2020-07-19","objectID":"/2020/07/%E7%AE%97%E6%B3%95/:2:0","tags":["算法"],"title":"算法","uri":"/2020/07/%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"插入排序 fn insert\u003cT: Ord +Copy\u003e(a: \u0026mut[T]){foriin1..a.len(){lettmp=a[i];letmutj=i;whilej\u003e0\u0026\u0026tmp\u003ca[j-1]{a[j]=a[j-1];j-=1;}a[j]=tmp;}} ","date":"2020-07-19","objectID":"/2020/07/%E7%AE%97%E6%B3%95/:3:0","tags":["算法"],"title":"算法","uri":"/2020/07/%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"希尔排序 fn shell\u003cT: Ord +Copy\u003e(a: \u0026mut[T]){letn=a.len();letmuth=1;whileh\u003cn/3{h=h*3+1;}whileh\u003e=1{foriinh..n{lettmp=a[i];letmutj=i;whiletmp\u003ca[j-h]{a[j]=a[j-h];j-=h;ifletNone=j.checked_sub(h){break;}}a[j]=tmp;}h/=3;}} ","date":"2020-07-19","objectID":"/2020/07/%E7%AE%97%E6%B3%95/:4:0","tags":["算法"],"title":"算法","uri":"/2020/07/%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"归并排序 //原地归并 fn merge_help\u003cT: Ord +Copy\u003e(a: \u0026mut[T],lo: usize,mid: usize,hi: usize){ifa[mid]\u003c=a[mid+1]{return;}letmuttmp=a.to_owned();//tmp.copy_from_slice(a); letmuti=lo;letmutj=mid+1;forkinlo..=hi{ifi\u003emid{a[k]=tmp[j];j+=1;}elseifj\u003ehi{a[k]=tmp[i];i+=1;}elseiftmp[j]\u003ctmp[i]{a[k]=tmp[j];j+=1;}else{a[k]=tmp[i];i+=1;}}}//自顶向下的归并排序 fn merge_sort\u003cT: Ord +Copy\u003e(a: \u0026mut[T],lo: usize,hi: usize){ifhi\u003c=lo{return;}//数组较小时用插入排序更快 ifhi-lo\u003c15{insert(\u0026muta[lo..=hi])}letmid=(lo+hi)/2;merge_sort(a,lo,mid);merge_sort(a,mid+1,hi);merge_help(a,lo,mid,hi);}fn merge\u003cT: Ord +Copy\u003e(a: \u0026mut[T]){merge_sort(a,0,a.len()-1);}//自底向上的归并 fn merge_sort_bu\u003cT: Ord +Copy\u003e(a: \u0026mut[T],lo: usize,hi: usize){letn=a.len();letmutsz=1;whilesz\u003cn{letmutlo=0;whilelo\u003cn-sz{merge_help(a,lo,lo+sz-1,std::cmp::min(lo+sz+sz-1,n-1));lo+=2*sz;}sz*=2;}} ","date":"2020-07-19","objectID":"/2020/07/%E7%AE%97%E6%B3%95/:5:0","tags":["算法"],"title":"算法","uri":"/2020/07/%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"堆排序 #[derive(Debug)]struct MaxPQ\u003cT: Ord +Copy\u003e{pq: Vec\u003cT\u003e,}impl\u003cT: Ord +Copy+std::fmt::Debug\u003eMaxPQ\u003cT\u003e{fn new(zero: T)-\u003e Self{letpq=vec![zero];Self{pq}}fn is_empty(\u0026self)-\u003e bool {self.pq.len()\u003c=1}fn insert(\u0026mutself,v: T){self.pq.push(v);letn=self.pq.len()-1;self.swim(n);}fn swim(\u0026mutself,mutk: usize){whilek\u003e1\u0026\u0026self.pq[k]\u003eself.pq[k/2]{self.pq.swap(k/2,k);k/=2;}}fn sink(\u0026mutself,mutk: usize,N: usize){lettmp=self.pq[k];whilek*2\u003c=N{letmutj=k*2;ifj\u003cN\u0026\u0026self.pq[j]\u003cself.pq[j+1]{j+=1;}ifself.pq[k]\u003e=self.pq[j]{break;}self.pq[k]=self.pq[j];k=j;}self.pq[k]=tmp;}fn sort(a: \u0026mut[T])-\u003e Vec\u003cT\u003e{letmutn=a.len();letmutpq=MaxPQ::new(a[0]);pq.pq.append(\u0026muta.to_vec());forkin(1..=(n/2)).rev(){MaxPQ::sink(\u0026mutpq,k,n);}whilen\u003e1{pq.pq.swap(1,n);n-=1;MaxPQ::sink(\u0026mutpq,1,n);}pq.pq.remove(0);pq.pq}} Api： public class UF{ UF(int N);//初始化N个触点 void union(int p,int q) //在p和q之间添加一条连接 int find(int p) // p所在的分量的标识符 boolean connected(intp ,int q)//如果q和p在同一各分量中则返回true int count()//联通分量的数量 } 加权 quick-union 算法： 将小数的根节点连接到大树的根节点 public class WeightedQuickUnionUF{ private int[] id; private int[] sz; private int count; public WeightedQuickUnionUF(int N) { count = N; id = new int[N]; for (int i = 0; i \u003c N; i++) id[i] = i; sz = new int[N]; for (int i = 0; i \u003c N; i++) sz[i] = 1; } public int getCount() { return count; } public boolean connected(int p, int q) { return find(p) == find(q); } public int find(int p) { while (p != id[p]) p = id[p]; return p; } public void union(int p, int q) { int i = find(p); int j = find(q); if (i == j) return; if (sz[i] \u003c sz[j]) { id[i] = j; sz[j] += sz[i]; } else { id[j] = i; sz[i] += sz[j]; } count--; } } 最优解法：路径压缩的加权 quick-union 算法 要实现路径压缩，只需要为find()添加一个循环，将在路径上遇到的所有节点都直接链接到根节点。 public int find(int p) { int root = p; while (root != id[root]) root = id[root]; while (p!=root) { int next = id[p]; id[p] = root; p = next; } return root; } ","date":"2020-07-19","objectID":"/2020/07/%E7%AE%97%E6%B3%95/:6:0","tags":["算法"],"title":"算法","uri":"/2020/07/%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"快速排序 fn quick_sort(a:\u0026[i32],lo:i32,hi:i32){} ","date":"2020-07-19","objectID":"/2020/07/%E7%AE%97%E6%B3%95/:7:0","tags":["算法"],"title":"算法","uri":"/2020/07/%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"Dubbo 的功能除了基本的 RPC 职能外，核心功能便是监控及服务注册。 ","date":"2020-06-28","objectID":"/2020/06/dubbo%E5%85%A5%E9%97%A8/:0:0","tags":["微服务"],"title":"Dubbo入门","uri":"/2020/06/dubbo%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"provider 服务 首先创建一个 maven 工程：springboot-provider，再添加一个 moven 模块：sample-api，再里面创建一个接口：IHelloService public interface IHelloService { String sayHello(String name); } 然后mvn install springboot-provide这个顶层项目，这会在本地的 maven 仓库安装这父子两个库。 再添加一个 springboot 模块：sample-provider，来实现IHelloService接口 @DubboService public class HelloServiceImpl implements IHelloService { @Value(\"${dubbo.application.name}\") private String serviceName; @Override public String sayHello(String s) { return String.format(\"[%s]: Hello,%s\", serviceName, s); } } 在 pom.xml 添加依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.apache.dubbo\u003c/groupId\u003e \u003cartifactId\u003edubbo-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e2.7.7\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.example\u003c/groupId\u003e \u003cartifactId\u003esample-api\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e 在 application.properties 添加 dubbo 的配置 dubbo.application.name=jesse-dubbo dubbo.protocol.port=20880 dubbo.protocol.name=dubbo dubbo.registry.address=N/A 启动类： @DubboComponentScan @SpringBootApplication public class SampleProviderApplication { public static void main(String[] args) { SpringApplication.run(SampleProviderApplication.class, args); } } provider 服务就启动了~ ","date":"2020-06-28","objectID":"/2020/06/dubbo%E5%85%A5%E9%97%A8/:1:0","tags":["微服务"],"title":"Dubbo入门","uri":"/2020/06/dubbo%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"consumer 服务 新建一个 springboot 项目：springboot-consumer，在 pom.xml 添加依赖，同上。同样也要在 application.properties 添加 dubbo 的配置，不过最少只要配置 name 就行 dubbo.application.name=springboot-consumer 启动类： @SpringBootApplication public class SpringbootConsumerApplication { @DubboReference(url = \"dubbo://127.0.0.1:20880\") private IHelloService helloService; public static void main(String[] args) { SpringApplication.run(SpringbootConsumerApplication.class, args); } @Bean public ApplicationRunner runner(){ return args -\u003e System.out.println(helloService.sayHello(\"Mic\")); } } 完~ ","date":"2020-06-28","objectID":"/2020/06/dubbo%E5%85%A5%E9%97%A8/:2:0","tags":["微服务"],"title":"Dubbo入门","uri":"/2020/06/dubbo%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"安装 sudo pacman -S fcitx5-git fcitx5-qt5-git kcm-fcitx5-git fcitx5-rime-git 配置 然后打开 fctix5 配置程序，添加中州*，就是 rime。 添加一下内容到~/.xprofile export GTK_IM_MODULE=fcitx5 export QT_IM_MODULE=fcitx5 export XMODIFIERS=@im=fcitx fctix5 不会自动启动，添加一下内容到~/.xprofile： fcitx5 \u0026 KDE 用户可以直接在系统设置模块-自动启动设置 双拼 or 五笔 在~/.local/share/fcitx5/rime/中 parse 下面 github 中的文件 https://github.com/jesse996/squirrel_config ","date":"2020-01-10","objectID":"/2020/01/%E8%AE%B0%E4%B8%80%E6%AC%A1fcitx5-rime%E5%AE%89%E8%A3%85/:0:0","tags":["Manjaro"],"title":"记一次fcitx5 Rime安装","uri":"/2020/01/%E8%AE%B0%E4%B8%80%E6%AC%A1fcitx5-rime%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"皮肤 修改皮肤：传送门 ","date":"2020-01-10","objectID":"/2020/01/%E8%AE%B0%E4%B8%80%E6%AC%A1fcitx5-rime%E5%AE%89%E8%A3%85/:0:1","tags":["Manjaro"],"title":"记一次fcitx5 Rime安装","uri":"/2020/01/%E8%AE%B0%E4%B8%80%E6%AC%A1fcitx5-rime%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"不是每个 trait 都可以作为 tarit 对象被使用，这和类型大小是否确认有关。每个 trait 都包含一个隐式的类型参数 Self，代表实现该 tarit 的实际类型。Self 默认有一个隐式的 tarit 限定?Sized，形如 Self:?Sized。?Sized trait 包含了所有的动态大小类型金额所有的可确定大小的类型。Rust 中大多数类型都是可确定的，就是\u003cT:Sized\u003e。 必须满足下面 2 条规则才可以当作 trait 对象使用： trait 的 Self 不能被限定为 Sized。 trait 中所有的方法都必须是对象安全的。 而对象安全的方法必须满足一下三点之一： 方法受 Self：Sized 约束 方法签名同时满足以下三点： （1）必须不包含任何泛型参数。 （2）第一个参数必须为 Self 类型或可以解引用为 Self 的类型 （3）Self 不能出现在第一个参数以外的地方，包括返回值 trait 中不能包含关联常量。 在实践中，只涉及到两条规则。如果一个 trait 中所有的方法有如下属性时，则该 trait 是对象安全的： 返回值类型不为 Self 方法没有任何泛型类型参数 每个文件定义一个模块。lib.rs 定义了一个和自己 crate 同名的模块；一个 mod.rs 定义了一个它所在文件夹名字的模块；其他的每个文件定义了一个同文件名的模块。 二进制 crate 的 root 必须是 main.rs，库 crate 的 root 必须是 lib.rs 单元测试通常和所测试的代码在同一个文件 集成测试，样例，benchmarks 都必须像其他用户一样导入 crate，只能用公开的 API。 ","date":"2019-12-30","objectID":"/2019/12/rust%E7%AC%94%E8%AE%B0/:0:0","tags":["Rust"],"title":"Rust笔记","uri":"/2019/12/rust%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"闭包 如果闭包中没有捕获任何环境变量，则默认自动实现 Fn 如果闭包中捕获了复制语义类型的环境变量，则 如果不需要修改环境变量，无论是否使用了 move，均会自动实现 Fn 如果需要修改环境变量，则自动实现 FnMut 如果闭包中捕获了移动语义类型的环境变量，则 如果不需要修改，且没有使用 move，则自动实现 FnOnce 如果不需要修改，且使用了 move，则自动实现 Fn 如果需要修改，则自动实现 FnMut 使用 move，如果捕获的变量是复制语义类型的，则闭包本身会自动实现 Copy/Clone,否则不会。 每个闭包表达式都是一个独立的类型，这会有一些不便，如不能把不同的闭包保存到一个数组中，但这可以通过把闭包当做 trait 对象来解决。把闭包放到 Box中就可以构建一个闭包的 trait 对象，然后就可以当做类型来使用， 三者关系： FnOnce-\u003e FnMut -\u003e Fn，即要实现 Fn，必须先实现前面 2 个。 rust 类型分为复制语义和移动语义，复制语义是指分配在栈上，所以复制的时候很简单，直接按位复制，不会出现内存不安全的情况。移动语义指分配在堆上，为了保证内存安全，才有了所有权系统，即一块内存只有有一个变量指向它。 对于复合类型来说，是复制还是移动，取决于其成员的类型，分为 2 种： 结构体，枚举体： 当成员全都是复制语义的时候，复合类型不会自动实现 Copy，要手动实现 Derive(Copy,Clone)，此时复合类型才是复制语义的。如果复合类型中的成员有移动语义的，则无法实现 Copy。 元组，数组，Option：类型会自动实现 Copy，如果元素均为复制语义，则元组就是复制，不需要手动再 Derive(Coyp,Clone)，否则元组就是移动语义的。 共享可变状态是万恶之源 每个 let 都会创建一个默认的词法作用域，这个作用域就是它的生命周期（lifetime），就是在这个词法作用域中存活，出了就死亡。 解引用会获得所有权。 显式生命周期参数是为了解决跨函数借用，编译器无法检查的问题。它只用于编译器的借用检查，来防止垂悬指针。 'b: 'a的意思是 b 的存活时间长于 a 结构体实例的生命周期应短于或等于任意一个成员的生命周期。 生命周期省略规则： 每个输入上对应一个不同的生命周期参数 如果只有一个输入，则输出生命周期等于这个输入的生命周期 如果有 self（\u0026self,\u0026mut self），则输出生命周期等于 self 的生命周期 trait 对象的生命周期默认以下规则： trait 对象的生命周期默认是’static 如果实现 trait 的类型包括\u0026‘a x 或\u0026‘a mut x，则默认生命周期就是’a 如果实现 trait 的类型包含多个类似 T：‘a 的从句，则生命周期需要明确指定 Cell 和 RefCell 的区别： Cell通过 set/get 来直接操作包裹的值，RefCell通过 borrow/borrow_mut。 Cell一般适合复制语义类型，即实现了 Copy，RefCell适合移动语义类型 Cell无运行时开销，不会再运行时 panic，RefCell 则有运行时开销，会 panic 写时复制 Cow Cow是一个枚举体智能指针，包括 2 个可选项： Borrowed：用于包裹引用 Woned：用于包裹所有者 cow 提供的功能是：以不可变的方式访问内容，在需要可变借用或所有权的时候再克隆一份数据。cow 要点： Cow实现了 Deref，所以可以直接调用 T 的不可变方法 在需要修改 T 时，可以使用 to_mut 方法获取可变借用。该方法会克隆，且仅克隆一次。如果 T 本身有所有权，则调用 to_mut 不会发生克隆 在需要修改 T 时，也可以用 into_owned 方法来获取一个拥有所有权的对象。如果 T 是借用类型，则会发生克隆，并创建新的有所有权的对象。如果 T 是所有权对象，则会将所有权转移到新的克隆对象。 Future Trait Future是 rust 异步的核心，代表一个将来会产生值的一个东东。调用poll方法可以让 future 朝着完成进行，如果完成了就返回 Pool::Ready(result)，否则返回Poll::Pending并加到事件循环队列中等待再次被wake方法调用。 Waker Waker 有一个 wake()方法，用来告诉执行器需要执行相关的任务，就会调用相关的 poll 方法。 Executor rust 的 future 都是懒执行的，就是说除非用主动推动完成才会完成，否则不会做任何事。一个推动 future 完成的方法是在 async 方法中用.await，但最外层的 future 如何完成呢？这就需要一个Future executor。 Executor 通过调用poll方法执行一系列最外层的 future。典型的，一旦一个 future 开始了，Executor 就会对之调用 poll 方法。当 future 暗示他们准备好了被调用 wake()更进一步，他们就会被放到队列中等待再次被 poll，不断重复直至完成。 先看看 Executor 的定义: struct Executor { ready_queue: Receiver\u003cArc\u003cTask\u003e\u003e } ","date":"2019-12-30","objectID":"/2019/12/rust%E7%AC%94%E8%AE%B0/:1:0","tags":["Rust"],"title":"Rust笔记","uri":"/2019/12/rust%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"基础知识 汇编语言，有 3 类指令组成： 汇编指令：机器码的助记符，有对应的机器码。 伪指令：没有对应机器码，由编译器执行，计算机并不执行。 其他符号：如+、-、*、\\，由编译器识别，没有对应机器码。 核心是编译指令。每一种 cpu 都有自己的汇编指令集。 存储器就是内存，存储器被划分为多个存储单元，从 0 开始顺序编号，一个存储单元就是一个字节（Byte）。存储器中指令和数据没有任何区别，都是二进制信息。 cpu 有 3 类总线：地址总线、数据总线、控制总线。 一个 cpu 有 n 根地址总线，则可以寻找 2 的 n 次方个内存单元。 n 根数据总线一次能传输 n 位，即 n bit。 控制总线是一些不同控制线的集合，有多少根控制总线，就意味着 cpu 提供了对外部器件的多少种控制。 内存地址空间：对 cpu 来说，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受 cpu 寻址能力的限制。这个逻辑存储器即是所说的内存地址空间。 寄存器 一个典型的 cpu 由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。前一章说的总线，相对于 cpu 内部来说是外部总线。 不同 cpu，寄存器的个数、结构都不同。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"通用寄存器 8086cpu 所有寄存器都是 16 位。AX、BX、CX、DX 这 4 个寄存器通常用来存放一般性数据，被称为通用寄存器。都可分为类似 AH 和 AL，BH 和 BL… 由于 8086 有 20 位地址总线，但 8086 是 16 位的，即在内部一次性处理、传输、暂时存储的地址只有 16 位，所以 8086 采用在内部用 2 个 16 位地址合成的方法来形成一个 20 位的物理地址。 地址加法器采用 物理地址=段地址x16+偏移地址 来合成物理地址。（也即左移 4 位，也即 x10H）。本质就是基础地址+偏移地址=物理地址。 cpu 可以用不同的段地址和偏移地址形成同一个物理地址。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"段寄存器 段地址存放在段寄存器中，8086 有 4 个段寄存器：CS、DS、SS、ES CS 和 IP 是 8086 中两个最关键的寄存器，它们共同表示了 cpu 当前要读取指令的地址。CS 为代码段寄存器，IP 为指令指针寄存器。 问：cpu 根据什么将内存中的信息看做是指令？ 答：cpu 将 CS:IP 指向的内存单元中的内容看做是指令。 在 cpu 中，程序员能用指令读写的部件只有寄存器。8086 大部分寄存器的值，都可以用mov来修改，mov称为传送指令。但不能用来设置 CS、IP 的值。 若想修改 CS、IP，可以用jmp指令，形如jmp 段地址：偏移地址。 若仅想修改 IP 的内容，可用形如jmp 某一合法寄存器，如jmp ax，可修改 IP 为 ax 中的值。 mov 可以操作的有：寄存器和寄存器，立即数到寄存器，寄存器和段寄存器，寄存器和内存单元，段寄存器和内存单元 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:2","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"代码段 我们可以根据需要，将一组内存单元定义为一个段。我们可以将长度为 N（N\u003c=64KB，因是 16 位）的一组代码，存在一组地址连续、起始地址为 16 的倍数的内存单元中，从而定义了一个代码段。那么代码段是如何被执行呢？只要将 CS：IP 指向代码段中第一条指令的首地址。 debug 用法 1.查看、修改 cpu 中寄存器的内容：R 2.查看内存中的内容：D 3.修改内存中的内容：E（可以写入数据、命令，无区别） 4.将内存中的内容解释为机器指令和对应的汇编指令：U 5.执行 CS：IP 指向的内存单元的指令：T 6.以汇编指令的形式向内存中写入命令：A 7.G 命令可以直接让 IP 跳到指定位置，如g 0012,会使 IP 跳到 0012 的位置。 8.用 p 命令可以从循环中一次循环完。也可以用 g 命令，直接跳到指定位置。 （T 命令在执行修改寄存器 SS 的指令时，下一条指令也紧接着执行） 寄存器（内存访问） 字单元：存放一个字型数据（16 位）的内存单元，由两个地址连续的内存单元组成。高地址存高位字节，低地址存地位字节。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:3","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"DS 和[address] DS 通常用来存放要访问数据的段地址。 将 10000H 中的数据读到 al 中 : mov bx,1000H mov ds,bx mov al,[0] mov 指令中的[]说明操作对象是一个内存单元,[]中的 0 说明偏移地址是 0，段地址默认是 ds。8086cpu 不支持将数据直接送入段寄存器，而是要用一个寄存器中转，即mov ds,1000H是非法的。 add、sub对段寄存器都是非法的，即add ds,ax,add ds,1,add, ds,[1]都是非法的。 综上，段寄存器的相关操作有: mov 段寄存器，寄存器 mov 寄存器，段寄存器 mov 段寄存器，内存单元 mov 内存单元，段寄存器 即段寄存器可以用 mov 与寄存器和内存单元进行操作（不能与数据），不能用add、sub ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"栈 push入栈，pop 出栈，如push ax,pop ax， SS:SP用来指向栈顶元素。 如图，8086 入栈时，栈顶从高地址向低地址方向增长。因为任意时刻SS：SP指向栈顶，所以当栈为空时，SS：SP指向栈的最底部单元下面的单元。 pop 与 push 相反 8086 不保证我们对栈的操作不会过界，我们只能自己注意。 push 和 pop 操作形式有如下几种: push 寄存器/段寄存器/内存单元 pop 寄存器/段寄存器/内存单元 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"段 段是我们人为规定的。 数据段：段地址放在 DS 中，用 mov、add、sub 等访问内存单元的指令时，cpu 就将我们单一的数据段中的内容当成数据来看。 代码段：段地址放在 CS 中，段中第一条指令的偏移地址放在 IP 中，cpu 将执行指令。 栈段：段地址放在 SS 中，栈顶元素的偏移地址放在 SP 中，cpu 进行站操作如 push、pop 时将栈段当做栈空间操作。 一段内存可以既是代码段又是数据段，又是栈段，也可以都不是。这取决于 CS、IP、SS、SP、DS 的指向。 第一个程序 汇编语言源程序包含两种指令： 1.汇编指令：有对应机器码，可以被编译为机器指令，最终被 cpu 执行。 2.伪指令：没有对应机器码，不被 cpu 执行，由编译器来执行。 assume cs:abc abc segment mov ax,2 add ax,ax add ax,ax mov ax,4c00H int 21H abc ends end segment segment和 ends是一对成对使用的伪指令，是必须要用到的一对伪指令，用来定义一个段，使用格式为： 段名 segment .. 段名 ends 一个汇编程序由多个段组成，这些段用来存放代码、数据或当做栈空间。一个有意义的汇编程序必须要有一个代码段。 end end是会变程序结束的标记，不要搞混end和ends，ends是和segment成对使用的。 assume 这条伪指令含义是“假设”，它假设某一段寄存器和程序的某一个用segment...ends定义的段相关联。只要记住 assume 是将有特定用途的段和相关联的段寄存器关联起来即可。 比如，用cname segment... cname ends定义了一个名为cname的段，在程序开头，用assume cs:cname将cname段和cs联系起来。 程序返回需要使用以下 2 条语句： mov ax,4c00H int 21H ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"loop 作用是循环，cpu 执行 loop 的时候，进行 2 部操作： 1.（cx）=（cx）-1 2.判断 cx 中的值，不为 0 则转到标号处执行，否则向下执行 在汇编源程序中，数据不能以字母开头，所以要在前面加 0。如，9100h 可以直接写为9100h，而 A000h 则要写为0A000h 程序加载后，ds 中存放着程序所在内存的段地址，偏移地址是 0。这个内存区前 256 个字节存放着的是 PSP，DOS 用来和程序进行通信，所以程序的地址可以表示为DS+10H:0 and 是逻辑与命令，or 是逻辑或命令。 大小写转换：一个字母，无论是大小写，将它的第 5 位置 0，就变成大写，第 5 位置 1，就变成小写。 si 和 di 是 8086 中与 bx 功能相近的寄存器，si 和 di 不能分成 2 个 8 位寄存器。 一般来说，在需要暂存数据的时候，我们都应该使用栈。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"bx，si，di，bp 在 8086 中，只有这 4 个寄存器可以用在[...]中来进行内存单元的寻址。 在[...]中，这 4 个寄存器可以单独出现，或只能以 4 种组合出现： 1.bx 和 si 2.bx 和 di 3.bp 和 si 4.bp 和 di 只要在[...]中使用 bp，而指令中没有显性给出段地址，那么段地址就默认在ss中。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"数据在什么地方？ 1.立即数：在 CPU 的指令缓存器中，如：mov ax,1 2.寄存器：在寄存器中，如：mov ax,bx 3.段地址（SA）和偏移地址（EA），如：mov ax,[0]（段地址默认是ds），mov ax,[bp]（段地址默认是ss） ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"数据有多长？ 数据有 2 种尺寸：byte和word 1.通过寄存器名指明要处理的数据的尺寸。 如指明进行字操作： mov ax,1 mov ds:[0],ax 指明进行字节操作： mov al,1 mov ds:[0],al 2.在没有寄存器名的情况下，用操作符X ptr指明内存单元的长度，X 可以为word或byte。如： 用word ptr指明了指令访问的内存单元是一个字单元： mov word ptr ds:[0],1 inc word ptr [bx] 用byte ptr指明是一个字节单元： mov byte ptr ds:[0],1 inc byte ptr [bx] 3.有些指令默认了访问的是字单元还是字节单元，如，push [1000H]，push 只进行字操作。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"div div 是除指令，要注意一下问题： 除数：8 位和 16 位两种，在一个寄存器或内存单元中。 被除数：默认放在 AX 或 DX 和 AX 中，如果除数为 8 位，被除数位 16 位，默认放在 AX 中；如果除数为 16 位，被除数为 32 位，在 DX 和 AX 中存放，DX 存高 16 位，AX 存低 16 位。 结果：如果除数为 8 位，则 AL 存储除法操作的商，AH 存储除法操作的余数；如果除数为 16 位，则 AX 存放商，DX 存放余数。 格式： div 寄存器 div 内存单元 div byte ptr ds:[0] 含义：（al）=（ax）/（（ds）*16+0）的商 (ah）=（ax）/（（ds）*16+0）的余数 div word ptr es:[0] 含义：（ax）= [（dx）*10000H+（ax）] /（（es））*16+0）的商 （dx）= [（dx）*10000H+（ax）] /（（es））*16+0）的余数 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"伪指令 dd db：用来定义字节型数据 dw：用来定义字型数据 dd：用来定义双字（define double word）型数据 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"dup dup 是一个操作符，它是和 db，dw，dd 配合使用的。如： db 3 dup (0) 定义了 3 个字节，值都是 0，相当于db 0,0,0 使用格式： db 重复的次数 dup （重复的字节型数据） dw 重复的次数 dup （重复的字型数据） dd 重复的次数 dup （重复的双字型数据） 转移指令的原理 可以修改 IP，或同时修改 CS 和 IP 的指令统称为转移指令。转移指令就是可以控制 cpu 执行内存中某处代码的指令。 8086 的转移行为有以下几类： 只修改 IP，称为段内转移，如：jmp ax 同时修改 CS 和 IP，称为段间转移，如：jmp 1000:0 段内转移又分为短转移和近转移： 短转移 IP 的修改范围为-128~127 近转移 IP 的修改分为为-32768~32767 转移指令有以下几类： 无条件转移（如：jmp） 条件转移 循环转移（如：loop） 过程 中断 这些转移的前提条件可能不同，但原理都相同。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"offset 由编译器处理，功能是取得标号的偏移地址。 start: mov ax,offset start ;相当于 mov ax,0（0是start的偏移地址） s: mov ax,offset s ;相当于 mov ax,3（3是s的偏移地址） ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:10:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"jmp 指令 jmp 可以只修改 IP，也可以修改同时 CS 和 IP jmp 指令要给出两种信息： 1.转移的目的地址 2.转移的距离 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"依据位移进行转移的 jmp 指令 jmp short 标号（转到标号处），short 指明是段内短转移（8 位位移），所对应的机器码并不包含转移的目的地址，而是包含的转移的位移 cpu 在指令 jmp 指令的时候，并不需要知道转移的目标地址。 类似的，有jmp near ptr 标号，实现的是段内近转移（16 位位移）。 位移 = 标号处的地址 - jmp 指令后的第一个字节的地址。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:1","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"依据转移的目的地址进行转移的 jmp 指令 jmp far ptr 标号实现的是段间转移，又称远转移 功能：（cs）= 标号所在段地址，（ip）= 标号在段中的偏移地址 机器码中有转移的目的地址 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:2","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"转移地址在寄存器中的 jmp 指令 格式：jmp 16 位寄存器 功能：（ip）= （16 位寄存器） ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:3","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"转移地址在内存中的 jmp 指令 有两种： jmp word ptr 内存单元地址(段内地址) 功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。 如： mov ax,0123H mov [bx],ax jmp word ptr [bx] 执行后，（IP）= 0123H 2.jmp dword ptr 内存单元地址(段内地址) 功能：从内存单元地址处开始存放着两个字，高地址是转移的目的段地址，低地址是转移的目的偏移地址。 如： mov ax,0123H mov [bx],ax mov word ptr [bx+2],0 jmp dword ptr [bx] 执行后，（CS）= 0，（IP）= 0123H 注意：形如 jmp 2000:1000的转移指令，是在 Debug 中使用的汇编指令，汇编编译器并不认识，如在源程序中使用，将编译报错。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:4","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"jcxz 指令 为有条件转移指令，所有的有条件转移指令都是短转移，相应机器码都是包含的位移，而不是目的地址。 格式： jcxz 标号（如果（cx）=0，转移到标号处执行） 操作： 当（cx）=0时，（ip）=（ip）+8位位移 相当于 if (cx==0) jmp short 标号 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:12:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"loop 指令 为循环指令，所有的循环指令都是短转移。 格式： loop 标号（（cx）= （cx）-1），如果（cx）!= 0，转移到标号处执行 操作： 1.（cx）=（cx）-1 2.如果（cx）!= 0 ，（ip）=（ip）+8 位位移 相当于： cx--; if (cx!=0) jmp short 标号; call 和 ret 指令 call 和 ret 都是转移指令，都修改 IP，或同时修改 CS 和 IP。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:13:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"ret 和 retf ret 指令用栈中数据，修改 IP 的内容，从而实现近转移 retf 指令用栈中数据，修改 CS 和 IP 的内容，从而实现远转移 执行 ret 指令时，cpu 执行以下 2 部操作： ip=ss*10H+sp sp=sp+2 相当于pop ip 执行 retf 指令时，进行下面 4 部操作： ip=ss*10H+sp sp=sp+2 cs=ss*10H+sp sp=sp+2 相当于pop ip ;pop cs ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:13:1","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"call 指令 执行 call 指令时，进行 2 部操作： 将当前 ip 或 cs 和 ip 压栈 转移 call 不能实现短转移，除此之外，call 实现转移的方法和 jmp 相同: call 标号：将当前 ip 压栈后，转到标号处执行,相当于： push ip jmp near ptr 标号 call far ptr 标号：实现段间转移,相当于： push cs push ip jmp far ptr 标号 call 16位寄存器：相当于： push ip jmp 16位寄存器 call word ptr 内存单元地址,相当于： push ip jmp word ptr 内存单元地址 call dword ptr 内存单元地址,相当于： push cs push ip jmp dword ptr 内存单元地址 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:13:2","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"mul 指令 mul 是乘法指令，要注意以下两点： 两个相乘的数：要么都是 8 位，要么都是 16 位。如果是 8 位，一个放在 al，一个放在 8 位寄存器或内存字节单元中；若是 16 位，一个在 ax，一个在 16 位寄存器中。 结果：如果是 8 位乘法，结果默认放在 ax 中；如果是 16 位，结果高位放在 dx，低位放在 ax。 解决除法溢出的方法： X/N = int( H/N)*65536 + [rem( H/N )*65536 + L ] / N X:被除数，N：除数，H：高 16 位，L：低 16 位，int：取商，rem：取余数 标志寄存器 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:13:3","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"ZF 标志（zero flag） flag 第 6 位是 ZF，零标志位。它记录执行相关指令后，其结果是否为 0。为 0 则 zf=1，否则 zf=0。 注意：8086 中，有些指令是影响 flag 的，比如：add、sub、mul、div、inc、or、and 等，它们大多是运算指令（逻辑或算数运算）；有一些则对 flag 没影响，如：mov，push，pop 等，大多是传送指令。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:14:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"PF 标志（Parity flag） flag 第 2 位是 PF，奇偶标志位。看执行结果的所有 bit 位中 1 的个数是否是偶数。是偶数则 pf=1，否则 pf=0。 可以理解成 1 偶标志位。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:15:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"SF 标志位（Sign Flag） flag 第 7 位是 SF，符号标志位。记录相关指令执行后结果是否为负。如果为负，sf=1；否则 sf=0 注意：sg 是 cpu 默认将数据当成有符号运算结果的记录。如果我们将数据当做无符号时，sf 时没有意义的，虽然相关指令可能影响了它的值。是不是有符号运算取决于我们。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:16:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"CF 标志位（Carry Flag） flag 第 0 位是 CF 标志位。一般情况下，在进行无符号数运算时，它记录了运算结果的最高有效位向更高位的进位值，或借位值。 inc 和 loop 指令不影响 cf ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:17:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"OF 标志位（Overflow Flag） flag 第 11 位是 OF，溢出标志位。记录了有符号运算的结果是否溢出。有溢出 of=1，否则 of=0； 注意和 CF 的区别： cf 是对无符号数运算有意义的标志位 of 是对有符号数运算有意义的标志位 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:18:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"adc 指令 adc 是带进位加法指令，它利用了 CF 位上记录的进位值。(add +carry –\u003e adc)如： adc ax,bx实现的功能是ax=ax+bx+cf。 cpu 提供 adc 的目的，就是来进行加法的第二步运算的。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:19:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"sbb 指令 sbb 是带借位减法指令（sub borrow），利用 cf 记录的借位值。 sbb ax,bx实现的功能是ax=ax-bx-cf。 cpu 提供 dbb 的目的，就是来进行减法的第二步运算的。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:20:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"cmp 指令 cmp 是比较指令，相当于减法指令，只是不保留结果。cmp 会对 flag 产生影响。如： cmp ax,ax做ax-ax运算，但并不在 ax 中保存，仅影响 flag。 进行·cmp ax,bx·比较后，通过 flag 可以看出比较结果 zf=1:ax=bx cf=1:ax\u003cbx cf=0:ax\u003e=bx cf=0 且 zf=0:ax\u003ebx cf=1 或 zf=1:ax\u003c=bx 注意：单纯的看 sf 的值不能判断结果的正负，因为可能会发生溢出。 而通过 sf 和 of 的值可以判断。 sf=1，of=0：没发生溢出，实际结果负，则逻辑结果也为负 sf=0，of=0：同上，逻辑结果非负 sf=1，of=1：有溢出，则实际与逻辑相反，逻辑为正。 sf=0，of=1：实际结果非负，又 of=1，则结果非 0，所以实际为正，逻辑结果为负。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:21:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"条件转移指令 通常配合 cmp，由 cmp 先进行比较，改变了 flag 中的值，条件转移指令根据 flag 中的值执行。 下面根据无符号数的比较进行转移的有： | 指令 | 含义 | 条件 | | —- | ———— | ————– | | je | 等于则转移 | 由 zf=1 则转移 | | jne | 不等于则转移 | zf=0 | | jb | 低于则转移 | cf=1 | | jnb | 不低于则转移 | cf=0 | | ja | 高于则转移 | cf=0 且 zf=0 | | jna | 不高于则转移 | cf=1 或 zf=1 | ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:22:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"DF 标志和串传送指令 flag 第 10 位是 DF，方向寄存器。在串处理指令中，控制每次操作后 si、di 的增减 df=0：每次操作后 si、di 递增 df=1：每次操作后 si、di 递减 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:23:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"movsb 指令 格式：movsb 相当于： mov es:[di],byte ptr ds:[si];（8086不支持这样的命令，这里只是描述） if df = 0: inc si inc di elif df = 1: dec si dec di ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:23:1","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"movsw 类似上面，就是 si,di 每次加或减 2 movsb和movsw进行的是串传送的一个步骤，通常配合rep使用,如： rep movsb，相当于： s:movsb loop s 可见rep是根据 cx 的值，重复执行后面的串传送指令。 cld 指令：可以将 df 置 0 std 指令：可以将 df 置 1 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:23:2","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"pushf 和 poopf pushf 功能是将标志寄存器的值压栈，popf 是从栈中弹出数据给标志寄存器中。 通过 pushf 和 popf，可以直接访问 flag call 和 ret 指令 call 和 ret 都是转移指令，都修改 IP，或同时修改 CS 和 IP。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:24:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"ret 和 retf ret 指令用栈中数据，修改 IP 的内容，从而实现近转移 retf 指令用栈中数据，修改 CS 和 IP 的内容，从而实现远转移 执行 ret 指令时，cpu 执行以下 2 部操作： ip=ss*10H+sp sp=sp+2 相当于pop ip 执行 retf 指令时，进行下面 4 部操作： ip=ss*10H+sp sp=sp+2 cs=ss*10H+sp sp=sp+2 相当于pop ip ;pop cs ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:24:1","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"call 指令 执行 call 指令时，进行 2 部操作： 将当前 ip 或 cs 和 ip 压栈 转移 call 不能实现短转移，除此之外，call 实现转移的方法和 jmp 相同: call 标号：将当前 ip 压栈后，转到标号处执行,相当于： push ip jmp near ptr 标号 call far ptr 标号：实现段间转移,相当于： push cs push ip jmp far ptr 标号 call 16位寄存器：相当于： push ip jmp 16位寄存器 call word ptr 内存单元地址,相当于： push ip jmp word ptr 内存单元地址 call dword ptr 内存单元地址,相当于： push cs push ip jmp dword ptr 内存单元地址 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:24:2","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"mul 指令 mul 是乘法指令，要注意以下两点： 两个相乘的数：要么都是 8 位，要么都是 16 位。如果是 8 位，一个放在 al，一个放在 8 位寄存器或内存字节单元中；若是 16 位，一个在 ax，一个在 16 位寄存器中。 结果：如果是 8 位乘法，结果默认放在 ax 中；如果是 16 位，结果高位放在 dx，低位放在 ax。 解决除法溢出的方法： X/N = int( H/N)*65536 + [rem( H/N )*65536 + L ] / N X:被除数，N：除数，H：高 16 位，L：低 16 位，int：取商，rem：取余数 标志寄存器 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:24:3","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"ZF 标志（zero flag） flag 第 6 位是 ZF，零标志位。它记录执行相关指令后，其结果是否为 0。为 0 则 zf=1，否则 zf=0。 注意：8086 中，有些指令是影响 flag 的，比如：add、sub、mul、div、inc、or、and 等，它们大多是运算指令（逻辑或算数运算）；有一些则对 flag 没影响，如：mov，push，pop 等，大多是传送指令。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:25:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"PF 标志（Parity flag） flag 第 2 位是 PF，奇偶标志位。看执行结果的所有 bit 位中 1 的个数是否是偶数。是偶数则 pf=1，否则 pf=0。 可以理解成 1 偶标志位。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:26:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"SF 标志位（Sign Flag） flag 第 7 位是 SF，符号标志位。记录相关指令执行后结果是否为负。如果为负，sf=1；否则 sf=0 注意：sg 是 cpu 默认将数据当成有符号运算结果的记录。如果我们将数据当做无符号时，sf 时没有意义的，虽然相关指令可能影响了它的值。是不是有符号运算取决于我们。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:27:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"CF 标志位（Carry Flag） flag 第 0 位是 CF 标志位。一般情况下，在进行无符号数运算时，它记录了运算结果的最高有效位向更高位的进位值，或借位值。 inc 和 loop 指令不影响 cf ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:28:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"OF 标志位（Overflow Flag） flag 第 11 位是 OF，溢出标志位。记录了有符号运算的结果是否溢出。有溢出 of=1，否则 of=0； 注意和 CF 的区别： cf 是对无符号数运算有意义的标志位 of 是对有符号数运算有意义的标志位 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:29:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"adc 指令 adc 是带进位加法指令，它利用了 CF 位上记录的进位值。(add +carry –\u003e adc)如： adc ax,bx实现的功能是ax=ax+bx+cf。 cpu 提供 adc 的目的，就是来进行加法的第二步运算的。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:30:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"sbb 指令 sbb 是带借位减法指令（sub borrow），利用 cf 记录的借位值。 sbb ax,bx实现的功能是ax=ax-bx-cf。 cpu 提供 dbb 的目的，就是来进行减法的第二步运算的。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:31:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"cmp 指令 cmp 是比较指令，相当于减法指令，只是不保留结果。cmp 会对 flag 产生影响。如： cmp ax,ax做ax-ax运算，但并不在 ax 中保存，仅影响 flag。 进行·cmp ax,bx·比较后，通过 flag 可以看出比较结果 zf=1:ax=bx cf=1:ax\u003cbx cf=0:ax\u003e=bx cf=0 且 zf=0:ax\u003ebx cf=1 或 zf=1:ax\u003c=bx 注意：单纯的看 sf 的值不能判断结果的正负，因为可能会发生溢出。 而通过 sf 和 of 的值可以判断。 sf=1，of=0：没发生溢出，实际结果负，则逻辑结果也为负 sf=0，of=0：同上，逻辑结果非负 sf=1，of=1：有溢出，则实际与逻辑相反，逻辑为正。 sf=0，of=1：实际结果非负，又 of=1，则结果非 0，所以实际为正，逻辑结果为负。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:32:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"条件转移指令 通常配合 cmp，由 cmp 先进行比较，改变了 flag 中的值，条件转移指令根据 flag 中的值执行。 下面根据无符号数的比较进行转移的有： | 指令 | 含义 | 条件 | | —- | ———— | ————– | | je | 等于则转移 | 由 zf=1 则转移 | | jne | 不等于则转移 | zf=0 | | jb | 低于则转移 | cf=1 | | jnb | 不低于则转移 | cf=0 | | ja | 高于则转移 | cf=0 且 zf=0 | | jna | 不高于则转移 | cf=1 或 zf=1 | ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:33:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"DF 标志和串传送指令 flag 第 10 位是 DF，方向寄存器。在串处理指令中，控制每次操作后 si、di 的增减 df=0：每次操作后 si、di 递增 df=1：每次操作后 si、di 递减 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:34:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"movsb 指令 格式：movsb 相当于： mov es:[di],byte ptr ds:[si];（8086不支持这样的命令，这里只是描述） if df = 0: inc si inc di elif df = 1: dec si dec di ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:34:1","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"movsw 类似上面，就是 si,di 每次加或减 2 movsb和movsw进行的是串传送的一个步骤，通常配合rep使用,如： rep movsb，相当于： s:movsb loop s 可见rep是根据 cx 的值，重复执行后面的串传送指令。 cld 指令：可以将 df 置 0 std 指令：可以将 df 置 1 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:34:2","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"pushf 和 poopf pushf 功能是将标志寄存器的值压栈，popf 是从栈中弹出数据给标志寄存器中。 通过 pushf 和 popf，可以直接访问 flag ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:35:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"修改源 sudo pacman-mirrors -i -c China -m rank //更新镜像排名 sudo pacman -Syy //更新数据源 sudo pacman -S archlinux-keyring//更新 archlinux 签名 ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:1:0","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"设置 archlinuxcn 源。 修改 /etc/pacman.conf 最后增加 [archlinuxcn] SigLevel = Optional TrustedOnly Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:1:1","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"更新系统 sudo pacman -Syy ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:2:0","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"安装archlinuxcn-keyring: sudo pacman -S archlinuxcn-keyring sudo pacman -Syy ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:3:0","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"修改 Home 下的目录为英文： 修改目录映射文件名； gedit ~/.config/user-dirs.dirs 修改为以下内容： XDG_DESKTOP_DIR=\"$HOME/Desktop\" XDG_DOWNLOAD_DIR=\"$HOME/Downloads\" XDG_TEMPLATES_DIR=\"$HOME/Templates\" XDG_PUBLICSHARE_DIR=\"$HOME/Public\" XDG_DOCUMENTS_DIR=\"$HOME/Documents\" XDG_MUSIC_DIR=\"$HOME/Music\" XDG_PICTURES_DIR=\"$HOME/Pictures\" XDG_VIDEOS_DIR=\"$HOME/Videos\" 将 Home 目录下的中文目录名改为对应的中文名； cd ~ mv 公共 Public mv 模板 Templates mv 视频 Videos mv 图片 Pictures mv 文档 Documents mv 下载 Downloads mv 音乐 Music mv 桌面 Desktop 重启系统。 ##安装 chrome sudo pacman -S google-chrome ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:4:0","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"安装和使用 oh-my-zsh 安装 oh-my-zsh 的配置 查看本地有哪几种 shell cat /etc/shells manjaro 默认已经安装了 zsh 安装 oh-my-zsh 的配置文件 #via curl sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" #或者 via wget sh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" 替换 zsh 的配置文件为 oh-my-zsh cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:5:0","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"安装插件 安装 zsh-autosuggestions git clone https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/plugins/zsh-autosuggestions 安装 zsh-syntax-highlighting git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ~/.oh-my-zsh/plugins/zsh-syntax-highlighting 安装 zsh-nvm git clone https://github.com/lukechilds/zsh-nvm ~/.oh-my-zsh/custom/plugins/zsh-nvm 安装 autojump sudo pacman -S autojump 在~/.zshrc中找到 plugins=( git ) 在括号中 git 的下一行添加插件名称使其生效 plugins=( git zsh-syntax-highlighting zsh-autosuggestions autojump zsh-nvm ) ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:5:1","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"更改主题\u0026\u0026lazyload nvm gedit ~/.zshrc ZSH_THEME=\"agnoster\" export NVM_LAZY_LOAD=true 刷新配置，使之生效 source ~/.zshrc ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:5:2","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"油酸乳 下载 脚本文件 wget http://www.djangoz.com/ssr#//github.com/the0demiurge/CharlesScripts/blob/master/charles/bin/ssr ssr 是一个 shell 脚本 执行脚本 sudo mv ssr /usr/local/bin sudo chmod 766 /usr/local/bin/ssr ssr install ssr config 然后在系统设置里设置网络代理为手动 ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:5:3","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"开机自启动 在/usr/lib/systemd/system/中加入ssr.service [Unit] Description=AutoRunSSR [Service] Type=forking ExecStart=ssr start [Install] WantedBy=multi-user.target 然后输入命令 systemctl enable ssr.service systemctl start ssr.service 可以查看状态 systemctl status ssr.service ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:5:4","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"设置 chrome 为默认浏览器: 在设置中把 html 关联类型设置为用 chrome 打开 ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:5:5","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"每元素都有一个外在盒子和容器盒子(内在盒子) 外在盒子负责元素是否一行显示 容器盒子负责元素的宽高、内容呈现 块级元素 外在盒子是 block 的元素 都有主块级盒子 list-item 还有一个附加盒子(IE 伪元素不支持附加盒子) ","date":"2018-08-11","objectID":"/2018/08/css%E7%AC%94%E8%AE%B0/:0:0","tags":["CSS"],"title":"CSS笔记","uri":"/2018/08/css%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"width : auto 充分利用可用空间，块级元素默认 100% 收缩与包裹。代表是浮动、绝对定位、inline-block、table 元素 收缩到最小 超出容器限制。内容很长的连续英文和数字，或者设置了 white-space:nowrap （除了第一个是外部尺寸，其余都是内部尺寸。分别对应以下的外部尺寸和内部尺寸） 外部尺寸 正常 width 是 100% 格式化宽度 出现在 position 为 absolute 和 fixed 元素中。 默认绝对定位元素宽度是由内部尺寸决定，除了当 left 和 right 或 top 和 bottom 同时出现时，其宽度相对于最近的具有定位特性的祖先元素计算 内部尺寸 包裹性 顾名思义，尺寸由内部元素决定，单永远小于包含块容器尺寸 首选最小宽度 当外部容器盒子宽度为 0，内部的内联盒子就是首选最小宽度 中文，为单个汉子宽度 西文遇到空格、-、?、其他非英文字符，就会换行 类似图片这样的替换元素，就是元素本身的宽度 最大宽度 等同于 包裹性 元素设置 white-sapce:nowrap 后的宽度 是最大的连续内联盒子的宽度 height 如何让元素支持 height:100% 效果？ 设置父元素高度 使用绝对定位 绝对定位的宽高百分比是相对于 padding box，其他是相对于 content box min-width/height 和 max-width/height min-width/min-height 初始值是 auto，max-* 是 none max-width 会覆盖width，即使是width:xpx !important min-width会覆盖max-width 内联元素 外在盒子是内联盒子的元素 ","date":"2018-08-11","objectID":"/2018/08/css%E7%AC%94%E8%AE%B0/:1:0","tags":["CSS"],"title":"CSS笔记","uri":"/2018/08/css%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"内联盒子模型 内容区域 围绕文字的盒子 内联盒子 是元素外在盒子 行框盒子 每一行就是一个行框盒子 包含盒子（包含块） 由一行一行的行框盒子组成，是父元素外面的盒子 ","date":"2018-08-11","objectID":"/2018/08/css%E7%AC%94%E8%AE%B0/:1:1","tags":["CSS"],"title":"CSS笔记","uri":"/2018/08/css%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"幽灵空白节点（strut） 内联元素的解析就像每个行框盒子前面都有一个空白节点，宽度为 0 ","date":"2018-08-11","objectID":"/2018/08/css%E7%AC%94%E8%AE%B0/:1:2","tags":["CSS"],"title":"CSS笔记","uri":"/2018/08/css%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"替换元素 内容可替换的元素，如： \u003cimg\u003e,\u003cobject\u003e,\u003cvideo\u003e,\u003ciframe\u003e,\u003cinput\u003e,\u003ctextarea\u003e,\u003cselect\u003e 有如下特性： 外观不受 css 影响 有自己的尺寸 很多 css 属性有自己的一套表现规则。如 vertical-align ，替换元素的baseline是元素的下边缘，非替换元素是x的下边缘 替换元素默认 dispay 值 都是inline或inline-block 主要记: \u003cimg\u003e是inline \u003cinput\u003e是inline-block_（火狐是 inline）_ \u003cinput\u003e和\u003cbutton\u003e区别： 前者white-space是 pre，后者是 normal white-space: normal (默认) 连续的空白符会被合并，换行符会被当作空白符来处理。填充 line 盒子时，必要的话会换行 nowrap 和 normal 一样，连续的空白符会被合并。但文本内的换行无效 pre 连续的空白符会被保留。在遇到换行符或者\u003cbr\u003e元素时才会换行。 pre-wrap 连续的空白符会被保留。在遇到换行符或者\u003cbr\u003e元素，或者需要为了填充 line 盒子时才会换行。 pre-line 连续的空白符会被合并。在遇到换行符或者\u003cbr\u003e元素，或者需要为了填充 line 盒子时会换行。 换行符 空格和 tap 文字转行 normal 空白符 合并 yes nowrap 空白符 合并 no pre 换行 保留 no pre-wrap 换行 保留 yes pre-line 换行 合并 yes ","date":"2018-08-11","objectID":"/2018/08/css%E7%AC%94%E8%AE%B0/:1:3","tags":["CSS"],"title":"CSS笔记","uri":"/2018/08/css%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"替换元素尺寸 固有尺寸 原本尺寸，无法改变 HTML 尺寸 通过 HTML 属性改变的尺寸，如： img的width,height input的size属性 textarea的cols和rows CSS 尺寸 通过 CSS 改变的尺寸 从下都上，优先级递减 Firefox 中没有src属性的img元素是inline元素 css 之所以可以改变图片的大小，是因为图片中的 comtent 默认的object-fit是fill ","date":"2018-08-11","objectID":"/2018/08/css%E7%AC%94%E8%AE%B0/:1:4","tags":["CSS"],"title":"CSS笔记","uri":"/2018/08/css%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"替换元素离非替换元素有多远？ 只隔了一个src Firefox 直接就行，Chrome 要有一个不为空的 alt 值 只隔了一个content属性 counter:url('...') ","date":"2018-08-11","objectID":"/2018/08/css%E7%AC%94%E8%AE%B0/:1:5","tags":["CSS"],"title":"CSS笔记","uri":"/2018/08/css%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"content 计数器 counter-reset 给计数器起名，和从那个数字开始计数 .xxx{ counter-reset:name 2} 名字就是 name ，从 2 开始，默认 0，数字不合符当 0 处理 可以多个计数器同时命名 .xxx{ counter-reset:name 2 name2 3} counter-increment key 为 counter-reset 的名字，值是每次增加的值，没有则默认 1，也可以有多个 key 用空格如同 counter-reset .counter { counter-reset: szx 2; counter-increment: szx 1; } .counter::before { content: counter(szx); } counter-increment 在父元素或子元素都有效 方法counter( ) / counters( ) counter(name[,style]) style 支持的值就是list-style-type支持的值，作用是增减可以是英文字母或罗马文 一个 content 可以有多个 content( )方法 counters(name,string[,style]) string 必须，表示子序号的链接字符,style 同上 reset 不要和 counter 同级 ","date":"2018-08-11","objectID":"/2018/08/css%E7%AC%94%E8%AE%B0/:2:0","tags":["CSS"],"title":"CSS笔记","uri":"/2018/08/css%E7%AC%94%E8%AE%B0/"}]