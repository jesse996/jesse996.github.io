[{"categories":["leetcode"],"content":"第 350 题：两个数组的交集 给定两个数组，编写一个函数来计算它们的交集。 ","date":"2020-08-20","objectID":"/leetcode/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/:1:0","tags":null,"title":"两个数组的交集","uri":"/leetcode/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"},{"categories":["leetcode"],"content":"示例 1: 输入: nums1 = [1,2,2,1], nums2 = [2,2] 输出: [2,2] ","date":"2020-08-20","objectID":"/leetcode/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/:1:1","tags":null,"title":"两个数组的交集","uri":"/leetcode/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"},{"categories":["leetcode"],"content":"示例 2: 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出: [4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。 我们可以不考虑输出结果的顺序。 进阶: 如果给定的数组已经排好序呢？将如何优化你的算法呢？ ","date":"2020-08-20","objectID":"/leetcode/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/:1:2","tags":null,"title":"两个数组的交集","uri":"/leetcode/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"},{"categories":["leetcode"],"content":"分析 首先拿到这道题，我们基本马上可以想到，此题可以看成是一道传统的映射题（map 映射），为什么可以这样看呢，因为我们需找出两个数组的交集元素，同时应与两个数组中出现的次数一致。这样就导致了我们需要知道每个值出现的次数，所以映射关系就成了\u003c元素,出现次数\u003e。剩下的就是顺利成章的解题。 //方法一，用map public int[] intersect(int[] nums1, int[] nums2) { Map\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e(); for (int i : nums1) { int count = map.getOrDefault(i, 0); map.put(i, count + 1); } int k = 0; for (int i : nums2) { int count = map.getOrDefault(i, 0); if (count \u003e 0) { nums2[k++] = i; map.put(i, count - 1); } } return Arrays.copyOfRange(nums2, 0, k); } 对于两个已经排序好数组的题，我们可以很容易想到使用双指针的解法: 如果两个指针的元素不相等，我们将小的一个指针后移,直到任意一个数组终止。 //方法二：如果排好序 public int[] intersect2(int[] nums1, int[] nums2) { Arrays.sort(nums1); Arrays.sort(nums2); int i = 0, j = 0, k = 0; while (i \u003c nums1.length \u0026\u0026 j \u003c nums2.length) { if (nums1[i] == nums2[j]) { nums1[k] = nums1[i]; i++; j++; k++; } else if (nums1[i] \u003e nums2[j]) { j++; } else { i++; } } return Arrays.copyOfRange(nums1,0,k); } ","date":"2020-08-20","objectID":"/leetcode/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/:1:3","tags":null,"title":"两个数组的交集","uri":"/leetcode/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"},{"categories":["leetcode"],"content":"题目 14: 最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，则返回”” ","date":"2020-08-20","objectID":"/leetcode/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/:1:0","tags":null,"title":"最长公共前缀","uri":"/leetcode/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"},{"categories":["leetcode"],"content":"示例 1: 输入: [\"flower\",\"flow\",\"flight\"] 输出: \"fl\" ","date":"2020-08-20","objectID":"/leetcode/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/:1:1","tags":null,"title":"最长公共前缀","uri":"/leetcode/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"},{"categories":["leetcode"],"content":"示例 2: 输入: [\"dog\",\"racecar\",\"car\"] 输出: \"\" 解释:输入不存在公共前缀。 说明： 所有输入只包含小写字母 a-z ","date":"2020-08-20","objectID":"/leetcode/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/:1:2","tags":null,"title":"最长公共前缀","uri":"/leetcode/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"},{"categories":["leetcode"],"content":"分析 我们要想寻找最长公共前缀，那么首先这个前缀是公共的，我们可以从任意一个元素中找到它。那么首先，我们可以将第一个元素设置为基准元素 x0。假如数组为[\"flow\",\"flower\",\"flight\"]，flow 就是我们的基准元素 x0。 然后我们只需要依次将基准元素和后面的元素进行比较（假定后面的元素依次为 x1,x2,x3....），不断更新基准元素(截取掉基准元素最后一个元素)，直到基准元素和所有元素都满足最长公共前缀的条件，就可以得到最长公共前缀。 public String longestCommonPrefix(String[] strs) { if (strs.length == 0) return \"\"; String prefix = strs[0]; for (String str : strs) { while (str.indexOf(prefix) != 0) { if (prefix.length() \u003c= 0) return \"\"; prefix = prefix.substring(0, prefix.length() - 1); } } return prefix; } pubfn longest_common_prefix(strs: Vec\u003cString\u003e)-\u003e String {ifstrs.is_empty(){return\"\".to_string();}letmutprefix=\u0026strs[0][..];forstrinstrs.iter(){while!str.starts_with(prefix){ifprefix.len()==0{return\"\".to_string();}prefix=\u0026prefix[0..prefix.len()-1];}}prefix.into()} ","date":"2020-08-20","objectID":"/leetcode/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/:2:0","tags":null,"title":"最长公共前缀","uri":"/leetcode/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"},{"categories":["剑指offer","leetcode"],"content":"请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 思路：和上一题相比，只用最后 reverse 一下 list 就可以了 /** * 例如: * 给定二叉树：[3,9,20,null,null,15,7], * \u003cp\u003e * 3 * / \\ * 9 20 * / \\ * 15 7 * 返回其层次遍历结果： * \u003cp\u003e * [ * [3], * [20,9], * [15,7] * ] */ public List\u003cList\u003cInteger\u003e\u003e levelOrder(TreeNode root) { boolean left2right = true; List\u003cList\u003cInteger\u003e\u003e res = new ArrayList\u003c\u003e(); Queue\u003cTreeNode\u003e queue = new ArrayDeque\u003c\u003e(); if (root != null) queue.add(root); while (!queue.isEmpty()) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); for (int i = queue.size(); i \u003e 0; i--) { TreeNode node = queue.poll(); list.add(node.val); if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); } if (left2right) { res.add(list); } else { Collections.reverse(list); res.add(list); } left2right = !left2right; } return res; } class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } ","date":"2020-08-18","objectID":"/leetcode/offer/32_3/:0:0","tags":null,"title":"32_3","uri":"/leetcode/offer/32_3/"},{"categories":["算法"],"content":"定义 流量网络：一个流量网络是一张边的权重（这里称为容量）为正的加权有向图。一个 st-流量网络有两个已知的顶点，即起点 s 和终点 t 流量配置：由一组和每条边相关的值组成的集合，这个值被称为边的流量。如果所有边的流量均小于边的容量且满足每个顶点的局部平衡（即净流量均为 0，s 和 t 除外），那么就称这种流量配置方案是可行的。 ","date":"2020-08-18","objectID":"/2020/08/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E7%AE%97%E6%B3%95/:1:0","tags":["算法"],"title":"网络流量算法","uri":"/2020/08/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"检查流量网络中的一种流量配置是否可行 private boolean localEq(FlowNetwork G,int v){ double EPSILON = 1E-11; double netflow = 0.0; for (FlowEdge e: G.adj(v)){ if (v == e.from()) netflow -= e.flow(); else netflow += e.flow(); } return Math.abs(netflow) \u003c EPSILON; } private boolean isFeasible(FlowNetwork G){ for (int v = 0; v \u003c G.V(); v++){ for(e.flow() \u003c 0 || e.flow() \u003e e.capacity()) return false; } for (int v = 0; v \u003c G.V(); v++) if (v != s \u0026\u0026 v != t \u0026\u0026 !localEq(v)) return false; return true; } ","date":"2020-08-18","objectID":"/2020/08/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E7%AE%97%E6%B3%95/:2:0","tags":["算法"],"title":"网络流量算法","uri":"/2020/08/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"Ford-Fulkerson 最大流量算法 网络中的初始流量为零，沿着任意从起点到终点（且不含有饱和的长相边或者是空的逆向边）的增广路径增大流量，知道网络中不存在这样的路径为止。 ","date":"2020-08-18","objectID":"/2020/08/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E7%AE%97%E6%B3%95/:3:0","tags":["算法"],"title":"网络流量算法","uri":"/2020/08/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"最大流-最小切分定义 ","date":"2020-08-18","objectID":"/2020/08/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E7%AE%97%E6%B3%95/:4:0","tags":["算法"],"title":"网络流量算法","uri":"/2020/08/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"定义 st-切分是一个将顶点 s 和顶点 t 分配于不同集合中的切分。 一个 st-切分的容量为该切分的 st-边的容量之和 st-切分的跨切分流量为该切分的 st-边的流量之和于 ts-边的流量之和的差 最小 st-切分：给定一个 st-网络，找到容量最小的 st-切分 ","date":"2020-08-18","objectID":"/2020/08/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E7%AE%97%E6%B3%95/:4:1","tags":["算法"],"title":"网络流量算法","uri":"/2020/08/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"定理 对于任意 st-流量网络，每种 st-切分中的跨切分流量都和总流量的值相等 s 的流出量等于 t 的流入量（即 st-流量网络的值） st-流量网络的值不可能超过任意 st-切分的容量 令 f 为一个 st-流量网络，一下三种条件是等价的： 存在某个 st-切分，其容量和 f 的流量相等 f 达到了最大流量 f 中已经不存在任何蹭广路径 当所有容量均为整数时，存在一个整数值的最大流量，而 Ford-Fulkerson 算法能够找出这个最大值 ","date":"2020-08-18","objectID":"/2020/08/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E7%AE%97%E6%B3%95/:4:2","tags":["算法"],"title":"网络流量算法","uri":"/2020/08/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"剩余网络 ","date":"2020-08-18","objectID":"/2020/08/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E7%AE%97%E6%B3%95/:5:0","tags":["算法"],"title":"网络流量算法","uri":"/2020/08/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"定义 给定某个 st-流量网络和其 st-流量配置，这种配置下的剩余网络中的顶点和原网络相同。原网络中的每条边都对应着剩余网络中的 1~2 条边。它的定义如下：对于原网络中的每条从顶点 v 到 w 的边 e，令$f_x$ 表示它的流量，$c_e$表示它的容量。如果$f_e$为正，将w-\u003ev加入剩余网络且容量为$f_e$；如果$f_e$小于$c_e$，将 w-\u003ew 加入剩余网络且容量为$c_e-f_e$ ","date":"2020-08-18","objectID":"/2020/08/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E7%AE%97%E6%B3%95/:5:1","tags":["算法"],"title":"网络流量算法","uri":"/2020/08/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"网络流量中的边（剩余网络） public class FlowEdge { private final int v; private final int w; private final double capacity; private double flow; public FlowEdge(int v, int w, double capacity){ ... } public int from(){return v;} public int to(){return w;} public double capacity(){return capacity;} public double flow(){return flow;} public int other(int vertex){ return vertex == v ? w : v; } public double residualCapacityTo(int vertex){ if (vertex == v) return flow; else if (vertex == w) return capacity -flow; else throw new RuntimeException(\"Inconsistent dege\"); } public void addResidualFlowTo(int vertex,double delta){ if (vertex == v) flow -= delta; else if (vertex == w) flow += delta; else throw new RuntimeException(\"Inconsistent dege\"); } } ","date":"2020-08-18","objectID":"/2020/08/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E7%AE%97%E6%B3%95/:6:0","tags":["算法"],"title":"网络流量算法","uri":"/2020/08/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"FordFulkerson 实现 public class FordFulkerson{ private boolean[] marked; private FlowEdge[] edgeTo; private double value; public FordFulkerson(FlowNetwork G,int s,int t){ while (hasAugmentingPath(G, s, t)) { // 计算瓶颈 double bottle = Double.POSITIVE_INFINITY; for (int v = t; v != s; v = edgeTo[v].other(v)) { bottle = Math.min(bottle, edgeTo[v].residualCapacityTo(v)); } // 增大流量 for (int v = t; v != s; v = edgeTo[v].other(v)) { edgeTo[v].addResidualFlowTo(v, bottle); } value += bottle; } } public double value() { return value; } //返回true如果v属于最小切分 public boolean inCut(int v) { return marked[v]; } private boolean hasAugmentingPath(FlowNetwork G, int s, int t) { edgeTo = new FlowEdge[G.V()]; marked = new boolean[G.V()]; // breadth-first search Queue\u003cInteger\u003e queue = new Queue\u003cInteger\u003e(); queue.enqueue(s); marked[s] = true; while (!queue.isEmpty() \u0026\u0026 !marked[t]) { int v = queue.dequeue(); for (FlowEdge e : G.adj(v)) { int w = e.other(v); // if residual capacity from v to w if (e.residualCapacityTo(w) \u003e 0 \u0026\u0026 !marked[w]) { edgeTo[w] = e; marked[w] = true; queue.enqueue(w); } } } // is there an augmenting path? return marked[t]; } public static void main(String[] args) { // create flow network with V vertices and E edges int V = Integer.parseInt(args[0]); int E = Integer.parseInt(args[1]); int s = 0, t = V-1; FlowNetwork G = new FlowNetwork(V, E); StdOut.println(G); // compute maximum flow and minimum cut FordFulkerson maxflow = new FordFulkerson(G, s, t); StdOut.println(\"Max flow from \" + s + \" to \" + t); for (int v = 0; v \u003c G.V(); v++) { for (FlowEdge e : G.adj(v)) { if ((v == e.from()) \u0026\u0026 e.flow() \u003e 0) StdOut.println(\" \" + e); } } // print min-cut StdOut.print(\"Min cut: \"); for (int v = 0; v \u003c G.V(); v++) { if (maxflow.inCut(v)) StdOut.print(v + \" \"); } StdOut.println(); StdOut.println(\"Max flow value = \" + maxflow.value()); } } ","date":"2020-08-18","objectID":"/2020/08/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E7%AE%97%E6%B3%95/:7:0","tags":["算法"],"title":"网络流量算法","uri":"/2020/08/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"定义 ","date":"2020-08-15","objectID":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/:1:0","tags":["SA-IS"],"title":"后缀数组及SA-IS算法笔记","uri":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"categories":["算法"],"content":"字符串 字符串s连续的一段字符组成的串叫做字符串，更广义地，任何一个由可比较大小的元素组成的数组都可称为字符串。字符串的下标从0开始，长度为length(s) ","date":"2020-08-15","objectID":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/:1:1","tags":["SA-IS"],"title":"后缀数组及SA-IS算法笔记","uri":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"categories":["算法"],"content":"后缀 suffix(i)表示字符串从s第i个位置开始的后缀，即由s[i]~s[n-1]组成的子串 ","date":"2020-08-15","objectID":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/:1:2","tags":["SA-IS"],"title":"后缀数组及SA-IS算法笔记","uri":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"categories":["算法"],"content":"后缀数组 sa[]是一个一维数组，保存了字符串s的所有后缀排序后的结果 rank[]是一个一维数组，保存了每个后缀在sa[]中的排名，rank[i]表示suffix(i)的排名，即rank[sa[i]]=i height[]是一个一维数组，保存了相邻两个后缀的最长公共前缀（Longest Common Prefix,lcp）的长度 ","date":"2020-08-15","objectID":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/:1:3","tags":["SA-IS"],"title":"后缀数组及SA-IS算法笔记","uri":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"categories":["算法"],"content":"一个简单的实现 public String longestDupSubstring(String S) { int n=S.length(); String[] sa=new String[n]; for (int i=0;i\u003cn;i++){ sa[i]=S.substring(i); } Arrays.sort(sa); String max=\"\"; for (int i=1;i\u003cn;i++){ int len=lcp(sa[i-1],sa[i]); if (len\u003emax.length()) max=sa[i].substring(0,len); } return max; } static int lcp(String a,String b){ int n =Math.min(a.length(),b.length()); for (int i=0;i\u003cn;i++){ if (a.charAt(i)!=b.charAt(i)) return i; } return n; } int n, k; const int MAXN = 100005; int rank[MAXN + 1]; int tmp[MAXN + 1]; int sa[MAXN], lcp[MAXN]; bool compare_sa(int i, int j) { if (rank[i] != rank[j]) return rank[i] \u003c rank[j]; else { int ri = i + k \u003c= n ? rank[i + k] : -1; int rj = j + k \u003c= n ? rank[j + k] : -1; return ri \u003c rj; } } void construct_sa(std::string S, int *sa) { n = S.length(); //初始化长度为1，rank直接取字符的编码 for (int i = 0; i \u003c= n; ++i) { sa[i] = i; rank[i] = i \u003c n ? S[i] : -1; } //利用对长度为k的排序结果对长度为2k排序 for (k = 1; k \u003c= n; k *=2) { std::sort(sa, sa + n + 1, compare_sa); //现在tmp临时存储新计算的rank，再转存回rank中 tmp[sa[0]] = 0; for (int i = 1; i \u003c= n; ++i) { tmp[sa[i]] = tmp[sa[i - 1]] + (compare_sa(sa[i - 1], sa[i]) ? 1 : 0); } for (int i = 0; i \u003c= n; ++i) { rank[i] = tmp[i]; } } } void construct_lcp(std::string S, int *sa, int *lcp) { int n = S.length(); for (int i = 0; i \u003c= n; ++i) { rank[sa[i]] = i; } int h = 0; lcp[0] = 0; for (int i = 0; i \u003c n; ++i) { int j = sa[rank[i] - 1]; if (h \u003e 0) h--; for (; j + h \u003c n \u0026\u0026 i + h \u003c n; ++h) { if (S[j + h] != S[i + h]) break; } lcp[rank[i] ] = h; } } std::string longestDupSubstring(std::string S) { construct_sa(S,sa); construct_lcp(S,sa,lcp); for (int i = 0; i \u003c= n; ++i) { std::cout\u003c\u003clcp[i]; } std::cout\u003c\u003c\"\\n\"; int len=0,p=-1; for (int i = 0; i \u003c= n; ++i) { if (lcp[rank[i]]\u003elen){ len=lcp[rank[i]]; p=i; } } if (p==-1) return \"\"; else return S.substr(p,len); } 这个对后缀数组的排序是用的标准库的排序方法，时间复杂度是O(nlogn)，比字符串大小是O(n)，故总的时间复杂度是O(n^2logn)，而 SA-IS 的时间复杂度是O(n) ","date":"2020-08-15","objectID":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/:2:0","tags":["SA-IS"],"title":"后缀数组及SA-IS算法笔记","uri":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"categories":["算法"],"content":"SA-IS 背景知识 在进入 SA-IS 算法的细节之前，我们需要先介绍一下 SA-IS 所建立的概念。 ","date":"2020-08-15","objectID":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/:3:0","tags":["SA-IS"],"title":"后缀数组及SA-IS算法笔记","uri":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"categories":["算法"],"content":"S-type and L-type suffixes 当排序一些字符串的后缀数组时，SA-IS 把他们分为“S 型”和“L 型”两种。S 型后缀是指那些比他们右边的后缀更小的那些后缀（所以在最终的排好序的后缀数组中靠前）。L 型就相反。 比如cabbage，offset 为 1 的后缀是abbage，它右边的后缀是bbage，可见abbage是比bbage小的，所以abbage是一个 S 型后缀。同理，ge是一个 L 型后缀（g\u003ee）。 规定最右边是一个空的（用#来表示），且它是 S 型。那么倒数第二个后缀，也就是不为空的最后一个字母是 L 型 我们可以写一个函数，接受一个字符串，并按照上面的规则映射出源字符串的每个字符是 S 型还是 L 型。 \u003e\u003e\u003e def buildTypeMap(data): ... \"\"\" ... Builds a map marking each suffix of the data as S_TYPE or L_TYPE. ... \"\"\" ... # The map should contain one more entry than there are characters ... # in the string, because we also need to store the type of the ... # empty suffix between the last character and the end of the ... # string. ... res = bytearray(len(data) + 1) ... ... # The empty suffix after the last character is S_TYPE ... res[-1] = S_TYPE ... ... # If this is an empty string... ... if not len(data): ... # ...there are no more characters, so we're done. ... return res ... ... # The suffix containing only the last character must necessarily ... # be larger than the empty suffix. ... res[-2] = L_TYPE ... ... # Step through the rest of the string from right to left. ... for i in range(len(data)-2, -1, -1): ... if data[i] \u003e data[i+1]: ... res[i] = L_TYPE ... elif data[i] == data[i+1] and res[i+1] == L_TYPE: ... res[i] = L_TYPE ... else: ... res[i] = S_TYPE ... ... return res \u003e\u003e\u003e def showTypeMap(data): ... print(data.decode('ascii')) ... print(buildTypeMap(data).decode('ascii')) \u003e\u003e\u003e showTypeMap(b'cabbage') cabbage LSLLSLLS 总结如下： s[n]==”#\",type[n]=S_TYPE,type[n-1]=L_TYPE if s[i]==s[i+1] type[i]=type[i+1] if s[i]\u003es[i+1] type[i]=L_TYPE if s[i]\u003cs[i+1] type[i]=S_TYPE 比如： s: \"cabbage\" type: \"LSLLSLLS\" 记住最后的 S 型是一个空。 ","date":"2020-08-15","objectID":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/:3:1","tags":["SA-IS"],"title":"后缀数组及SA-IS算法笔记","uri":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"categories":["算法"],"content":"LMS 字符 就是 Left Most S 型，一串连续的 S 型中最左边的 S 型，它的左边是一个 L 型，这样的字符就是 LMS 字符 cabbage LSLLSLLS ^ ^ ^ ^指向的就是LMS字符 \u003e\u003e\u003e def isLMSChar(offset, typemap): ... \"\"\" ... Returns true if the character at offset is a left-most S-type. ... \"\"\" ... if offset == 0: ... return False ... if typemap[offset] == S_TYPE and typemap[offset - 1] == L_TYPE: ... return True ... ... return False \u003e\u003e\u003e def showTypeMap(data): ... typemap = buildTypeMap(data) ... ... print(data.decode('ascii')) ... print(typemap.decode('ascii')) ... ... print(\"\".join( ... \"^\" if isLMSChar(i, typemap) else \" \" ... for i in range(len(typemap)) ... )) \u003e\u003e\u003e showTypeMap(b'cabbage') cabbage LSLLSLLS ^ ^ ^ ","date":"2020-08-15","objectID":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/:3:2","tags":["SA-IS"],"title":"后缀数组及SA-IS算法笔记","uri":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"categories":["算法"],"content":"LMS 子串 LMS 子串就是从一个 LMS 字符开始到下一个 LMS 字符（不包括下一个 LMS 字符）的字符串，上面的cabbage的 LMS 子串就是abb和age。 SA-IS 算法的神奇之处在于对 LMS 子串进行排序，但我们不能使用普通的字符串比较函数，因为我们不一定知道每个 LMS 字符串有多长。我们需要沿着字符串走，才能找到下一个 LMS 字符的开头，我们反正要遍历字符串，不如同时进行比较。 \u003e\u003e\u003e def lmsSubstringsAreEqual(string, typemap, offsetA, offsetB): ... \"\"\" ... Return True if LMS substrings at offsetA and offsetB are equal. ... \"\"\" ... # No other substring is equal to the empty suffix. ... if offsetA == len(string) or offsetB == len(string): ... return False ... ... i = 0 ... while True: ... aIsLMS = isLMSChar(i + offsetA, typemap) ... bIsLMS = isLMSChar(i + offsetB, typemap) ... ... # If we've found the start of the next LMS substrings... ... if (i \u003e 0 and aIsLMS and bIsLMS): ... # ...then we made it all the way through our original LMS ... # substrings without finding a difference, so we can go ... # home now. ... return True ... ... if aIsLMS != bIsLMS: ... # We found the end of one LMS substring before we reached ... # the end of the other. ... return False ... ... if string[i + offsetA] != string[i + offsetB]: ... # We found a character difference, we're done. ... return False ... ... i += 1 ","date":"2020-08-15","objectID":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/:3:3","tags":["SA-IS"],"title":"后缀数组及SA-IS算法笔记","uri":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"categories":["算法"],"content":"桶排序 因为我要要对后缀数组排序，所以所有以相同字符开头的后缀都会挨着。比如cabbage，有 2 个 a 开头的后缀，2 个 b 开头的后缀，1 个 c 开头的后缀，所以我们可以预测排好序的数组前两个是 a 开头的后缀，然后是 2 个 b 开头的，再是 1 个 c 开头的。 \u003e\u003e\u003e def findBucketSizes(string, alphabetSize=256): ... res = [0] * alphabetSize ... ... for char in string: ... res[char] += 1 ... ... return res #a = 0, b = 1, c = 2... \u003e\u003e\u003e encoded_cabbage = [2, 0, 1, 1, 0, 6, 4]#cabbage \u003e\u003e\u003e findBucketSizes(encoded_cabbage, 7) [2, 2, 1, 0, 1, 0, 1] 现在我们知道了每个 bucket 有多大，就可以简单地推导出一个数组，其中每个字符的索引都指向后缀数组中相应 bucket 的开头。 \u003e\u003e\u003e def findBucketHeads(bucketSizes): ... offset = 1 ... res = [] ... for size in bucketSizes: ... res.append(offset) ... offset += size ... ... return res \u003e\u003e\u003e encoded_cabbage = [2, 0, 1, 1, 0, 6, 4] \u003e\u003e\u003e findBucketSizes(encoded_cabbage, 7) [2, 2, 1, 0, 1, 0, 1] \u003e\u003e\u003e cabbage_buckets = findBucketSizes(encoded_cabbage, 7) \u003e\u003e\u003e findBucketHeads(cabbage_buckets) [1, 3, 5, 6, 6, 7, 7] 最后的空后缀总是在排好的后缀数组的第 0 位，所以 bucket 从 1 开始。有 2 个 a 开头的后缀所以 b 桶从 3 开始，以此类推。注意 d 桶和 e 桶都从 6 开始，但因为没有 d 开头的后缀，所以不会有问题。 同门可以用相似的方法找到桶尾。 \u003e\u003e\u003e def findBucketTails(bucketSizes): ... offset = 1 ... res = [] ... for size in bucketSizes: ... offset += size ... res.append(offset - 1) ... ... return res \u003e\u003e\u003e findBucketTails(cabbage_buckets) [2, 4, 5, 5, 6, 6, 7] 现在，讲完了所有的背景知识，我们来谈谈算法本身。 ","date":"2020-08-15","objectID":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/:3:4","tags":["SA-IS"],"title":"后缀数组及SA-IS算法笔记","uri":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"categories":["算法"],"content":"SA-IS 算法 名字由来是 Suffix Array by Induced Sorting。什么是 Induced Sorting？建立后缀数组的棘手部分是 LMS 后缀。 先宏观看一下 SA-IS 算法 \u003e\u003e\u003e def makeSuffixArrayByInducedSorting(string, alphabetSize): ... \"\"\" ... Compute the suffix array of 'string' with the SA-IS algorithm. ... \"\"\" ... ... # Classify each character of the string as S_TYPE or L_TYPE ... typemap = buildTypeMap(string) ... ... # We'll be slotting suffixes into buckets according to what ... # character they start with, so let's precompute that info now. ... bucketSizes = findBucketSizes(string, alphabetSize) ... ... # Use a simple bucket-sort to insert all the LMS suffixes into ... # approximately the right place the suffix array. ... guessedSuffixArray = guessLMSSort(string, bucketSizes, typemap) ... ... # Slot all the other suffixes into guessedSuffixArray, by using ... # induced sorting. This may move the LMS suffixes around. ... induceSortL(string, guessedSuffixArray, bucketSizes, typemap) ... induceSortS(string, guessedSuffixArray, bucketSizes, typemap) ... ... # Create a new string that summarises the relative order of LMS ... # suffixes in the guessed suffix array. ... summaryString, summaryAlphabetSize, summarySuffixOffsets = \\ ... summariseSuffixArray(string, guessedSuffixArray, typemap) ... ... # Make a sorted suffix array of the summary string. ... summarySuffixArray = makeSummarySuffixArray( ... summaryString, ... summaryAlphabetSize, ... ) ... ... # Using the suffix array of the summary string, determine exactly ... # where the LMS suffixes should go in our final array. ... result = accurateLMSSort(string, bucketSizes, typemap, ... summarySuffixArray, summarySuffixOffsets) ... ... # ...and once again, slot all the other suffixes into place with ... # induced sorting. ... induceSortL(string, result, bucketSizes, typemap) ... induceSortS(string, result, bucketSizes, typemap) ... ... return result 为了帮助说明算法的运行情况，我们将使用以下函数来显示正在进行中的后缀数组的状态。我们将在未初始化的后缀数组元素中存储-1，由于我们将在短字符串上演示该算法，我们可以假设每个偏移量将是一到两位数的长度（与”-1 “的长度相同），并像这样呈现后缀数组的中间状态。 \u003e\u003e\u003e def showSuffixArray(arr, pos=None): ... print(\" \".join(\"%02d\" % each for each in arr)) ... ... if pos is not None: ... print(\" \".join( ... \"^^\" if each == pos else \" \" ... for each in range(len(arr)) ... )) \u003e\u003e\u003e showSuffixArray([2, -1, 4]) 02 -1 04 \u003e\u003e\u003e showSuffixArray([2, -1, 4], 2) 02 -1 04 ^^ ","date":"2020-08-15","objectID":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/:4:0","tags":["SA-IS"],"title":"后缀数组及SA-IS算法笔记","uri":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"categories":["算法"],"content":"第一个猜测 我们还不知道我们的 LMS 后缀在 sfffix 数组中的确切位置，所以我们先用桶排序把它们放在大约正确的位置。在其他条件相同的情况下，较长的后缀（字符串中较早出现的后缀）排在较短的后缀（较晚出现的后缀）之后，所以我们将从左到右遍历字符串，并将我们找到的每个 LMS 后缀堆放在其桶的尾部。 \u003e\u003e\u003e def guessLMSSort(string, bucketSizes, typemap): ... \"\"\" ... Make a suffix array with LMS-substrings approximately right. ... \"\"\" ... # Create a suffix array with room for a pointer to every suffix of ... # the string, including the empty suffix at the end. ... guessedSuffixArray = [-1] * (len(string) + 1) ... ... bucketTails = findBucketTails(bucketSizes) ... ... # Bucket-sort all the LMS suffixes into their appropriate bucket. ... for i in range(len(string)): ... if not isLMSChar(i, typemap): ... # Not the start of an LMS suffix ... continue ... ... # Which bucket does this suffix go into? ... bucketIndex = string[i] ... # Add the start position at the tail of the bucket... ... guessedSuffixArray[bucketTails[bucketIndex]] = i ... # ...and move the tail pointer down. ... bucketTails[bucketIndex] -= 1 ... ... # Show the current state of the array ... showSuffixArray(guessedSuffixArray) ... ... # The empty suffix is defined to be an LMS-substring, and we know ... # it goes at the front. ... guessedSuffixArray[0] = len(string) ... ... showSuffixArray(guessedSuffixArray) ... ... return guessedSuffixArray 因此，现在我们可以猜测 LMS 子串在我们的字符串中的位置，将所有其他位置设置为-1。 \u003e\u003e\u003e cabbage_buckets = findBucketSizes(b'cabbage') \u003e\u003e\u003e cabbage_types = buildTypeMap(b'cabbage') \u003e\u003e\u003e cabbage_guess = guessLMSSort(b'cabbage', cabbage_buckets, cabbage_types) -1 -1 01 -1 -1 -1 -1 -1 -1 04 01 -1 -1 -1 -1 -1 07 04 01 -1 -1 -1 -1 -1 它找到的第一个 LMS 后缀是 abbage，在字符串的索引 1 处，所以它把它放在 a 桶的末尾。 它找到的下一个 LMS 后缀是 index 4 的 age，所以它把它放在 abbage 之前 我们到了源字符串的结尾，所以我们在后缀数组的 0 位置添加了空后缀。 为了填补剩下的位置，我们将使用 “诱导排序”；也就是根据数组中已有的内容来确定其他后缀的位置。 ","date":"2020-08-15","objectID":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/:4:1","tags":["SA-IS"],"title":"后缀数组及SA-IS算法笔记","uri":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"categories":["算法"],"content":"诱导排序：L 型后缀 现在我们的后缀数组中已经有了 LMS 后缀，我们可以推断出所有其他后缀的去向。我们首先扫描我们的临时后缀数组，对于每一个列出的后缀，我们检查原始字符串中它左边的后缀–如果那是 L 型，我们也会对它进行桶式排序。 \u003e\u003e\u003e def induceSortL(string, guessedSuffixArray, bucketSizes, typemap): ... \"\"\" ... Slot L-type suffixes into place. ... \"\"\" ... bucketHeads = findBucketHeads(bucketSizes) ... ... # For each cell in the suffix array.... ... for i in range(len(guessedSuffixArray)): ... if guessedSuffixArray[i] == -1: ... # No offset is recorded here. ... continue ... ... # We're interested in the suffix that begins to the left of ... # the suffix this entry points at. ... j = guessedSuffixArray[i] - 1 ... if j \u003c 0: ... # This entry in the suffix array is the suffix that begins ... # at the start of the string, offset 0. Therefore there is ... # no suffix to the left of it, and j is out of bounds of ... # the typemap. ... continue ... if typemap[j] != L_TYPE: ... # We're only interested in L-type suffixes right now. ... continue ... ... # Which bucket does this suffix go into? ... bucketIndex = string[j] ... # Add the start position at the head of the bucket... ... guessedSuffixArray[bucketHeads[bucketIndex]] = j ... # ...and move the head pointer up. ... bucketHeads[bucketIndex] += 1 ... ... showSuffixArray(guessedSuffixArray, i) 如果我们将之前的猜测反馈给这个函数，就可以看着它将 L 型后缀传播到数组中。 \u003e\u003e\u003e induceSortL(b'cabbage', cabbage_guess, cabbage_buckets, cabbage_types) 07 04 01 -1 -1 -1 06 -1 ^^ 07 04 01 03 -1 -1 06 -1 ^^ 07 04 01 03 -1 00 06 -1 ^^ 07 04 01 03 02 00 06 -1 ^^ 07 04 01 03 02 00 06 05 ^^ 根据上面的结果，我们可以知道发生了什么 我们从后缀数组中的第一个开始，它代表字符串末尾的空后缀。 空后缀前的字符为 e,偏移量是 6，所以我们将 6 放入 e 桶中。 下一个单元格的后缀 age 在偏移量为 4，它左边的后缀是偏移量为 3 的 L 型后缀 bage，所以我们将 3 放入 b 桶中。 接下来是偏移量 1 的 abbage，左边是偏移量 为 0 的 L 型后缀 cabbage，所以我们把 0 槽入 c 桶中 我们在偏移量 3 处找到了两步前存储的 bage–但偏移量 2 处的后缀(bbage)仍然是 L 型的，所以我们将它放入 b 桶中。 我们在偏移量 2 处找到了 bbage，但它左边的后缀不是 L 型，所以我们继续前进。 我们在偏移量 0 处发现了 cabbage，但它的左边没有任何东西，所以我们继续前进。 我们在偏移量 6 处发现 e，而偏移量 5 处的后缀(ge)是 L 型的，所以我们将其放入 g 桶中 我们在第 5 关找到了 ge，但它左边的后缀不是 L 型，所以我们结束了 ","date":"2020-08-15","objectID":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/:4:2","tags":["SA-IS"],"title":"后缀数组及SA-IS算法笔记","uri":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"categories":["算法"],"content":"诱导排序：S 型后缀 在 L 型后缀从左到右扫描后缀数组后，我们现在从右到左扫描 S 型后缀。这基本上是前面函数的镜像。 \u003e\u003e\u003e def induceSortS(string, guessedSuffixArray, bucketSizes, typemap): ... \"\"\" ... Slot S-type suffixes into place. ... \"\"\" ... bucketTails = findBucketTails(bucketSizes) ... ... for i in range(len(guessedSuffixArray)-1, -1, -1): ... j = guessedSuffixArray[i] - 1 ... if j \u003c 0: ... # This entry in the suffix array is the suffix that begins ... # at the start of the string, offset 0. Therefore there is ... # no suffix to the left of it, and j is out of bounds of ... # the typemap. ... continue ... if typemap[j] != S_TYPE: ... # We're only interested in S-type suffixes right now. ... continue ... ... # Which bucket does this suffix go into? ... bucketIndex = string[j] ... # Add the start position at the tail of the bucket... ... guessedSuffixArray[bucketTails[bucketIndex]] = j ... # ...and move the tail pointer down. ... bucketTails[bucketIndex] -= 1 ... ... showSuffixArray(guessedSuffixArray, i) \u003e\u003e\u003e induceSortS(b'cabbage', cabbage_guess, cabbage_buckets, cabbage_types) 07 04 04 03 02 00 06 05 ^^ 07 01 04 03 02 00 06 05 ^^ cabbage 只有两个 S 型后缀，所以我们只能得到两行输出。当函数扫过后缀数组时，它最终将 LMS 后缀的顺序从 “04 01 “换成了 “01 04”，这足以将我们猜测的后缀数组转化为正确的后缀数组。不过这只是一个快乐的巧合。如果我们处理我们的另一个例子。 \u003e\u003e\u003e baa = b'baabaabac' \u003e\u003e\u003e showTypeMap(baa) baabaabac LSSLSSLSLS ^ ^ ^ ^ \u003e\u003e\u003e induceSortS(baa, baa_guess, baa_buckets, baa_types) 09 -1 -1 07 04 07 06 03 00 08 ^^ 09 -1 -1 07 02 07 06 03 00 08 ^^ 09 -1 -1 05 02 07 06 03 00 08 ^^ 09 -1 01 05 02 07 06 03 00 08 ^^ 09 04 01 05 02 07 06 03 00 08 ^^ 还有一些单元格需要换一换。 ","date":"2020-08-15","objectID":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/:4:3","tags":["SA-IS"],"title":"后缀数组及SA-IS算法笔记","uri":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"categories":["算法"],"content":"总结猜测的后缀数组 我们从某个字母表中的一串字符开始，我们为这串字符做了一个近似的后缀数组，现在我们将用一个新的字母表中的新字符串来总结这个近似的后缀数组，它只代表了最重要的信息：在诱导 SortL()和诱导 SortS()做了它们的事情之后，LMS 后缀的最终位置。 总结的工作原理是这样的。原始字符串中的每个 LMS 后缀都有一个根据这些后缀在猜测的后缀数组中出现的顺序得到的名字。或者说，每个 LMS 后缀开头的 LMS 子串都会得到一个名字：如果两个 LMS 后缀以相同的 LMS 子串开头，它们就会得到相同的名字。这些名称按照与原始字符串中对应后缀相同的顺序组合，形成摘要字符串。 下面是相应的实现。 \u003e\u003e\u003e def summariseSuffixArray(string, guessedSuffixArray, typemap): ... \"\"\" ... Construct a 'summary string' of the positions of LMS-substrings. ... \"\"\" ... # We will use this array to store the names of LMS substrings in ... # the positions they appear in the original string. ... lmsNames = [-1] * (len(string) + 1) ... ... # Keep track of what names we've allocated. ... currentName = 0 ... ... # Where in the original string was the last LMS suffix we checked? ... lastLMSSuffixOffset = None ... ... # We know that the first LMS-substring we'll see will always be ... # the one representing the empty suffix, and it will always be at ... # position 0 of suffixOffset. ... lmsNames[guessedSuffixArray[0]] = currentName ... lastLMSSuffixOffset = guessedSuffixArray[0] ... ... showSuffixArray(lmsNames) ... ... # For each suffix in the suffix array... ... for i in range(1, len(guessedSuffixArray)): ... # ...where does this suffix appear in the original string? ... suffixOffset = guessedSuffixArray[i] ... ... # We only care about LMS suffixes. ... if not isLMSChar(suffixOffset, typemap): ... continue ... ... # If this LMS suffix starts with a different LMS substring ... # from the last suffix we looked at.... ... if not lmsSubstringsAreEqual(string, typemap, ... lastLMSSuffixOffset, suffixOffset): ... # ...then it gets a new name ... currentName += 1 ... ... # Record the last LMS suffix we looked at. ... lastLMSSuffixOffset = suffixOffset ... ... # Store the name of this LMS suffix in lmsNames, in the same ... # place this suffix occurs in the original string. ... lmsNames[suffixOffset] = currentName ... showSuffixArray(lmsNames) ... ... # Now lmsNames contains all the characters of the suffix string in ... # the correct order, but it also contains a lot of unused indexes ... # we don't care about and which we want to remove. We also take ... # this opportunity to build summarySuffixOffsets, which tells ... # us which LMS-suffix each item in the summary string represents. ... # This will be important later. ... summarySuffixOffsets = [] ... summaryString = [] ... for index, name in enumerate(lmsNames): ... if name == -1: ... continue ... summarySuffixOffsets.append(index) ... summaryString.append(name) ... ... # The alphabetically smallest character in the summary string ... # is numbered zero, so the total number of characters in our ... # alphabet is one larger than the largest numbered character. ... summaryAlphabetSize = currentName + 1 ... ... return summaryString, summaryAlphabetSize, summarySuffixOffsets 上面代码很多，看一个例子 \u003e\u003e\u003e ( ... cabbage_summary, ... cabbage_summary_alpha_size, ... cabbage_summary_suffix_offsets, ... ) = summariseSuffixArray(b'cabbage', cabbage_guess, cabbage_types) -1 -1 -1 -1 -1 -1 -1 00 -1 01 -1 -1 -1 -1 -1 00 -1 01 -1 -1 02 -1 -1 00 \u003e\u003e\u003e showSuffixArray(cabbage_guess) 07 01 04 03 02 00 06 05 在这些后缀中，我们知道前三个是 LMS 后缀，依次是空后缀、abbage 和 age。因为这三个 LMS 后缀都是以不同的 LMS 子串开始的，所以它们得到了三个不同的名字（0，1 和 2）。这些名称被存储在 lmsNames 中，位于原始字符串中相应后缀出现的位置：分别是偏移量 7、1 和 4。 计算出 lmsNames 后，我们扔掉 lmsNames 的未使用的索引，生成 摘要字符串。 \u003e\u003e\u003e cabbage_summary [1, 2, 0] 但这不是我们函数的唯一输出。我们还知道，摘要字符串是用三个不同的字符组成的字母表书写的: \u003e\u003e\u003e cabbage_summary_alpha_size 3 而且我们有一个列表，存储了与摘要字符串中每个项目相关联的后缀偏移。 \u003e\u003e\u003e cabbage_summary_suffix_offsets [1, 4, 7] 但如前所述，cabbage是一个很简单的字符串。让我们试试我们更复杂的例子，baabaabac: \u003e\u003e\u003e ( ... baa_summary, ... baa_summary_alpha_size, ... baa_summary_suffix_offsets, ... ) = summariseSuffixArray(baa, baa_guess, baa_types) -1 -1 -1 -1 -1 -1 -1 -1 -1 00 -1 -1 -1 -1 01 -1 -1 -1 -1 00 -1 01 -1 -1 01 -1 -1 -1 -1 00 -1 01 -1 -1 01 -1 -1 02 -1 00 对于这个字符串，有两个 LMS 后缀是以相同的 LMS 子串开始的：aabaabac 和 aabac 都是以 aab 开始的，这些字符的类型在这两种情况下都是 SSL。因此，这两个后缀得到了相同的名称（1），我们的摘要字符串包含两个相同的字符: \u003e\u003e\u003e baa_summary [1, 1, 2,","date":"2020-08-15","objectID":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/:4:4","tags":["SA-IS"],"title":"后缀数组及SA-IS算法笔记","uri":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"categories":["算法"],"content":"得到总结的后缀数组 我们从一个字符串开始，想建立一个后缀数组，在这个过程中，我们已经建立了第二个字符串，现在我们也要把这个字符串做一个后缀数组？这不是循环推理吗？ 嗯，差不多：这是递归推理。 如果我们要做递归，就需要有一个不是递归的基例。如果我们看一下我们上面的cabbage例子，我们得到了一个很简单的摘要字符串： \u003e\u003e\u003e cabbage_summary [1, 2, 0] 是的，这个特殊的例子恰好小到你可以在脑海中建立后缀数组，但还有一个有趣的特点：我们已经说过这是一个由三个字符组成的字母表中的字符串，而字母表中的每个字符都会在这个字符串中的某个地方精确地出现一次。这意味着我们可以用我们可靠的老桶排序来创建一个后缀数组。 如果反过来看我们 baabaabac 的例子，前景就没有那么乐观了。 \u003e\u003e\u003e baa_summary [1, 1, 2, 0] 这个字符串仍然是三个字符的字母表，但它的长度超过了三个字符，这意味着至少有一个字符必须重复，而我们不能确定一个桶排序会做正确的事情–所以在这种情况下，我们必须递归。 值得指出的是，虽然理论上你可以在字母表中拥有一个包含重复的三个字符的字符串（比如说，[1，1，0]），但我们的 summaryiseSuffixArray()函数永远不会产生这样的东西，因为它总是使用字母表中的连续字符，而且它总是将字母表的大小设置为它所使用的不同字符数。 \u003e\u003e\u003e def makeSummarySuffixArray(summaryString, summaryAlphabetSize): ... \"\"\" ... Construct a sorted suffix array of the summary string. ... \"\"\" ... if summaryAlphabetSize == len(summaryString): ... # Every character of this summary string appears once and only ... # once, so we can make the suffix array with a bucket sort. ... summarySuffixArray = [-1] * (len(summaryString) + 1) ... ... # Always include the empty suffix at the beginning. ... summarySuffixArray[0] = len(summaryString) ... ... for x in range(len(summaryString)): ... y = summaryString[x] ... summarySuffixArray[y+1] = x ... ... else: ... # This summary string is a little more complex, so we'll have ... # to use recursion. ... summarySuffixArray = makeSuffixArrayByInducedSorting( ... summaryString, ... summaryAlphabetSize, ... ) ... ... return summarySuffixArray 我们还不能在baabaabac摘要上测试这个函数，因为我们还没有完成递归的实现，但我们可以在cabbage摘要上测试它。 \u003e\u003e\u003e cabbage_summary_suffix_array = makeSummarySuffixArray( ... cabbage_summary, cabbage_summary_alpha_size, ... ) \u003e\u003e\u003e showSuffixArray(cabbage_summary_suffix_array) 03 02 00 01 和用内置排序算法比较: \u003e\u003e\u003e showSuffixArray(naivelyMakeSuffixArray(cabbage_summary)) 03 02 00 01 ","date":"2020-08-15","objectID":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/:4:5","tags":["SA-IS"],"title":"后缀数组及SA-IS算法笔记","uri":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"categories":["算法"],"content":"建立真正的后缀数组 最后，我们开始根据摘要字符串的后缀数组构建真正的、最终的后缀数组。和之前一样，我们先将 LMS 后缀放入后缀数组中，然后我们可以通过诱导排序来填充所有其他的后缀。与之前不同的是，我们不只是按照找到的任何顺序将它们桶式排序到位，而是按照摘要字符串的后缀数组决定的顺序插入。 请记住，当我们建立摘要字符串时（其中每个字符都是一个 LMS 子串的生成名称），我们还建立了一个相应的摘要 SuffixOffsets 数组，该数组将摘要字符串中的字符映射回原始字符串中的 LMS 子串（因此是 LMS 后缀），所以这就是我们要使用的。 这个过程是这样的。摘要字符串的后缀数组中的每个条目都指向摘要中的一个位置。我们在 summarySuffixOffsets 中查看相同的位置，以找到我们原始字符串的相应 LMS 后缀的偏移量。然后，我们将该 LMS 后缀放入正确的桶中，相信 summary 后缀数组会将它们按正确的顺序放入桶中。 \u003e\u003e\u003e def accurateLMSSort(string, bucketSizes, typemap, ... summarySuffixArray, summarySuffixOffsets): ... \"\"\" ... Make a suffix array with LMS suffixes exactly right. ... \"\"\" ... # A suffix for every character, plus the empty suffix. ... suffixOffsets = [-1] * (len(string) + 1) ... ... # As before, we'll be adding suffixes to the ends of their ... # respective buckets, so to keep them in the right order we'll ... # have to iterate through summarySuffixArray in reverse order. ... bucketTails = findBucketTails(bucketSizes) ... for i in range(len(summarySuffixArray)-1, 1, -1): ... stringIndex = summarySuffixOffsets[summarySuffixArray[i]] ... ... # Which bucket does this suffix go into? ... bucketIndex = string[stringIndex] ... # Add the suffix at the tail of the bucket... ... suffixOffsets[bucketTails[bucketIndex]] = stringIndex ... # ...and move the tail pointer down. ... bucketTails[bucketIndex] -= 1 ... ... showSuffixArray(suffixOffsets) ... ... # Always include the empty suffix at the beginning. ... suffixOffsets[0] = len(string) ... ... showSuffixArray(suffixOffsets) ... ... return suffixOffsets 注意：为了确保我们的 LMS 后缀能在后面的诱导排序中存活下来，我们需要把它们插入到它们的桶的最后，所以我们在向后插入后缀的时候，需要向后走过 summarySuffixArray，以保持它们的相对顺序。 另外，我们并不是对 summarySuffixArray 中的每个条目都进行处理：第一个条目对应的是 summary 字符串的空后缀，它不对应原始字符串的任何后缀。第二个条目对应的是原始字符串的空后缀，我们无法对它进行桶式排序，因为它是空的。不过我们已经知道它在开头，所以这不是问题。 让我们来看看这个算法，因为它适用于我们的老朋友cabbage。提醒一下，这里是 accounterLMSSort()的输入。 \u003e\u003e\u003e showSuffixArray(cabbage_summary_suffix_array) 03 02 00 01 \u003e\u003e\u003e showSuffixArray(cabbage_summary) 01 02 00 \u003e\u003e\u003e showSuffixArray(cabbage_summary_suffix_offsets) 01 04 07 现在，我们可以走一遍算法。 我们在摘要的后缀数组中找到的第一个条目（最后一个条目，因为我们是从后往前走）是 01。如果我们查看 summarySuffixOffsets 的偏移量 1，我们看到这对应于原始字符串第 4 位（age）的 LMS 后缀，所以我们可以在 a 桶的最后插入该后缀。 summary 的后缀数组的下一个条目是 00，summarySuffixOffsets 的偏移量 0 对应于原始字符串第 1 个位置的 LMS 后缀（abbage），所以我们把这个后缀插到 age 之前的 a 桶中。 倒数第二的条目被跳过，因为它指向原始字符串的空后缀，而我们无法将其进行桶排序。 最后一条被跳过，因为它代表摘要字符串末尾的空后缀，它在原始字符串中没有对应的 LMS 后缀。 最后，我们知道，空的后缀（在第 7 位）将出现在最后的后缀数组的开头。 当我们运行我们的函数时，我们可以看到同样的步骤发生。 \u003e\u003e\u003e cabbage_real = accurateLMSSort(b'cabbage', cabbage_buckets, ... cabbage_types, cabbage_summary_suffix_array, ... cabbage_summary_suffix_offsets) -1 -1 04 -1 -1 -1 -1 -1 -1 01 04 -1 -1 -1 -1 -1 07 01 04 -1 -1 -1 -1 -1 04 是在 a 桶的末尾，然后前面紧接着是 01，最后是空后缀在开头得到它的特殊位置。 ","date":"2020-08-15","objectID":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/:4:6","tags":["SA-IS"],"title":"后缀数组及SA-IS算法笔记","uri":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"categories":["算法"],"content":"整合在一起 在将 LMS 后缀放到正确的位置后，所有其他后缀都会像之前一样，通过第二轮诱导排序归位。我们现在已经描述了 makeSuffixArrayByInducedSorting()调用的所有函数，所以我们可以调用它来有效地建立一个我们喜欢的任何字符串的后缀数组……以及其内部计算的详细日志（为简洁起见这里省略）。 \u003e\u003e\u003e showSuffixArray(makeSuffixArrayByInducedSorting(b'cabbage', 256)) -1 -1 01 -1 -1 -1 -1 -1 ... 07 01 04 03 02 00 06 05 \u003e\u003e\u003e showSuffixArray(makeSuffixArrayByInducedSorting(baa, 256)) -1 -1 -1 -1 -1 01 -1 -1 -1 -1 ... 09 01 04 02 05 07 00 03 06 08 但是，由于大多数人想要建立一个排序后缀数组的人都会有一串字节，而不是任意大小的字母串，所以让我们做一个具有合理默认值的包装函数。 \u003e\u003e\u003e def makeSuffixArray(bytestring): ... return makeSuffixArrayByInducedSorting(bytestring, 256) 现在我们完成了。 \u003e\u003e\u003e naivelyMakeSuffixArray(b'cabbage') == makeSuffixArray(b'cabbage') True \u003e\u003e\u003e naivelyMakeSuffixArray(baa) == makeSuffixArray(baa) True ","date":"2020-08-15","objectID":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/:4:7","tags":["SA-IS"],"title":"后缀数组及SA-IS算法笔记","uri":"/2020/08/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8Asa-is%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"categories":["剑指offer","leetcode"],"content":"从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。 例如: 给定二叉树: [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果： [ [3], [9,20], [15,7] ] ","date":"2020-08-14","objectID":"/leetcode/offer/32_2/:1:0","tags":null,"title":"32_2","uri":"/leetcode/offer/32_2/"},{"categories":["剑指offer","leetcode"],"content":"思路： 这次是要把每层分成一组，那么可以想每次循环把队列的每个值都拿出来，就是说每次最外面的大循环就是一层。 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public List\u003cList\u003cInteger\u003e\u003e levelOrder(TreeNode root) { List\u003cList\u003cInteger\u003e\u003e ret = new ArrayList\u003c\u003e(); Queue\u003cTreeNode\u003e queue = new ArrayDeque\u003c\u003e(); if (root!=null) queue.add(root); while (!queue.isEmpty()) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); for (int i =queue.size();i\u003e0;i--){ TreeNode node=queue.poll(); list.add(node.val); if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); } ret.add(list); } return ret; } } ","date":"2020-08-14","objectID":"/leetcode/offer/32_2/:2:0","tags":null,"title":"32_2","uri":"/leetcode/offer/32_2/"},{"categories":null,"content":"github webhook 是什么 当 github 上面的仓库发生变化时（push 或 issue），可以自定义回调（一条链接）。 先定义一个脚本 例如： #/root/webhook/deploy.sh #!/bin/bash cd /path/to/directory git pull 注意要添加执行权限 chmod +x deploy.sh 在定义一个 webhook.js 文件 在同一目录下新建 webhook.js 文件 var http = require('http') var spawn = require('child_process').spawn var createHandler = require('github-webhook-handler') // 注意将 secret 修改你自己的 var handler = createHandler({ path: '/webhook', secret: 'yourwebhooksecret' }) http.createServer(function (req, res) { handler(req, res, function (err) { res.statusCode = 404 res.end('no such location') }) }).listen(6666) handler.on('error', function (err) { console.error('Error:', err.message) }) handler.on('push', function (event) { console.log( 'Received a push event for %s to %s', event.payload.repository.name, event.payload.ref ) runCommand('sh', ['./deploy.sh'], function (txt) { console.log(txt) }) }) function runCommand(cmd, args, callback) { var child = spawn(cmd, args) var resp = 'Deploy OK' child.stdout.on('data', function (buffer) { resp += buffer.toString() }) child.stdout.on('end', function () { callback(resp) }) } 用 pm2 启动服务 pm2 start webhook.js Nginx 配置 # GitHub auto deploy webhook location /webhook { proxy_pass http://127.0.0.1:6666; } GitHub Webhook 配置 在 github 仓库的Setting-webhooks新建一个 webhook,Content Type 为 application/json，secret 设置成与 webhook.js 中的相同。 图\" 图 验证 如果如图表示成功 图\" 图 ","date":"2020-08-14","objectID":"/2020/08/webhook%E6%95%99%E7%A8%8B/:0:0","tags":null,"title":"Webhook教程","uri":"/2020/08/webhook%E6%95%99%E7%A8%8B/"},{"categories":["剑指offer","leetcode"],"content":"从上到下打印二叉树 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。 例如: 给定二叉树: [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回： [3,9,20,15,7] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题目要求从上到下，从左到右打印，自然就想到用队列来循环。也就是 bfs 算法。 class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } public int[] levelOrder(TreeNode root) { if (root == null) return new int[0]; Queue\u003cTreeNode\u003e queue = new ArrayDeque\u003c\u003e() {{ add(root); }}; List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); while (!queue.isEmpty()) { TreeNode node = queue.poll(); list.add(node.val); if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); } int[] ret = new int[list.size()]; for (int i = 0; i \u003c list.size(); i++) { ret[i] = list.get(i); } return ret; } // Definition for a binary tree node. #[derive(Debug, PartialEq, Eq)]pubstruct TreeNode{pubval: i32,publeft: Option\u003cRc\u003cRefCell\u003cTreeNode\u003e\u003e\u003e,pubright: Option\u003cRc\u003cRefCell\u003cTreeNode\u003e\u003e\u003e,}implTreeNode{#[inline]pubfn new(val: i32)-\u003e Self{TreeNode{val,left: None,right: None,}}}usestd::rc::Rc;usestd::cell::RefCell;usestd::collections::VecDeque;pubfn level_order(root: Option\u003cRc\u003cRefCell\u003cTreeNode\u003e\u003e\u003e)-\u003e Vec\u003ci32\u003e{ifroot.is_none(){returnvec![];}letroot=root.unwrap();letmutqueue=VecDeque::new();queue.push_back(root.clone());letmutret=vec![];while!queue.is_empty(){letnode=queue.pop_front().unwrap();ret.push(node.borrow().val);ifnode.borrow().left.is_some(){letleft=Rc::clone(node.borrow().left.as_ref().unwrap());queue.push_back(left);}ifnode.borrow().right.is_some(){letleft=Rc::clone(node.borrow().right.as_ref().unwrap());queue.push_back(left);}}ret} ","date":"2020-08-13","objectID":"/leetcode/offer/32_1/:0:0","tags":null,"title":"32-1","uri":"/leetcode/offer/32_1/"},{"categories":null,"content":"常用命令 ","date":"2020-08-13","objectID":"/2020/08/hugo%E6%95%99%E7%A8%8B/:0:0","tags":null,"title":"Hugo教程","uri":"/2020/08/hugo%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"hugo new 添加网站内容. 例如: hugo new about.md, 他会在 content 目录下生成一个 about.md 的文件, 根据这个文件可以生成对应的静态页面. 可以在 about.md 前面添加对应的路径, 但文件会以 content 为根目录, 也就是说所有添加新文件都会存放在 content 目录下面. ","date":"2020-08-13","objectID":"/2020/08/hugo%E6%95%99%E7%A8%8B/:1:0","tags":null,"title":"Hugo教程","uri":"/2020/08/hugo%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"hugo new theme 为网站添加 UI, 也就是模板文件/主题文件. 例如: hugo new theme mytheme. 这会在 themes 目录下创建一个 mytheme 目录, mytheme 目录中会默认添加一些基本的文件结构. 所有的模板/主题文件都会保存在 themes 目录中. ","date":"2020-08-13","objectID":"/2020/08/hugo%E6%95%99%E7%A8%8B/:2:0","tags":null,"title":"Hugo教程","uri":"/2020/08/hugo%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"hugo 生成静态网站, 默认在生成的静态文件保存在 public 目录中. 也可以指定路. ","date":"2020-08-13","objectID":"/2020/08/hugo%E6%95%99%E7%A8%8B/:3:0","tags":null,"title":"Hugo教程","uri":"/2020/08/hugo%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"hugo server hugo 自带一个 web 服务器, 运行 hugo server 后可以通过 http://localhost:1313 来访问静态网站. 下面是 hugo server 常用的参数, 注意大小写: -p 端口: 修改默认端口 -D: 在使用 server 预览网站时, draft 属性为 ture 的草稿文件是不会生成预览的. 添加-D 后可以预览草稿文件. 文章和页面的对应关系 └── content ├── _index.md // [home] \u003c- https://example.com/ ** ├── about.md // [page] \u003c- https://example.com/about/ ├── posts | ├── _index.md // [section] \u003c- https://example.com/posts/ ** | ├── firstpost.md // [page] \u003c- https://example.com/posts/firstpost/ | ├── happy | | ├── _index.md // [section] \u003c- https://example.com/posts/happy/ ** | | └── ness.md // [page] \u003c- https://example.com/posts/happy/ness/ | └── secondpost.md // [page] \u003c- https://example.com/posts/secondpost/ └── quote ├── _index.md // [section] \u003c- https://example.com/quote/ ** ├── first.md // [page] \u003c- https://example.com/quote/first/ └── second.md // [page] \u003c- https://example.com/quote/second/ // hugo默认生成的页面, 没有对应的markdown文章 分类列表页面 // [taxonomyTerm] \u003c- https://example.com/categories/ ** 某个分类下的所有文章的列表 // [taxonomy] \u003c- https://example.com/categories/one-category ** 标签列表页面 // [taxonomyTerm] \u003c- https://example.com/tags/ ** 某个标签下的所有文章的列表 // [taxonomy] \u003c- https://example.com/tags/one-tag ** 中括号[]中标注的是页面的 kind 属性, 他们整体上分为两类: single(单页面 - page) 和 list(列表页 - home, section, taxonomyTerm, taxonomy). content 目录下的所有 _index.md 可以用来生成对应的列表页面, 如果没有这些 markdown 文件, hugo 也会默认生成对应的页面. 有这些 markdown 文件的话, hugo 会根据文件里面的 FrontMatter 的设置生成更个性的页面. 页面和模板的对应关系 页面和模板的应对关系是根据页面的一系列的属性决定的, 这些属性有: Kind, Output Format, Language, Layout, Type, Section. 他们不是同时起作用, 其中 kind, layout, type, section 用的比较多. kind: 用于确定页面的类型, 单页面使用 single.html 为默认模板页, 列表页使用 list.html 为默认模板页, 值不能被修改 section: 用于确定 section tree 下面的文章的模板. section tree 的结构是由 content 目录结构生成的, 不能被修改, content 目录下的一级目录自动成为 root section, 二级及以下的目录, 需要在目录下添加 _index.md 文件才能成为 section tree 的一部分. 如果页面不在 section tree 下 section 的值为空 type: 可以在 Front Matter 中设置, 用户指定模板的类型. 如果没设定 type 的值, type 的值等于 section 的值 或 等于 page(section 为空的时候) layout: 可以在 Front Matter 中设置, 用户指定具体的模板名称. 从层次上 hugo 中的模板分为三个级别的, hugo 依据从上到下的顺序一次查找模板,直到找到为止. 特定页面的模板 应对某一类页面的模板 应对全站的模板: 存放在_default 目录下面的 list.html 和 single.html 页面 HomepageTemplate 查找顺序 ","date":"2020-08-13","objectID":"/2020/08/hugo%E6%95%99%E7%A8%8B/:4:0","tags":null,"title":"Hugo教程","uri":"/2020/08/hugo%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"首页模板的查找顺序 layouts/page/index.html //page为type的默认值 layouts/page/home.html layouts/page/list.html layouts/index.html layouts/home.html layouts/list.html layouts/_default/index.html layouts/_default/home.html layouts/_default/list.html ","date":"2020-08-13","objectID":"/2020/08/hugo%E6%95%99%E7%A8%8B/:5:0","tags":null,"title":"Hugo教程","uri":"/2020/08/hugo%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"设置了 type 属性的首页模板的查找顺序 layouts/type的值/index.html layouts/type的值/home.html layouts/type的值/list.html layouts/index.html layouts/home.html layouts/list.html layouts/_default/index.html layouts/_default/home.html layouts/_default/list.html 如果要设置首页的 type 属性, 需要在 content 目录下面添加_index.md 文件, 并设置 FromtMatter 中的 type 属性, 同时在 layouts 目录下面创建和 type 属性的值相同的目录名. SingePageTemplate 查找顺序 ","date":"2020-08-13","objectID":"/2020/08/hugo%E6%95%99%E7%A8%8B/:6:0","tags":null,"title":"Hugo教程","uri":"/2020/08/hugo%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"section 下单页面模板的查找顺序 layouts/section的值/layout的值.html layouts/section的值/single.html layouts/_default/single.html ","date":"2020-08-13","objectID":"/2020/08/hugo%E6%95%99%E7%A8%8B/:7:0","tags":null,"title":"Hugo教程","uri":"/2020/08/hugo%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"非 section 下单页面模板的查找顺序 layouts/page/layout的值.html layouts/page/single.html //type的默认值 layouts/_default/single.html ","date":"2020-08-13","objectID":"/2020/08/hugo%E6%95%99%E7%A8%8B/:8:0","tags":null,"title":"Hugo教程","uri":"/2020/08/hugo%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"设置了 type 属性的单页面模板的查找顺序 layouts/type的值/layout的值.html layouts/type的值/single.html layouts/_default/single.html SectionTemplate 的查找顺序 section template 为列表类型的模板, 用来展示 section tree 中某个的节点文章列表, Kind 可以轻松地与模板中的 where 函数结合使用，以创建种类特定的内容列表. ","date":"2020-08-13","objectID":"/2020/08/hugo%E6%95%99%E7%A8%8B/:9:0","tags":null,"title":"Hugo教程","uri":"/2020/08/hugo%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"section 模板的查找顺序 layouts/section的值/section的值.html layouts/section的值/section.html layouts/section的值/list.html layouts/section/section的值.html layouts/section/section.html layouts/section/list.html layouts/_default/section的值.html layouts/_default/section.html layouts/_default/list.html ","date":"2020-08-13","objectID":"/2020/08/hugo%E6%95%99%E7%A8%8B/:10:0","tags":null,"title":"Hugo教程","uri":"/2020/08/hugo%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"设置 type 的 section 模板的查找顺序 layouts/type的值/section的值.html layouts/type的值/section.html layouts/type的值/list.html layouts/section的值/section的值.html layouts/section的值/section.html layouts/section的值/list.html layouts/section/section的值.html layouts/section/section.html layouts/section/list.html layouts/_default/section的值.html layouts/_default/section.html layouts/_default/list.html TaxonomyTemplate 的查找顺序 tags 和 categories 是 hugo 默认会创建的两种分类, 如果要手工创建分类可以在 config 文件中配置 [taxonomies] category = \"categories\" tag = \"tags\" 如果不希望 hugo 创建任何分类, 配置 config 中的 disableKinds 属性 disableKinds = [\"taxonomy\", \"taxonomyTerm\"] taxonomy list(某一分类的文章列表)), taxonomy terms list(所有的分类) ","date":"2020-08-13","objectID":"/2020/08/hugo%E6%95%99%E7%A8%8B/:11:0","tags":null,"title":"Hugo教程","uri":"/2020/08/hugo%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"Taxonomy Terms List Pages layouts/categories/category.terms.html layouts/categories/terms.html layouts/categories/list.html layouts/taxonomy/category.terms.html layouts/taxonomy/terms.html layouts/taxonomy/list.html layouts/category/category.terms.html layouts/category/terms.html layouts/category/list.html layouts/_default/category.terms.html layouts/_default/terms.html layouts/_default/list.html ","date":"2020-08-13","objectID":"/2020/08/hugo%E6%95%99%E7%A8%8B/:12:0","tags":null,"title":"Hugo教程","uri":"/2020/08/hugo%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"Taxonomy List Pages layouts/categories/category.html layouts/categories/taxonomy.html layouts/categories/list.html layouts/taxonomy/category.html layouts/taxonomy/taxonomy.html layouts/taxonomy/list.html layouts/category/category.html layouts/category/taxonomy.html layouts/category/list.html layouts/_default/category.html layouts/_default/taxonomy.html layouts/_default/list.html 基础模板–Baseof.html 基础模板页的文件名字为 baseof.html 或 \u003cTYPE\u003e-baseof.html 在基础模板页中使用 block 定义了一个占位符, 当模板页使用了一个基础模板页时, 模板页的解析后的内容会嵌入到基础模板页面中 block 的位置 示例: baseof.html 的内容如下 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003ctitle\u003ebaseof基础模板页\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"content\"\u003e {{- block \"main\" . }}{{- end }} \u003c!-- . 点表示从基础模板页面传递到模板页面的变量 --\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 网站首页引用基础模板页 \u003c!-- block定义的占位符是 'main', 所以这里需要定义名为 'main'的模板 --\u003e {{- define \"main\" -}} \u003csection id=\"posts\" class=\"posts\"\u003e 被define 和 end 包裹的内容会插入到baseof.html文件的{{- block \"main\" . }}{{- end }}位置. \u003c/section\u003e {{- end -}} 除了要在基础模板页使用 block 外, 基础模板页的 命名 和 存放位置 也要征询一定的规制 ","date":"2020-08-13","objectID":"/2020/08/hugo%E6%95%99%E7%A8%8B/:13:0","tags":null,"title":"Hugo教程","uri":"/2020/08/hugo%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"基础模板页的存放位置及命名 /layouts/section/\u003cTYPE\u003e-baseof.html /themes/\u003cTHEME\u003e/layouts/section/\u003cTYPE\u003e-baseof.html /layouts/\u003cTYPE\u003e/baseof.html /themes/\u003cTHEME\u003e/layouts/\u003cTYPE\u003e/baseof.html /layouts/section/baseof.html /themes/\u003cTHEME\u003e/layouts/section/baseof.html /layouts/_default/\u003cTYPE\u003e-baseof.html /themes/\u003cTHEME\u003e/layouts/_default/\u003cTYPE\u003e-baseof.html /layouts/_default/baseof.html /themes/\u003cTHEME\u003e/layouts/_default/baseof.html 自定义数据 Hugo 中的数据库 ","date":"2020-08-13","objectID":"/2020/08/hugo%E6%95%99%E7%A8%8B/:13:1","tags":null,"title":"Hugo教程","uri":"/2020/08/hugo%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"data 目录 在 data 目录下创建 json | yaml | toml 格式的文件. 通过 .Site.Data 变量以 MPA 的方式访问这些数据. 也就是 MAP 的结构组织目录和文件名的. 具体的可以输出 .Site.Data 来查看 例如在 data 目录中存放了两个用户的信息: data/users/jim.toml data/users/tom.toml 文件的内容为: name = \"Jim\" age = 22 address = [ \"地址一\", \"地址二\" ] 在模板中使用这些数据: {{$users := .Site.Data.users}} {{$user_jim := .Site.Data.users.jim}} \u003cdiv\u003ejim.tom文件中的姓名: {{$user_jim.name}}\u003c/div\u003e \u003cdiv\u003e输出users目录下所有文件的内容: {{$users}}\u003c/div\u003e ","date":"2020-08-13","objectID":"/2020/08/hugo%E6%95%99%E7%A8%8B/:14:0","tags":null,"title":"Hugo教程","uri":"/2020/08/hugo%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"外源数据 hugo 还可以通过 getJSON 和 getCSV 两个函数加载外部数据, 这两个函数是模板函数. 在外部数据加载完成以前, hugo 会暂停渲染模板文件. 语法: {{ $dataJ := getJSON \"url\" }} {{ $dataC := getCSV \"separator\" \"url\" }} 带可变参数语法: {{ $dataJ := getJSON \"url prefix\" \"arg1\" \"arg2\" \"arg n\" }} {{ $dataC := getCSV \"separator\" \"url prefix\" \"arg1\" \"arg2\" \"arg n\" }} getCSV 的第一个参数为分隔符. 示例: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eName\u003c/th\u003e \u003cth\u003ePosition\u003c/th\u003e \u003cth\u003eSalary\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e {{ $url := \"https://example.com/demo.csv\" }} {{ $sep := \",\" }} {{ range $i, $r := getCSV $sep $url }} \u003ctr\u003e \u003ctd\u003e{{ index $r 0 }}\u003c/td\u003e \u003ctd\u003e{{ index $r 1 }}\u003c/td\u003e \u003ctd\u003e{{ index $r 2 }}\u003c/td\u003e \u003c/tr\u003e {{ end }} \u003c/tbody\u003e \u003c/table\u003e ","date":"2020-08-13","objectID":"/2020/08/hugo%E6%95%99%E7%A8%8B/:15:0","tags":null,"title":"Hugo教程","uri":"/2020/08/hugo%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"文件结构 helloworld |--CMakeLists.txt |--helloworld.cpp ","date":"2020-08-11","objectID":"/2020/08/cmake%E7%AC%94%E8%AE%B0/:0:1","tags":["cmake"],"title":"Cmake笔记","uri":"/2020/08/cmake%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"CMakeLists.txt # CMake 最低版本号要求 cmake_minimum_required(VERSION 3.0) # 指定项目名称，其实就是给变量PROJECT_NAME赋值 project(HelloWorld) # 查找指定目录下的所有源文件 并存放到指定变量名SRC中 aux_source_directory(. SRC) # 指定生成目标 add_executable(${PROJECT_NAME} ${SRC}) *aux_source_directory这个函数在添加源码文件时，是不会把头文件添加进去的* # CMake 最低版本号要求 cmake_minimum_required(VERSION 3.0) # 项目名称 project(CMakeFile) # 查找指定目录下的所有.cpp与.h文件 并存放到指定变量名SC_FILES中 FILE(GLOB SC_FILES \"*.cpp\" \"*.h\") # 指定生成目标 add_executable(${PROJECT_NAME} ${SC_FILES}) 从第三方获取一些功能的源码文件，如 md5 CMakeFile |--common | |--md5 | |--md5.cpp | |--md5.h |--CMakeLists.txt |--main.cpp |--stdafx.h # CMake 最低版本号要求 cmake_minimum_required(VERSION 3.0) # 项目名称 project(CMakeFile) # 设置md5代码文件的路径 set(MD5_FILE \"./common/md5/md5.cpp\" \"./common/md5/md5.h\") # 查找指定目录下的所有.cpp与.h文件 并存放到指定变量名SC_FILES中 FILE(GLOB SC_FILES \"*.cpp\" \"*.h\") # 对md5的源码分组到md5组里 source_group(md5 FILES ${MD5_FILE}) # 指定生成目标 add_executable(${PROJECT_NAME} ${SC_FILES} ${MD5_FILE}) 一. 初识 cmake - cmake 实践 1.0.0 documentation ","date":"2020-08-11","objectID":"/2020/08/cmake%E7%AC%94%E8%AE%B0/:0:2","tags":["cmake"],"title":"Cmake笔记","uri":"/2020/08/cmake%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":" 博观而约取，厚积而薄发。 ——苏轼 记录一下自己读过的书： 2020 加密与解密 机器学习 统计学习方法 机器学习理论引导 windows 程序设计（珍藏版） C++反汇编与逆向分析技术揭秘 架构修炼之道 阿里巴巴 Java 开发手册（泰山版） 深入理解计算机系统（原书第 3 版） DirectX 12 3D 游戏开发实战 算法（第四版） 码出高效：Java 开发手册 Spring Cloud Alibaba 微服务原理与实战 深入理解 Spring Cloud 与微服务构建 Spring Boot+Vue 全栈开发实战 C++ primer 第五版 深入浅出通信原理 通信原理 算法图解 算法之美 SpringBoot 揭秘：快速构建微服务体系 Python 编程：从入门到实践 2019 Rust 编程之道 Rust 权威指南 图解 HTTP 白帽子讲 Web 安全 白话大数据与机器学习 编码：隐匿在计算机软硬件背后的语言 Java 编程思想 JavaScript 高级程序设计 JavaScript 忍者秘籍 高性能 JavaScript CSS 世界 新时期的 Node.js 入门 Spring Boot 编程思想 汇编语言 第三版 王爽 手把手教你学 51 单片机-C 语言版 C++ Primer Plus 第六版 Java 8 实战 Docker — 从入门到实践 Web 安全攻防：渗透测试实战指南 浮生六记 2018 第一行代码 Android 第二版 Java 编程思想 数据结构教程 JavaScript 函数式编程 The Linux Command Line 鸟哥的 Linux 私房菜 Vue.js 实战 JavaScript DOM 编程艺术 永恒的终结 人间失格 解忧杂货店 秘密 嫌疑人 X 的献身 彷徨之刃 恶意 白夜行 幻夜 1984 动物庄园 ","date":"2020-08-11","objectID":"/books/:0:0","tags":null,"title":"书单","uri":"/books/"},{"categories":null,"content":"天蝎男，爱羽毛球。 技能点： 前端：Vue+React 后端：Java，Spring Boot，Rust，Nodejs Qt 单片机 Win32 编程 x86 汇编 逆向 ","date":"2020-08-11","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":["算法"],"content":"0-1 背包 有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 cost[i]， 价值是 value[i]。求解将哪些物品装入背包可使价值总和最大 //初始化 letv=2;//背包体积 letn=4;//物品个数,必须等于cost和value的长度 letcost=vec![1,2,3,4];//物品花费 letvalue=vec![1,3,5,7];//物品价值 letmutf=vec![0;v+1];// 0 \u003c= i \u003c n foriin0..n{zoro_one_pack(\u0026mutf,cost[i],value[i],v);}//最后价值总和最大的值就是f[v] fn zoro_one_pack(f: \u0026mutVec\u003cusize\u003e,cost: usize,value: usize,v: usize){forjin(cost..=v).rev(){f[j]=std::cmp::max(f[j],f[j-cost]+value);}} 注意： 如果题目要求 恰好装满背包 ,则除了f[0]设为 0，其余都设为 $-∞$，如果不要求恰好装满，则f全初始化为 0。 ","date":"2020-08-10","objectID":"/2020/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:0:0","tags":["算法","背包问题"],"title":"背包问题","uri":"/2020/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"一个常数优化 //伪代码 foriin0..n{forjin(cpm::max(cost[i],v-(cost[i]+..+cost[n-1]))..=v).rev(){f[j]=std::cmp::max(f[j],f[j-cost[i]]+value[i]);}} 完全背包 有 N 种物品和一个容量为V 的背包，每种物品都有无限件可用。放入第 i 种物品的费用是 cost[i]，价值是 value[i]。求解：将哪些物品装入背包，可使这些物品的耗费的费用总 和不超过背包容量，且价值总和最大 思路是转化成0-1 背包：将一种物品拆成多件只能选 0 件或 1 件的 01 背包中的物品。 //初始化 letv=2;//背包体积 letn=4;//物品个数,必须等于cost和value的长度 letcost=vec![1,2,3,4];//物品花费 letvalue=vec![1,3,5,7];//物品价值 letmutf=vec![0;v+1];// 0 \u003c= i \u003c n foriin0..n{complete_pack(\u0026mutf,cost[i],value[i],v);}//最后价值总和最大的值就是f[v] fn complete_pack(f: \u0026mutVec\u003cusize\u003e,cost: usize,value: usize,v: usize){//就是将0-1背包中内层循环次序反转 forjincost..=v{f[j]=std::cmp::max(f[j],f[j-cost]+value);}} 多重背包 有 N 种物品和一个容量为 V 的背包。第 i 种物品最多有 M[i] 件可用，每件耗费的空间是 cost[i]，价值是 value[i]。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超 过背包容量，且价值总和最大 fn multiple_pack(f: \u0026mutVec\u003cusize\u003e,cost: usize,value: usize,v: usize,mutm: usize){ifcost*m\u003e=v{complete_pack(f,cost,value,v);return;}letmutk=1;whilek\u003cm{zoro_one_pack(f,k*cost,k*value,v);m-=k;k*=2;}zoro_one_pack(f,m*cost,m*value,v)} ","date":"2020-08-10","objectID":"/2020/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:0:1","tags":["算法","背包问题"],"title":"背包问题","uri":"/2020/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"可行性问题 当问题是“每种有若干件的物品能否填满给定容量的背包”，只须考虑填满背包的可行性，不需考虑每件物品的价值时，多重背包问题同样有 O(VN) 复杂度的算法 fn multiple_pack_ok(){//也可以用硬币模型来理解。v代表硬币的总价值，n代表硬币的种类， //m是每个硬币的数量，cost代表每种硬币的价值 letv=2;letn=4;letcost=vec![5,4,9,3];letm=vec![2,1,4,6];letmutf=vec![-1;v+1];f[0]=0;foriin0..n{forjin0..=v{iff[j]\u003e=0{f[j]=m[i];}//else { // f[j] = -1; 应为默认初始化就是-1 //} }ifv\u003ccost[i]{break;}forjin0..=(v-cost[i]){iff[j]\u003e=0{f[j+cost[i]]=std::cmp::max(f[j+cost[i]],f[j]-1);}}}} f[i][j]表示使用前i个物品，填充容量为j的背包，第i个物品最多能够剩余多少个，如果无法填充容量为j的背包，则值为-1 首先，f[i - 1][j] 代表前 i - 1 件物品凑面值 j，如果其值大于等于 0 即状态合法可以凑出j，就说明接下来不需要第i种硬币就能凑出j，所以剩余的硬币数就是m[i]了。 如果f[i - 1][j]小于0，说明前i-1种凑不出来j。加上第i个硬币可能面值太大，也可能正好，所以先取 -1待定。 f[i][j + cost[i]] = std::cmp::max(f[i][j + cost[i]], f[i][j] - 1); 如果能凑成j+cost[i],那么就把硬币数量-1，如果不行，就维持-1的状态。 然后把二维数组改为一位数组。 混合背包 就是上面三种背包混合在一起 //伪代码： foriin0..n{ifi是01背包{zero_one_pack(..);}elseifi是完全背包{complete_pack(..);}elseifi是多重背包{multiple_pack(..);}} 男人八题之多重背包问题 二维背包 对于每件物品，具有两种不同的费用，选择这件物品必须同时付出这两种费用。对于每种费用都有一个可付出的最大值（背包容量）。问怎样 选择物品可以得到最大的价值。 设第 i 件物品所需的两种费用分别为 Ci 和 Di。两种费用可付出的最大值（也即两种背包容量）分别为 V 和 U。物品的价值为 Wi 状态转移方程如下： F[i, v, u] = max{F[i − 1, v, u], F[i − 1, v − Ci, u − Di] +Wi} 有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取 U 件物品。 这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为 1，可以 付出的最大件数费用为 U 分组背包 有 N 件物品和一个容量为 V 的背包。第 i 件物品的费用是 Ci，价值是 Wi。这些物品被划分为 K 组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包 可使这些物品的费用总和不超过背包容量，且价值总和最大 设 F[k, v] 表示前 k 组物品花费费用 v 能取得的最大权值，则有： F[k, v] = max{F[k − 1, v], F[k − 1, v − Ci] + Wi | item i ∈ group k} fn group_pack(f: \u0026mutVec\u003cusize\u003e,v: usize,cost: \u0026Vec\u003cusize\u003e,value: \u0026Vec\u003cusize\u003e){letgroup=cost.len();forjin(0..=v).rev(){forkin0..group{ifj\u003ccost[k]{break;}f[j]=cmp::max(f[j],f[j-cost[k]]+value[k]);}}}fn test_group(){letv=4;letn=3;letcost=vec![vec![1,2],vec![3,4],vec![5,6]];//三组 letvalue=vec![vec![3,2],vec![1,5],vec![2,4]];// letmutf=vec![0;v+1];foriin0..n{group_pack(\u0026mutf,v,\u0026cost[i],\u0026value[i]);}dbg!(\u0026f[v]);} 有依赖的背包问题 也就是说，物品 i 依赖于物品 j，表示若选物品 i，则必须选物品 j。 可以对主件 k 的“附件集合”先进行一次 01 背包，得到费用依次为 0. . .V − Ck 所有这些值时相应的最 大价值 Fk[0 . . . V − Ck]。那么，这个主件及它的附件集合相当于 V − Ck + 1 个物品的 物品组，其中费用为 v 的物品的价值为 Fk[v −Ck] +Wk，v 的取值范围是 Ck ≤ v ≤ V。 也就是说，原来指数级的策略中，有很多策略都是冗余的，通过一次 01 背包后，将主件 k 及其附件转化为 V −Ck + 1 个物品的物品组，就可以直接应用分组背包的算法解决问题了 背包问题总结（下） /* 即物品间存在依赖，比如i依赖于j，表示若选物品i，则必须选物品j http://acm.hdu.edu.cn/showproblem.php?pid=3449 有很多个箱子，想买箱子中的物品必须先买下箱子，典型的依赖背包 将不依赖其他物品的物品称为主件，依赖其他物品的物品称为附件 我们有n个箱子，箱子里面的物品个数为cnt[i] 那么箱子称为主件，箱子里面的物品称为附件 那么考虑一个主件和它附件的集合，那么有2^n+1种策略，每种策略都是互斥的。所以它是分组背包问题。 但是不能像一般的分组背包那样处理，因为组内有2^n+1种。 但是考虑到费用相同时，只选择价值最大的。所以可以对组内的附件进行01背包，得到费用依次为v-c[i]...0的最大价值 dp2[v-c[i]...0] */ #include \u003cstdio.h\u003e #include \u003cstring.h\u003e int dp[100000+10],dp2[100000+10]; int box[55],cnt[55],price[55][11],value[55][11]; inline int max(const int \u0026a, const int \u0026b) { return a \u003c b ? b : a; } int main() { int n,v,i,j,k; while(scanf(\"%d%d\",\u0026n,\u0026v)!=EOF) { memset(dp,0,sizeof(dp)); for(i=1; i\u003c=n; ++i) { scanf(\"%d%d\",\u0026box[i],\u0026cnt[i]); memcpy(dp2,dp,sizeof(dp)); for(j=1; j\u003c=cnt[i]; ++j) { scanf(\"%d%d\",\u0026price[i][j],\u0026value[i][j]); for(k=v-box[i]; k\u003e=price[i][j]; --k)//附件进行01背包，每个dp2[k]对于组内的一种策略 dp2[k] = max(dp2[k],dp2[k-price[i][j]]+value[i][j]); } for(k=box[i];k\u003c=v; ++k) dp[k] = max(dp[k],dp2[k-box[i]]);//当容量为k时，取第i组的物品时得到的最大值和不取比较哪个大 } printf(\"%d\\n\",dp[v]); } return 0; } ","date":"2020-08-10","objectID":"/2020/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:0:2","tags":["算法","背包问题"],"title":"背包问题","uri":"/2020/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"SSVM 简介 SSVM 是适用于云，AI 和区块链应用程序的高性能，企业级 WebAssembly（WASM）虚拟机。包括以下用例： Node.js 应用程序中 Rust 函数的高性能和安全运行时 针对 ONNX AI 模型的硬件优化的运行时 适用于领先的区块链平台的智能合约运行时引擎 一个简单的 Web App 功能：base64 的编码和解码 ","date":"2020-08-01","objectID":"/2020/08/webassembly/:0:0","tags":["wasm","Rust"],"title":"WebAssembly","uri":"/2020/08/webassembly/"},{"categories":null,"content":"首先在 rust 的 lib 文件中编写实际的用来编码和解码的代码： usebase64::{decode,encode};usewasm_bindgen::prelude::*;#[wasm_bindgen]pubfn base64Encode(s: \u0026str)-\u003e String {encode(s)}#[wasm_bindgen]pubfn base64Decode(s: \u0026str)-\u003e String {String::from_utf8(decode(s).unwrap()).unwrap()} ","date":"2020-08-01","objectID":"/2020/08/webassembly/:0:1","tags":["wasm","Rust"],"title":"WebAssembly","uri":"/2020/08/webassembly/"},{"categories":null,"content":"然后在 node 中调用 rust 代码： const { base64Encode, base64Decode, } = require('../pkg/ssvm_nodejs_starter_lib.js') const http = require('http') const url = require('url') const hostname = '0.0.0.0' const port = 3000 const server = http.createServer((req, res) =\u003e { const queryObject = url.parse(req.url, true).query if (queryObject['encodeStr']) { res.end(base64Encode(queryObject['encodeStr']) + '\\n') } else if (queryObject['decodeStr']) { console.log(queryObject['decodeStr']) res.end(base64Decode(queryObject['decodeStr']) + '\\n') } else { res.end( `Please use command curl http://${hostname}:${port}/?encodeStr=string or http://${hostname}:${port}/?decodeStr=string \\n` ) } }) server.listen(port, hostname, () =\u003e { console.log(`Server running at http://${hostname}:${port}/`) }) ","date":"2020-08-01","objectID":"/2020/08/webassembly/:0:2","tags":["wasm","Rust"],"title":"WebAssembly","uri":"/2020/08/webassembly/"},{"categories":null,"content":" 1.添加 wpa_supplicant.conf 文件 在 boot 分区下添加 wpa_supplicant.conf 文件，文件内容写入 country=CN ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev network={ ssid=\"my_wifi\" psk=\"12345678\" key_mgmt=WPA-PSK } 2.开启 ssh 在 boot 分区下新建 ssh 文件，无内容 3.插卡，启动 启动后树莓会自动链接 wifi，但是有个问题，不知道树莓的自动获取的 ip 方法 1： 如果网络中只有一个 pi，可以直接 ping raspberrypi 方法 2： nmap -sn 192.168.1.0/24 方法 3： 打开路由，看看已连接设备，叫 raspberrypi 的就是 默认用户名：pi 默认密码：raspberry ","date":"2020-07-31","objectID":"/2020/07/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%AC%94%E8%AE%B0/:0:0","tags":["树莓派"],"title":"树莓派笔记","uri":"/2020/07/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%AC%94%E8%AE%B0/"},{"categories":["算法"],"content":"图 ","date":"2020-07-19","objectID":"/2020/07/%E7%AE%97%E6%B3%95/:1:0","tags":["算法"],"title":"算法","uri":"/2020/07/%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"无向图 图的表示方法：邻接表 dfs 和 bfs 的区别：dfs 是用栈，bfs 用队列 //连通图 public class CC { private boolean[] marked; private int[] id; private int count; public CC(Graph G) { marked = new boolean[G.V()]; id = new int[G.V()]; for (int s = 0; s \u003c G.V(); s++) { dfs(G, s); count++; } } private void dfs(Graph G, int v) { marked[v] = true; id[v] = count; for (int w : G.adj(v)) if (!marked[w]) dfs(G, w); } } ","date":"2020-07-19","objectID":"/2020/07/%E7%AE%97%E6%B3%95/:1:1","tags":["算法"],"title":"算法","uri":"/2020/07/%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"有向图 有向无环图(DAG): 不含有向环的有向图 当且仅当一副有向图是无环图时它才能进行拓扑排序 有向图中基于 dfs 的顶点排序：前序、后续、逆后续 前序和后续用队列，逆后续用栈 一副有向无环图的拓扑排序就是所有顶点的逆后续排列（要先判断有没有环） 强连通 ：两个顶点互联可达，则这两个顶点是强连通。若一个图任意两顶点都是强连通，则这幅有向图也是强连通的。 计算强连通分量的 Kosaraju 算法：先使用 dfs 查找 G 的反向图，得到所有顶点的逆后续，再用 dfs 处理，即可得到强连通分量 //强连通分量 public class KosarajuSCC { private boolean[] marked; private int[] id; private int count; public KosarajuSCC(Digraph G) { marked = new boolean[G.V()]; id = new int[G.V()]; DepthFirstOrder order=new DepthFirstOrder(G.reverse()); for (int s:order.reversePost()) { dfs(G, s); count++; } } private void dfs(Digraph G, int v) { marked[v] = true; id[v] = count; for (int w : G.adj(v)) if (!marked[w]) dfs(G, w); } } ","date":"2020-07-19","objectID":"/2020/07/%E7%AE%97%E6%B3%95/:1:2","tags":["算法"],"title":"算法","uri":"/2020/07/%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2020-07-19","objectID":"/2020/07/%E7%AE%97%E6%B3%95/:2:0","tags":["算法"],"title":"算法","uri":"/2020/07/%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"插入排序 fn insert\u003cT: Ord +Copy\u003e(a: \u0026mut[T]){foriin1..a.len(){lettmp=a[i];letmutj=i;whilej\u003e0\u0026\u0026tmp\u003ca[j-1]{a[j]=a[j-1];j-=1;}a[j]=tmp;}} ","date":"2020-07-19","objectID":"/2020/07/%E7%AE%97%E6%B3%95/:2:1","tags":["算法"],"title":"算法","uri":"/2020/07/%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"希尔排序 fn shell\u003cT: Ord +Copy\u003e(a: \u0026mut[T]){letn=a.len();letmuth=1;whileh\u003cn/3{h=h*3+1;}whileh\u003e=1{foriinh..n{lettmp=a[i];letmutj=i;whiletmp\u003ca[j-h]{a[j]=a[j-h];j-=h;ifletNone=j.checked_sub(h){break;}}a[j]=tmp;}h/=3;}} ","date":"2020-07-19","objectID":"/2020/07/%E7%AE%97%E6%B3%95/:2:2","tags":["算法"],"title":"算法","uri":"/2020/07/%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"归并排序 //原地归并 fn merge_help\u003cT: Ord +Copy\u003e(a: \u0026mut[T],lo: usize,mid: usize,hi: usize){ifa[mid]\u003c=a[mid+1]{return;}letmuttmp=a.to_owned();//tmp.copy_from_slice(a); letmuti=lo;letmutj=mid+1;forkinlo..=hi{ifi\u003emid{a[k]=tmp[j];j+=1;}elseifj\u003ehi{a[k]=tmp[i];i+=1;}elseiftmp[j]\u003ctmp[i]{a[k]=tmp[j];j+=1;}else{a[k]=tmp[i];i+=1;}}}//自顶向下的归并排序 fn merge_sort\u003cT: Ord +Copy\u003e(a: \u0026mut[T],lo: usize,hi: usize){ifhi\u003c=lo{return;}//数组较小时用插入排序更快 ifhi-lo\u003c15{insert(\u0026muta[lo..=hi])}letmid=(lo+hi)/2;merge_sort(a,lo,mid);merge_sort(a,mid+1,hi);merge_help(a,lo,mid,hi);}fn merge\u003cT: Ord +Copy\u003e(a: \u0026mut[T]){merge_sort(a,0,a.len()-1);}//自底向上的归并 fn merge_sort_bu\u003cT: Ord +Copy\u003e(a: \u0026mut[T],lo: usize,hi: usize){letn=a.len();letmutsz=1;whilesz\u003cn{letmutlo=0;whilelo\u003cn-sz{merge_help(a,lo,lo+sz-1,std::cmp::min(lo+sz+sz-1,n-1));lo+=2*sz;}sz*=2;}} ","date":"2020-07-19","objectID":"/2020/07/%E7%AE%97%E6%B3%95/:2:3","tags":["算法"],"title":"算法","uri":"/2020/07/%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"堆排序 #[derive(Debug)]struct MaxPQ\u003cT: Ord +Copy\u003e{pq: Vec\u003cT\u003e,}impl\u003cT: Ord +Copy+std::fmt::Debug\u003eMaxPQ\u003cT\u003e{fn new(zero: T)-\u003e Self{letpq=vec![zero];Self{pq}}fn is_empty(\u0026self)-\u003e bool {self.pq.len()\u003c=1}fn insert(\u0026mutself,v: T){self.pq.push(v);letn=self.pq.len()-1;self.swim(n);}fn swim(\u0026mutself,mutk: usize){whilek\u003e1\u0026\u0026self.pq[k]\u003eself.pq[k/2]{self.pq.swap(k/2,k);k/=2;}}fn sink(\u0026mutself,mutk: usize,N: usize){lettmp=self.pq[k];whilek*2\u003c=N{letmutj=k*2;ifj\u003cN\u0026\u0026self.pq[j]\u003cself.pq[j+1]{j+=1;}ifself.pq[k]\u003e=self.pq[j]{break;}self.pq[k]=self.pq[j];k=j;}self.pq[k]=tmp;}fn sort(a: \u0026mut[T])-\u003e Vec\u003cT\u003e{letmutn=a.len();letmutpq=MaxPQ::new(a[0]);pq.pq.append(\u0026muta.to_vec());forkin(1..=(n/2)).rev(){MaxPQ::sink(\u0026mutpq,k,n);}whilen\u003e1{pq.pq.swap(1,n);n-=1;MaxPQ::sink(\u0026mutpq,1,n);}pq.pq.remove(0);pq.pq}} Api： public class UF{ UF(int N);//初始化N个触点 void union(int p,int q) //在p和q之间添加一条连接 int find(int p) // p所在的分量的标识符 boolean connected(intp ,int q)//如果q和p在同一各分量中则返回true int count()//联通分量的数量 } ","date":"2020-07-19","objectID":"/2020/07/%E7%AE%97%E6%B3%95/:2:4","tags":["算法"],"title":"算法","uri":"/2020/07/%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"快速排序 fn quick_sort(a:\u0026[i32],lo:i32,hi:i32){} voidgetNext(char*p,int*next){//next.length=p.length next[0]=-1;inti=0,j=-1;while(i\u003cstrlen(p)-1){if(j==-1||p[i]==p[j]){++i;++j;//next[i] = j; //下面是优化 if(p[i]!=p[j])next[i]=j;elsenext[i]=next[j];}elsej=next[j];}}intKMP(char*t,char*p){inti=0;intj=0;while(i\u003cstrlen(t)\u0026\u0026j\u003c(int)strlen(p)){if(j==-1||t[i]==p[j]){i++;j++;}elsej=next[j];}if(j==strlen(p))returni-j;elsereturn-1;} ","date":"2020-07-19","objectID":"/2020/07/%E7%AE%97%E6%B3%95/:2:5","tags":["算法"],"title":"算法","uri":"/2020/07/%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"加权 quick-union 算法： 将小数的根节点连接到大树的根节点 public class WeightedQuickUnionUF{ private int[] id; private int[] sz; private int count; public WeightedQuickUnionUF(int N) { count = N; id = new int[N]; for (int i = 0; i \u003c N; i++) id[i] = i; sz = new int[N]; for (int i = 0; i \u003c N; i++) sz[i] = 1; } public int getCount() { return count; } public boolean connected(int p, int q) { return find(p) == find(q); } public int find(int p) { while (p != id[p]) p = id[p]; return p; } public void union(int p, int q) { int i = find(p); int j = find(q); if (i == j) return; if (sz[i] \u003c sz[j]) { id[i] = j; sz[j] += sz[i]; } else { id[j] = i; sz[i] += sz[j]; } count--; } } ","date":"2020-07-19","objectID":"/2020/07/%E7%AE%97%E6%B3%95/:3:0","tags":["算法"],"title":"算法","uri":"/2020/07/%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"最优解法：路径压缩的加权 quick-union 算法 要实现路径压缩，只需要为find()添加一个循环，将在路径上遇到的所有节点都直接链接到根节点。 public int find(int p) { int root = p; while (root != id[root]) root = id[root]; while (p!=root) { int next = id[p]; id[p] = root; p = next; } return root; } ","date":"2020-07-19","objectID":"/2020/07/%E7%AE%97%E6%B3%95/:4:0","tags":["算法"],"title":"算法","uri":"/2020/07/%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"BM 算法原理 字符串匹配 —- BM 算法原理 ","date":"2020-07-19","objectID":"/2020/07/%E7%AE%97%E6%B3%95/:5:0","tags":["算法"],"title":"算法","uri":"/2020/07/%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"Qt 快速入门系列教程 Qt 如果用 cmake 构建的话，默认是没有 UNICODE 预定义的，也就是说调用的 win32 api 都是 A 版的，而不是 W 版，解决方法是在 CMakeLists.txt 中加入 add_definitions(-DUNICODE -D_UNICODE) ","date":"2020-07-09","objectID":"/2020/07/qt%E7%AC%94%E8%AE%B0/:0:0","tags":["c++","Qt"],"title":"Qt笔记","uri":"/2020/07/qt%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"设置透明而空间不透明 this-\u003esetWindowFlags(Qt::FramelessWindowHint); this-\u003esetWindowOpacity(1); this-\u003esetAttribute(Qt::WA_TranslucentBackground); ","date":"2020-07-09","objectID":"/2020/07/qt%E7%AC%94%E8%AE%B0/:0:1","tags":["c++","Qt"],"title":"Qt笔记","uri":"/2020/07/qt%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"关于常用 setWindowFlags 的状态设置： Qt::FramelessWindowHint 窗口无边框 Qt::WindowStaysOnTopHint 窗口置顶 Qt::WindowMaximized 窗口启动最大化 Qt::SubWindow 表示窗口小部件是子窗口 ","date":"2020-07-09","objectID":"/2020/07/qt%E7%AC%94%E8%AE%B0/:0:2","tags":["c++","Qt"],"title":"Qt笔记","uri":"/2020/07/qt%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"Dubbo 的功能除了基本的 RPC 职能外，核心功能便是监控及服务注册。 ","date":"2020-06-28","objectID":"/2020/06/dubbo%E5%85%A5%E9%97%A8/:0:0","tags":["微服务"],"title":"Dubbo入门","uri":"/2020/06/dubbo%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"provider 服务 首先创建一个 maven 工程：springboot-provider，再添加一个 moven 模块：sample-api，再里面创建一个接口：IHelloService public interface IHelloService { String sayHello(String name); } 然后mvn install springboot-provide这个顶层项目，这会在本地的 maven 仓库安装这父子两个库。 再添加一个 springboot 模块：sample-provider，来实现IHelloService接口 @DubboService public class HelloServiceImpl implements IHelloService { @Value(\"${dubbo.application.name}\") private String serviceName; @Override public String sayHello(String s) { return String.format(\"[%s]: Hello,%s\", serviceName, s); } } 在 pom.xml 添加依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.apache.dubbo\u003c/groupId\u003e \u003cartifactId\u003edubbo-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e2.7.7\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.example\u003c/groupId\u003e \u003cartifactId\u003esample-api\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e 在 application.properties 添加 dubbo 的配置 dubbo.application.name=jesse-dubbo dubbo.protocol.port=20880 dubbo.protocol.name=dubbo dubbo.registry.address=N/A 启动类： @DubboComponentScan @SpringBootApplication public class SampleProviderApplication { public static void main(String[] args) { SpringApplication.run(SampleProviderApplication.class, args); } } provider 服务就启动了~ ","date":"2020-06-28","objectID":"/2020/06/dubbo%E5%85%A5%E9%97%A8/:1:0","tags":["微服务"],"title":"Dubbo入门","uri":"/2020/06/dubbo%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"consumer 服务 新建一个 springboot 项目：springboot-consumer，在 pom.xml 添加依赖，同上。同样也要在 application.properties 添加 dubbo 的配置，不过最少只要配置 name 就行 dubbo.application.name=springboot-consumer 启动类： @SpringBootApplication public class SpringbootConsumerApplication { @DubboReference(url = \"dubbo://127.0.0.1:20880\") private IHelloService helloService; public static void main(String[] args) { SpringApplication.run(SpringbootConsumerApplication.class, args); } @Bean public ApplicationRunner runner(){ return args -\u003e System.out.println(helloService.sayHello(\"Mic\")); } } 完~ ","date":"2020-06-28","objectID":"/2020/06/dubbo%E5%85%A5%E9%97%A8/:2:0","tags":["微服务"],"title":"Dubbo入门","uri":"/2020/06/dubbo%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"win32 根据进程名获取进程 ID 或者终止进程： https://blog.csdn.net/zjx_cfbx/article/details/82390064 https://blog.csdn.net/ouchengguo/article/details/88602267 https://blog.csdn.net/zwhuang/article/details/2218651 https://www.write-bug.com/article/1568.html ","date":"2020-03-15","objectID":"/2020/03/win32/:0:0","tags":["win32"],"title":"Win32","uri":"/2020/03/win32/"},{"categories":null,"content":"从窗口句柄获取进程句柄 FindWindow：找串口句柄 GetWindowThreadProcessId：由窗口句柄找进程 id OpenProcess：由进程 id 得进程句柄 ","date":"2020-03-15","objectID":"/2020/03/win32/:0:1","tags":["win32"],"title":"Win32","uri":"/2020/03/win32/"},{"categories":null,"content":"内存读写 ReadProcessMemory WriteProcessMemory ","date":"2020-03-15","objectID":"/2020/03/win32/:0:2","tags":["win32"],"title":"Win32","uri":"/2020/03/win32/"},{"categories":null,"content":"通过快照来获取进程 ID HANDLE WINAPI CreateToolhelp32Snapshot(DWORD dwFlags,DWORD th32ProcessID); BOOL WINAPI Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe); BOOL WINAPI Process32Next(HANDLE hSnapshot,LPPROCESSENTRY32 lppe); //结果 typedef struct tagPROCESSENTRY32 { DWORD dwSize; // 结构大小； DWORD cntUsage; // 此进程的引用计数； DWORD th32ProcessID; // 进程ID; DWORD th32DefaultHeapID; // 进程默认堆ID； DWORD th32ModuleID; // 进程模块ID； DWORD cntThreads; // 此进程开启的线程计数； DWORD th32ParentProcessID; // 父进程ID； LONG pcPriClassBase; // 线程优先权； DWORD dwFlags; // 保留； char szExeFile[MAX_PATH]; // 进程全名； } PROCESSENTRY32; x64-dbg 使用： https://www.bilibili.com/s/video/BV1jK4y1b7wc cs source:控制台（~） sv_cheats 1 bot_add_t bot_stop 1 bot_stop 0 ","date":"2020-03-15","objectID":"/2020/03/win32/:0:3","tags":["win32"],"title":"Win32","uri":"/2020/03/win32/"},{"categories":null,"content":"设置滚动条： SetScrollInfo GetScrollInfo 滚动条变化了调用 ScrollWindows,再调用 UpdateWindow ","date":"2020-03-15","objectID":"/2020/03/win32/:0:4","tags":["win32"],"title":"Win32","uri":"/2020/03/win32/"},{"categories":null,"content":"DC 三种获取方法与销毁方法（要成对出现） GetDC()——ReleaseDC() GeginPaint()——EndPaint() GetCompatibleDC()——DeleteDC() ","date":"2020-03-15","objectID":"/2020/03/win32/:0:5","tags":["win32"],"title":"Win32","uri":"/2020/03/win32/"},{"categories":null,"content":"为防止头文件被多次引用，采用 #ifndef xxx #define xxx ... #endif xxx可以根据头文件名字来定义一个唯一的名字。 int global=1000;//可以在别的文件用extern引用 static int one_file=50;//只能在本文件用 const int f=10;//等于 static const int f=10;其他文件不能用 extern const int g=10;//其他文件可以用 void fun1(){ static int c=0;//静态，只能在本函数内用 } 以上代码表示 static 有 2 种意义： 1.用于局部声明，表示变量是静态变量。 2.用于代码块外声明，表示内部链接性，而变量已经是静态了。 未被初始化的静态变量所有位都被设置为 0，成为零初始化。 constexpr：创建常亮表达式 变量声明： 定义声明，会开辟空间 double up; extern char gz='z’; //因为有初始化所以也是定义声明 引用声明，不会开辟空间 extern int b; 函数的链接性默认为外部的，即其他文件可以用（用 extern 或者不用）,用 static 设置为内部的。 ","date":"2020-02-11","objectID":"/2020/02/c-%E7%AC%94%E8%AE%B0/:0:0","tags":["c++"],"title":"C++笔记","uri":"/2020/02/c-%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"语言链接性 在 c 语言中，如spiff这样的函数名翻译成_spiff，这称为 c 语言链接性，而 c++也有 c++的语言链接性，和 C 不同。 extern \"C\" void spiff(int); //用C的语言链接性查找函数 extern void spoff(int); //默认就是C++语言链接性查找函数 extern \"C++\" void spaff(int);//或显式 ","date":"2020-02-11","objectID":"/2020/02/c-%E7%AC%94%E8%AE%B0/:1:0","tags":["c++"],"title":"C++笔记","uri":"/2020/02/c-%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"命名空间 用户命名空间: namespace Jack{ double p; void f(); } 可以把名称加入到已有的名称空间中。 访问： Jack::f(); 或者 using Jack::f; f() 或者 using namespace Jack; f(); struct 默认是 public 的，class 默认是 private 的。 Stock s1=Stock(\"aa\",11);//初始化，可能会创建临时对象（也可能不会） Stock s2(\"aa\",1);//同上 s2=Stock(\"b\",11);//赋值，一定会创建一个临时变量 Stock s3={\"cc\",11};//列表初始化 Stock s4{\"cc\",11}; const 成员函数：void Stock::show() const，只要类方法不修改对象，就应该 声明为 const 接受一个参数的构造函数允许用赋值语法将对象初始化为一个值: Classname obj=value; ","date":"2020-02-11","objectID":"/2020/02/c-%E7%AC%94%E8%AE%B0/:2:0","tags":["c++"],"title":"C++笔记","uri":"/2020/02/c-%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"两种类型转换： Stock(double d);//会将double隐式转换成Stock Stock(double d,int a=0);//第二个提供默认值也会隐式转化 explicit Stock(double d);//会关闭隐式转化 上面是将数字转化成类对象 下面是将类对象转化成数字，叫做转换函数 operator double();//转换成double explicit operator double();//同样，需要显示类型转换才会转换，如(double) xx; c++会默认提供下面成员函数： 默认构造函数 默认析构函数 复制构造函数 Class_name(const Class_name \u0026); Class StringBad{}; StringBad d(m); StringBad d=m; StringBad d=StringBad(m); StringBad *p=new StringBad(m); 其中中间 2 种可能生成中间匿名对象，最后一种一定生成中间匿名对象 赋值运算符 地址运算符 StringBad a(\"aa\"); Stringbad b; b=a;//会调用赋值运算符 StringBad c=a;//会调用复制构造函数，不一定调用赋值运算符 对 const 数据成员，和引用类成员，初始化必须用初始化列表来初始化。 对于简单数据类型成员，使用初始化列表和在函数体内赋值没什么区别，但对于本身就是类对象的成员来时使用初始化列表效率更高。 右值引用 如int \u0026\u0026 r=13;，int \u0026\u0026 r = x+y，传统的左值引用只能出现在=的左边，现在的右值引用如常量是出现在=的右边。右值引用的目的之一是实现移动语义。 ","date":"2020-02-11","objectID":"/2020/02/c-%E7%AC%94%E8%AE%B0/:2:1","tags":["c++"],"title":"C++笔记","uri":"/2020/02/c-%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"移动语义 移动语义实际上避免的移动原始数据，而只是修改了记录。 使用std::move()一般会导致移动操作，但并非一定会 如果您提供了析构函数、复制构造函数或 复制赋值运算符，编译器将不会自动提供移动构造函数和移动赋值运算符； 如果您 提供了移动构造函数或移动赋值运算符，编译器将不会自动提供默认构造函数，复制构造函数和复制赋值运算符。 使用关键字 default 显式地声明这些方法的默认版本 关键字 delete 可用于禁止编译器使用特定方法 关键字 default 只能用于 6 个特殊成员函数，但 delete 可用于任何成员函数。 delete 的一种可能用法是禁止特定的转换。 在一个构造函数的定义中使用另一个构造函数，这被称为委托。 c++ primer 读书笔记 ","date":"2020-02-11","objectID":"/2020/02/c-%E7%AC%94%E8%AE%B0/:2:2","tags":["c++"],"title":"C++笔记","uri":"/2020/02/c-%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"2.基本内置类型 带符号数与无符号数操作时，会变成无符号数。如，-1 会变成 255 定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。在函数体外默认是 0。类的对象如果没有显示初始化，其值由类确定。 const int *p=nullptr;//p是一个指向整形常量的指针 constexpr int *q=nullptr;//q是一个指向整形的常量指针 typedef char *ps; const ps cstr=0;//常量指针 const ps *p;//指向常量指针 //不能把别名带入理解，是错误的 auto 会忽略顶层 const，底层 const 会保留。auto 赋值等号右边是一个引用时，auto 类型是没有引用的。 decltype 返回操作数的数据类型。如果表达式是一个变量，会返回变量的类型（包括 const 和引用）,如果表达式内容是解引用操作，会得到引用类型；如果是加了括号的表达式，会得到引用 ","date":"2020-02-11","objectID":"/2020/02/c-%E7%AC%94%E8%AE%B0/:3:0","tags":["c++"],"title":"C++笔记","uri":"/2020/02/c-%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"3.字符串、向量和数组 不能把字面值直接相加 使用数组作为一个 auto 变量的初始值时，推断得到的类型是指针而非数组 用 for 语句处理多维数组时，除了最内层的循环外，其他所有的控制变量都应该是引用类型 ","date":"2020-02-11","objectID":"/2020/02/c-%E7%AC%94%E8%AE%B0/:4:0","tags":["c++"],"title":"C++笔记","uri":"/2020/02/c-%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"4.表达式 static_cast:只要不包含底层 const，都可以用来类型转化 const_cast: 只能改变对象的底层 const 性质（去掉或增加） reinterpret_cast:强制转化，很危险 ","date":"2020-02-11","objectID":"/2020/02/c-%E7%AC%94%E8%AE%B0/:5:0","tags":["c++"],"title":"C++笔记","uri":"/2020/02/c-%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"6.函数 当用实参初始化形参时会忽略掉顶层 const。形参的顶级 const 被忽略了。而底层 const 不会被忽略。 如果形参数量未知，但类型相同，可以用标准库的initializer_list类型的形参，这是一个模板类型。 调用一个返回引用的函数得到左值，其他类型得到右值。如果返回类型是常量引用，则不能给结果赋值。 ","date":"2020-02-11","objectID":"/2020/02/c-%E7%AC%94%E8%AE%B0/:6:0","tags":["c++"],"title":"C++笔记","uri":"/2020/02/c-%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"安装 sudo pacman -S fcitx5-git fcitx5-qt5-git kcm-fcitx5-git fcitx5-rime-git 配置 然后打开 fctix5 配置程序，添加中州*，就是 rime。 添加一下内容到~/.xprofile export GTK_IM_MODULE=fcitx5 export QT_IM_MODULE=fcitx5 export XMODIFIERS=@im=fcitx fctix5 不会自动启动，添加一下内容到~/.xprofile： fcitx5 \u0026 KDE 用户可以直接在系统设置模块-自动启动设置 双拼 or 五笔 在~/.local/share/fcitx5/rime/中 parse 下面 github 中的文件 https://github.com/jesse996/squirrel_config ","date":"2020-01-10","objectID":"/2020/01/%E8%AE%B0%E4%B8%80%E6%AC%A1fcitx5-rime%E5%AE%89%E8%A3%85/:0:0","tags":["Manjaro"],"title":"记一次fcitx5 Rime安装","uri":"/2020/01/%E8%AE%B0%E4%B8%80%E6%AC%A1fcitx5-rime%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"皮肤 修改皮肤：传送门 ","date":"2020-01-10","objectID":"/2020/01/%E8%AE%B0%E4%B8%80%E6%AC%A1fcitx5-rime%E5%AE%89%E8%A3%85/:0:1","tags":["Manjaro"],"title":"记一次fcitx5 Rime安装","uri":"/2020/01/%E8%AE%B0%E4%B8%80%E6%AC%A1fcitx5-rime%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"不是每个 trait 都可以作为 tarit 对象被使用，这和类型大小是否确认有关。每个 trait 都包含一个隐式的类型参数 Self，代表实现该 tarit 的实际类型。Self 默认有一个隐式的 tarit 限定?Sized，形如 Self:?Sized。?Sized trait 包含了所有的动态大小类型金额所有的可确定大小的类型。Rust 中大多数类型都是可确定的，就是\u003cT:Sized\u003e。 必须满足下面 2 条规则才可以当作 trait 对象使用： trait 的 Self 不能被限定为 Sized。 trait 中所有的方法都必须是对象安全的。 而对象安全的方法必须满足一下三点之一： 方法受 Self：Sized 约束 方法签名同时满足以下三点： （1）必须不包含任何泛型参数。 （2）第一个参数必须为 Self 类型或可以解引用为 Self 的类型 （3）Self 不能出现在第一个参数以外的地方，包括返回值 trait 中不能包含关联常量。 在实践中，只涉及到两条规则。如果一个 trait 中所有的方法有如下属性时，则该 trait 是对象安全的： 返回值类型不为 Self 方法没有任何泛型类型参数 每个文件定义一个模块。lib.rs 定义了一个和自己 crate 同名的模块；一个 mod.rs 定义了一个它所在文件夹名字的模块；其他的每个文件定义了一个同文件名的模块。 二进制 crate 的 root 必须是 main.rs，库 crate 的 root 必须是 lib.rs 单元测试通常和所测试的代码在同一个文件 集成测试，样例，benchmarks 都必须像其他用户一样导入 crate，只能用公开的 API。 ","date":"2019-12-30","objectID":"/2019/12/rust%E7%AC%94%E8%AE%B0/:0:0","tags":["Rust"],"title":"Rust笔记","uri":"/2019/12/rust%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"闭包 如果闭包中没有捕获任何环境变量，则默认自动实现 Fn 如果闭包中捕获了复制语义类型的环境变量，则 如果不需要修改环境变量，无论是否使用了 move，均会自动实现 Fn 如果需要修改环境变量，则自动实现 FnMut 如果闭包中捕获了移动语义类型的环境变量，则 如果不需要修改，且没有使用 move，则自动实现 FnOnce 如果不需要修改，且使用了 move，则自动实现 Fn 如果需要修改，则自动实现 FnMut 使用 move，如果捕获的变量是复制语义类型的，则闭包本身会自动实现 Copy/Clone,否则不会。 每个闭包表达式都是一个独立的类型，这会有一些不便，如不能把不同的闭包保存到一个数组中，但这可以通过把闭包当做 trait 对象来解决。把闭包放到 Box中就可以构建一个闭包的 trait 对象，然后就可以当做类型来使用， 三者关系： FnOnce-\u003e FnMut -\u003e Fn，即要实现 Fn，必须先实现前面 2 个。 rust 类型分为复制语义和移动语义，复制语义是指分配在栈上，所以复制的时候很简单，直接按位复制，不会出现内存不安全的情况。移动语义指分配在堆上，为了保证内存安全，才有了所有权系统，即一块内存只有有一个变量指向它。 对于复合类型来说，是复制还是移动，取决于其成员的类型，分为 2 种： 结构体，枚举体： 当成员全都是复制语义的时候，复合类型不会自动实现 Copy，要手动实现 Derive(Copy,Clone)，此时复合类型才是复制语义的。如果复合类型中的成员有移动语义的，则无法实现 Copy。 元组，数组，Option：类型会自动实现 Copy，如果元素均为复制语义，则元组就是复制，不需要手动再 Derive(Coyp,Clone)，否则元组就是移动语义的。 共享可变状态是万恶之源 每个 let 都会创建一个默认的词法作用域，这个作用域就是它的生命周期（lifetime），就是在这个词法作用域中存活，出了就死亡。 解引用会获得所有权。 显式生命周期参数是为了解决跨函数借用，编译器无法检查的问题。它只用于编译器的借用检查，来防止垂悬指针。 'b: 'a的意思是 b 的存活时间长于 a 结构体实例的生命周期应短于或等于任意一个成员的生命周期。 生命周期省略规则： 每个输入上对应一个不同的生命周期参数 如果只有一个输入，则输出生命周期等于这个输入的生命周期 如果有 self（\u0026self,\u0026mut self），则输出生命周期等于 self 的生命周期 trait 对象的生命周期默认以下规则： trait 对象的生命周期默认是’static 如果实现 trait 的类型包括\u0026‘a x 或\u0026‘a mut x，则默认生命周期就是’a 如果实现 trait 的类型包含多个类似 T：‘a 的从句，则生命周期需要明确指定 Cell 和 RefCell 的区别： Cell通过 set/get 来直接操作包裹的值，RefCell通过 borrow/borrow_mut。 Cell一般适合复制语义类型，即实现了 Copy，RefCell适合移动语义类型 Cell无运行时开销，不会再运行时 panic，RefCell 则有运行时开销，会 panic 写时复制 Cow Cow是一个枚举体智能指针，包括 2 个可选项： Borrowed：用于包裹引用 Woned：用于包裹所有者 cow 提供的功能是：以不可变的方式访问内容，在需要可变借用或所有权的时候再克隆一份数据。cow 要点： Cow实现了 Deref，所以可以直接调用 T 的不可变方法 在需要修改 T 时，可以使用 to_mut 方法获取可变借用。该方法会克隆，且仅克隆一次。如果 T 本身有所有权，则调用 to_mut 不会发生克隆 在需要修改 T 时，也可以用 into_owned 方法来获取一个拥有所有权的对象。如果 T 是借用类型，则会发生克隆，并创建新的有所有权的对象。如果 T 是所有权对象，则会将所有权转移到新的克隆对象。 Future Trait Future是 rust 异步的核心，代表一个将来会产生值的一个东东。调用poll方法可以让 future 朝着完成进行，如果完成了就返回 Pool::Ready(result)，否则返回Poll::Pending并加到事件循环队列中等待再次被wake方法调用。 Waker Waker 有一个 wake()方法，用来告诉执行器需要执行相关的任务，就会调用相关的 poll 方法。 Executor rust 的 future 都是懒执行的，就是说除非用主动推动完成才会完成，否则不会做任何事。一个推动 future 完成的方法是在 async 方法中用.await，但最外层的 future 如何完成呢？这就需要一个Future executor。 Executor 通过调用poll方法执行一系列最外层的 future。典型的，一旦一个 future 开始了，Executor 就会对之调用 poll 方法。当 future 暗示他们准备好了被调用 wake()更进一步，他们就会被放到队列中等待再次被 poll，不断重复直至完成。 先看看 Executor 的定义: struct Executor { ready_queue: Receiver\u003cArc\u003cTask\u003e\u003e } ","date":"2019-12-30","objectID":"/2019/12/rust%E7%AC%94%E8%AE%B0/:1:0","tags":["Rust"],"title":"Rust笔记","uri":"/2019/12/rust%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"简单的 HashMap 初始化 vec![('d',5),('c',1)].into_iter().collect::\u003cHashMap\u003cchar,i32\u003e\u003e(); fn main(){letsource=\"你好你是谁\";// first find the byte index, then find the corresponding character index // (code point index) // this goes through the source twice though :( letchar_index=source.find(\"你是\").map(|found_byte_index|{source.char_indices().position(|(byte_index,_)|byte_index==found_byte_index).unwrap()});dbg!(char_index);} ","date":"2019-12-30","objectID":"/2019/12/rust%E7%AC%94%E8%AE%B0/:2:0","tags":["Rust"],"title":"Rust笔记","uri":"/2019/12/rust%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"基础知识 汇编语言，有 3 类指令组成： 汇编指令：机器码的助记符，有对应的机器码。 伪指令：没有对应机器码，由编译器执行，计算机并不执行。 其他符号：如+、-、*、\\，由编译器识别，没有对应机器码。 核心是编译指令。每一种 cpu 都有自己的汇编指令集。 存储器就是内存，存储器被划分为多个存储单元，从 0 开始顺序编号，一个存储单元就是一个字节（Byte）。存储器中指令和数据没有任何区别，都是二进制信息。 cpu 有 3 类总线：地址总线、数据总线、控制总线。 一个 cpu 有 n 根地址总线，则可以寻找 2 的 n 次方个内存单元。 n 根数据总线一次能传输 n 位，即 n bit。 控制总线是一些不同控制线的集合，有多少根控制总线，就意味着 cpu 提供了对外部器件的多少种控制。 内存地址空间：对 cpu 来说，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受 cpu 寻址能力的限制。这个逻辑存储器即是所说的内存地址空间。 寄存器 一个典型的 cpu 由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。前一章说的总线，相对于 cpu 内部来说是外部总线。 不同 cpu，寄存器的个数、结构都不同。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"通用寄存器 8086cpu 所有寄存器都是 16 位。AX、BX、CX、DX 这 4 个寄存器通常用来存放一般性数据，被称为通用寄存器。都可分为类似 AH 和 AL，BH 和 BL… 由于 8086 有 20 位地址总线，但 8086 是 16 位的，即在内部一次性处理、传输、暂时存储的地址只有 16 位，所以 8086 采用在内部用 2 个 16 位地址合成的方法来形成一个 20 位的物理地址。 地址加法器采用 物理地址=段地址x16+偏移地址 来合成物理地址。（也即左移 4 位，也即 x10H）。本质就是基础地址+偏移地址=物理地址。 cpu 可以用不同的段地址和偏移地址形成同一个物理地址。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"段寄存器 段地址存放在段寄存器中，8086 有 4 个段寄存器：CS、DS、SS、ES CS 和 IP 是 8086 中两个最关键的寄存器，它们共同表示了 cpu 当前要读取指令的地址。CS 为代码段寄存器，IP 为指令指针寄存器。 问：cpu 根据什么将内存中的信息看做是指令？ 答：cpu 将 CS:IP 指向的内存单元中的内容看做是指令。 在 cpu 中，程序员能用指令读写的部件只有寄存器。8086 大部分寄存器的值，都可以用mov来修改，mov称为传送指令。但不能用来设置 CS、IP 的值。 若想修改 CS、IP，可以用jmp指令，形如jmp 段地址：偏移地址。 若仅想修改 IP 的内容，可用形如jmp 某一合法寄存器，如jmp ax，可修改 IP 为 ax 中的值。 mov 可以操作的有：寄存器和寄存器，立即数到寄存器，寄存器和段寄存器，寄存器和内存单元，段寄存器和内存单元 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:2","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"代码段 我们可以根据需要，将一组内存单元定义为一个段。我们可以将长度为 N（N\u003c=64KB，因是 16 位）的一组代码，存在一组地址连续、起始地址为 16 的倍数的内存单元中，从而定义了一个代码段。那么代码段是如何被执行呢？只要将 CS：IP 指向代码段中第一条指令的首地址。 debug 用法 1.查看、修改 cpu 中寄存器的内容：R 2.查看内存中的内容：D 3.修改内存中的内容：E（可以写入数据、命令，无区别） 4.将内存中的内容解释为机器指令和对应的汇编指令：U 5.执行 CS：IP 指向的内存单元的指令：T 6.以汇编指令的形式向内存中写入命令：A 7.G 命令可以直接让 IP 跳到指定位置，如g 0012,会使 IP 跳到 0012 的位置。 8.用 p 命令可以从循环中一次循环完。也可以用 g 命令，直接跳到指定位置。 （T 命令在执行修改寄存器 SS 的指令时，下一条指令也紧接着执行） 寄存器（内存访问） 字单元：存放一个字型数据（16 位）的内存单元，由两个地址连续的内存单元组成。高地址存高位字节，低地址存地位字节。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:3","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"DS 和[address] DS 通常用来存放要访问数据的段地址。 将 10000H 中的数据读到 al 中 : mov bx,1000H mov ds,bx mov al,[0] mov 指令中的[]说明操作对象是一个内存单元,[]中的 0 说明偏移地址是 0，段地址默认是 ds。8086cpu 不支持将数据直接送入段寄存器，而是要用一个寄存器中转，即mov ds,1000H是非法的。 add、sub对段寄存器都是非法的，即add ds,ax,add ds,1,add, ds,[1]都是非法的。 综上，段寄存器的相关操作有: mov 段寄存器，寄存器 mov 寄存器，段寄存器 mov 段寄存器，内存单元 mov 内存单元，段寄存器 即段寄存器可以用 mov 与寄存器和内存单元进行操作（不能与数据），不能用add、sub ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"栈 push入栈，pop 出栈，如push ax,pop ax， SS:SP用来指向栈顶元素。 如图，8086 入栈时，栈顶从高地址向低地址方向增长。因为任意时刻SS：SP指向栈顶，所以当栈为空时，SS：SP指向栈的最底部单元下面的单元。 pop 与 push 相反 8086 不保证我们对栈的操作不会过界，我们只能自己注意。 push 和 pop 操作形式有如下几种: push 寄存器/段寄存器/内存单元 pop 寄存器/段寄存器/内存单元 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"段 段是我们人为规定的。 数据段：段地址放在 DS 中，用 mov、add、sub 等访问内存单元的指令时，cpu 就将我们单一的数据段中的内容当成数据来看。 代码段：段地址放在 CS 中，段中第一条指令的偏移地址放在 IP 中，cpu 将执行指令。 栈段：段地址放在 SS 中，栈顶元素的偏移地址放在 SP 中，cpu 进行站操作如 push、pop 时将栈段当做栈空间操作。 一段内存可以既是代码段又是数据段，又是栈段，也可以都不是。这取决于 CS、IP、SS、SP、DS 的指向。 第一个程序 汇编语言源程序包含两种指令： 1.汇编指令：有对应机器码，可以被编译为机器指令，最终被 cpu 执行。 2.伪指令：没有对应机器码，不被 cpu 执行，由编译器来执行。 assume cs:abc abc segment mov ax,2 add ax,ax add ax,ax mov ax,4c00H int 21H abc ends end segment segment和 ends是一对成对使用的伪指令，是必须要用到的一对伪指令，用来定义一个段，使用格式为： 段名 segment .. 段名 ends 一个汇编程序由多个段组成，这些段用来存放代码、数据或当做栈空间。一个有意义的汇编程序必须要有一个代码段。 end end是会变程序结束的标记，不要搞混end和ends，ends是和segment成对使用的。 assume 这条伪指令含义是“假设”，它假设某一段寄存器和程序的某一个用segment...ends定义的段相关联。只要记住 assume 是将有特定用途的段和相关联的段寄存器关联起来即可。 比如，用cname segment... cname ends定义了一个名为cname的段，在程序开头，用assume cs:cname将cname段和cs联系起来。 程序返回需要使用以下 2 条语句： mov ax,4c00H int 21H ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"loop 作用是循环，cpu 执行 loop 的时候，进行 2 部操作： 1.（cx）=（cx）-1 2.判断 cx 中的值，不为 0 则转到标号处执行，否则向下执行 在汇编源程序中，数据不能以字母开头，所以要在前面加 0。如，9100h 可以直接写为9100h，而 A000h 则要写为0A000h 程序加载后，ds 中存放着程序所在内存的段地址，偏移地址是 0。这个内存区前 256 个字节存放着的是 PSP，DOS 用来和程序进行通信，所以程序的地址可以表示为DS+10H:0 and 是逻辑与命令，or 是逻辑或命令。 大小写转换：一个字母，无论是大小写，将它的第 5 位置 0，就变成大写，第 5 位置 1，就变成小写。 si 和 di 是 8086 中与 bx 功能相近的寄存器，si 和 di 不能分成 2 个 8 位寄存器。 一般来说，在需要暂存数据的时候，我们都应该使用栈。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"bx，si，di，bp 在 8086 中，只有这 4 个寄存器可以用在[...]中来进行内存单元的寻址。 在[...]中，这 4 个寄存器可以单独出现，或只能以 4 种组合出现： 1.bx 和 si 2.bx 和 di 3.bp 和 si 4.bp 和 di 只要在[...]中使用 bp，而指令中没有显性给出段地址，那么段地址就默认在ss中。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"数据在什么地方？ 1.立即数：在 CPU 的指令缓存器中，如：mov ax,1 2.寄存器：在寄存器中，如：mov ax,bx 3.段地址（SA）和偏移地址（EA），如：mov ax,[0]（段地址默认是ds），mov ax,[bp]（段地址默认是ss） ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"数据有多长？ 数据有 2 种尺寸：byte和word 1.通过寄存器名指明要处理的数据的尺寸。 如指明进行字操作： mov ax,1 mov ds:[0],ax 指明进行字节操作： mov al,1 mov ds:[0],al 2.在没有寄存器名的情况下，用操作符X ptr指明内存单元的长度，X 可以为word或byte。如： 用word ptr指明了指令访问的内存单元是一个字单元： mov word ptr ds:[0],1 inc word ptr [bx] 用byte ptr指明是一个字节单元： mov byte ptr ds:[0],1 inc byte ptr [bx] 3.有些指令默认了访问的是字单元还是字节单元，如，push [1000H]，push 只进行字操作。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"div div 是除指令，要注意一下问题： 除数：8 位和 16 位两种，在一个寄存器或内存单元中。 被除数：默认放在 AX 或 DX 和 AX 中，如果除数为 8 位，被除数位 16 位，默认放在 AX 中；如果除数为 16 位，被除数为 32 位，在 DX 和 AX 中存放，DX 存高 16 位，AX 存低 16 位。 结果：如果除数为 8 位，则 AL 存储除法操作的商，AH 存储除法操作的余数；如果除数为 16 位，则 AX 存放商，DX 存放余数。 格式： div 寄存器 div 内存单元 div byte ptr ds:[0] 含义：（al）=（ax）/（（ds）*16+0）的商 (ah）=（ax）/（（ds）*16+0）的余数 div word ptr es:[0] 含义：（ax）= [（dx）*10000H+（ax）] /（（es））*16+0）的商 （dx）= [（dx）*10000H+（ax）] /（（es））*16+0）的余数 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"伪指令 dd db：用来定义字节型数据 dw：用来定义字型数据 dd：用来定义双字（define double word）型数据 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"dup dup 是一个操作符，它是和 db，dw，dd 配合使用的。如： db 3 dup (0) 定义了 3 个字节，值都是 0，相当于db 0,0,0 使用格式： db 重复的次数 dup （重复的字节型数据） dw 重复的次数 dup （重复的字型数据） dd 重复的次数 dup （重复的双字型数据） 转移指令的原理 可以修改 IP，或同时修改 CS 和 IP 的指令统称为转移指令。转移指令就是可以控制 cpu 执行内存中某处代码的指令。 8086 的转移行为有以下几类： 只修改 IP，称为段内转移，如：jmp ax 同时修改 CS 和 IP，称为段间转移，如：jmp 1000:0 段内转移又分为短转移和近转移： 短转移 IP 的修改范围为-128~127 近转移 IP 的修改分为为-32768~32767 转移指令有以下几类： 无条件转移（如：jmp） 条件转移 循环转移（如：loop） 过程 中断 这些转移的前提条件可能不同，但原理都相同。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"offset 由编译器处理，功能是取得标号的偏移地址。 start: mov ax,offset start ;相当于 mov ax,0（0是start的偏移地址） s: mov ax,offset s ;相当于 mov ax,3（3是s的偏移地址） ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:10:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"jmp 指令 jmp 可以只修改 IP，也可以修改同时 CS 和 IP jmp 指令要给出两种信息： 1.转移的目的地址 2.转移的距离 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"依据位移进行转移的 jmp 指令 jmp short 标号（转到标号处），short 指明是段内短转移（8 位位移），所对应的机器码并不包含转移的目的地址，而是包含的转移的位移 cpu 在指令 jmp 指令的时候，并不需要知道转移的目标地址。 类似的，有jmp near ptr 标号，实现的是段内近转移（16 位位移）。 位移 = 标号处的地址 - jmp 指令后的第一个字节的地址。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:1","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"依据转移的目的地址进行转移的 jmp 指令 jmp far ptr 标号实现的是段间转移，又称远转移 功能：（cs）= 标号所在段地址，（ip）= 标号在段中的偏移地址 机器码中有转移的目的地址 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:2","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"转移地址在寄存器中的 jmp 指令 格式：jmp 16 位寄存器 功能：（ip）= （16 位寄存器） ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:3","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"转移地址在内存中的 jmp 指令 有两种： jmp word ptr 内存单元地址(段内地址) 功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。 如： mov ax,0123H mov [bx],ax jmp word ptr [bx] 执行后，（IP）= 0123H 2.jmp dword ptr 内存单元地址(段内地址) 功能：从内存单元地址处开始存放着两个字，高地址是转移的目的段地址，低地址是转移的目的偏移地址。 如： mov ax,0123H mov [bx],ax mov word ptr [bx+2],0 jmp dword ptr [bx] 执行后，（CS）= 0，（IP）= 0123H 注意：形如 jmp 2000:1000的转移指令，是在 Debug 中使用的汇编指令，汇编编译器并不认识，如在源程序中使用，将编译报错。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:4","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"jcxz 指令 为有条件转移指令，所有的有条件转移指令都是短转移，相应机器码都是包含的位移，而不是目的地址。 格式： jcxz 标号（如果（cx）=0，转移到标号处执行） 操作： 当（cx）=0时，（ip）=（ip）+8位位移 相当于 if (cx==0) jmp short 标号 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:12:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"loop 指令 为循环指令，所有的循环指令都是短转移。 格式： loop 标号（（cx）= （cx）-1），如果（cx）!= 0，转移到标号处执行 操作： 1.（cx）=（cx）-1 2.如果（cx）!= 0 ，（ip）=（ip）+8 位位移 相当于： cx--; if (cx!=0) jmp short 标号; call 和 ret 指令 call 和 ret 都是转移指令，都修改 IP，或同时修改 CS 和 IP。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:13:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"ret 和 retf ret 指令用栈中数据，修改 IP 的内容，从而实现近转移 retf 指令用栈中数据，修改 CS 和 IP 的内容，从而实现远转移 执行 ret 指令时，cpu 执行以下 2 部操作： ip=ss*10H+sp sp=sp+2 相当于pop ip 执行 retf 指令时，进行下面 4 部操作： ip=ss*10H+sp sp=sp+2 cs=ss*10H+sp sp=sp+2 相当于pop ip ;pop cs ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:13:1","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"call 指令 执行 call 指令时，进行 2 部操作： 将当前 ip 或 cs 和 ip 压栈 转移 call 不能实现短转移，除此之外，call 实现转移的方法和 jmp 相同: call 标号：将当前 ip 压栈后，转到标号处执行,相当于： push ip jmp near ptr 标号 call far ptr 标号：实现段间转移,相当于： push cs push ip jmp far ptr 标号 call 16位寄存器：相当于： push ip jmp 16位寄存器 call word ptr 内存单元地址,相当于： push ip jmp word ptr 内存单元地址 call dword ptr 内存单元地址,相当于： push cs push ip jmp dword ptr 内存单元地址 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:13:2","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"mul 指令 mul 是乘法指令，要注意以下两点： 两个相乘的数：要么都是 8 位，要么都是 16 位。如果是 8 位，一个放在 al，一个放在 8 位寄存器或内存字节单元中；若是 16 位，一个在 ax，一个在 16 位寄存器中。 结果：如果是 8 位乘法，结果默认放在 ax 中；如果是 16 位，结果高位放在 dx，低位放在 ax。 解决除法溢出的方法： X/N = int( H/N)*65536 + [rem( H/N )*65536 + L ] / N X:被除数，N：除数，H：高 16 位，L：低 16 位，int：取商，rem：取余数 标志寄存器 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:13:3","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"ZF 标志（zero flag） flag 第 6 位是 ZF，零标志位。它记录执行相关指令后，其结果是否为 0。为 0 则 zf=1，否则 zf=0。 注意：8086 中，有些指令是影响 flag 的，比如：add、sub、mul、div、inc、or、and 等，它们大多是运算指令（逻辑或算数运算）；有一些则对 flag 没影响，如：mov，push，pop 等，大多是传送指令。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:14:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"PF 标志（Parity flag） flag 第 2 位是 PF，奇偶标志位。看执行结果的所有 bit 位中 1 的个数是否是偶数。是偶数则 pf=1，否则 pf=0。 可以理解成 1 偶标志位。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:15:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"SF 标志位（Sign Flag） flag 第 7 位是 SF，符号标志位。记录相关指令执行后结果是否为负。如果为负，sf=1；否则 sf=0 注意：sg 是 cpu 默认将数据当成有符号运算结果的记录。如果我们将数据当做无符号时，sf 时没有意义的，虽然相关指令可能影响了它的值。是不是有符号运算取决于我们。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:16:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"CF 标志位（Carry Flag） flag 第 0 位是 CF 标志位。一般情况下，在进行无符号数运算时，它记录了运算结果的最高有效位向更高位的进位值，或借位值。 inc 和 loop 指令不影响 cf ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:17:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"OF 标志位（Overflow Flag） flag 第 11 位是 OF，溢出标志位。记录了有符号运算的结果是否溢出。有溢出 of=1，否则 of=0； 注意和 CF 的区别： cf 是对无符号数运算有意义的标志位 of 是对有符号数运算有意义的标志位 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:18:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"adc 指令 adc 是带进位加法指令，它利用了 CF 位上记录的进位值。(add +carry –\u003e adc)如： adc ax,bx实现的功能是ax=ax+bx+cf。 cpu 提供 adc 的目的，就是来进行加法的第二步运算的。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:19:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"sbb 指令 sbb 是带借位减法指令（sub borrow），利用 cf 记录的借位值。 sbb ax,bx实现的功能是ax=ax-bx-cf。 cpu 提供 dbb 的目的，就是来进行减法的第二步运算的。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:20:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"cmp 指令 cmp 是比较指令，相当于减法指令，只是不保留结果。cmp 会对 flag 产生影响。如： cmp ax,ax做ax-ax运算，但并不在 ax 中保存，仅影响 flag。 进行·cmp ax,bx·比较后，通过 flag 可以看出比较结果 zf=1:ax=bx cf=1:ax\u003cbx cf=0:ax\u003e=bx cf=0 且 zf=0:ax\u003ebx cf=1 或 zf=1:ax\u003c=bx 注意：单纯的看 sf 的值不能判断结果的正负，因为可能会发生溢出。 而通过 sf 和 of 的值可以判断。 sf=1，of=0：没发生溢出，实际结果负，则逻辑结果也为负 sf=0，of=0：同上，逻辑结果非负 sf=1，of=1：有溢出，则实际与逻辑相反，逻辑为正。 sf=0，of=1：实际结果非负，又 of=1，则结果非 0，所以实际为正，逻辑结果为负。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:21:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"条件转移指令 通常配合 cmp，由 cmp 先进行比较，改变了 flag 中的值，条件转移指令根据 flag 中的值执行。 下面根据无符号数的比较进行转移的有： | 指令 | 含义 | 条件 | | —- | ———— | ————– | | je | 等于则转移 | 由 zf=1 则转移 | | jne | 不等于则转移 | zf=0 | | jb | 低于则转移 | cf=1 | | jnb | 不低于则转移 | cf=0 | | ja | 高于则转移 | cf=0 且 zf=0 | | jna | 不高于则转移 | cf=1 或 zf=1 | ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:22:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"DF 标志和串传送指令 flag 第 10 位是 DF，方向寄存器。在串处理指令中，控制每次操作后 si、di 的增减 df=0：每次操作后 si、di 递增 df=1：每次操作后 si、di 递减 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:23:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"movsb 指令 格式：movsb 相当于： mov es:[di],byte ptr ds:[si];（8086不支持这样的命令，这里只是描述） if df = 0: inc si inc di elif df = 1: dec si dec di ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:23:1","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"movsw 类似上面，就是 si,di 每次加或减 2 movsb和movsw进行的是串传送的一个步骤，通常配合rep使用,如： rep movsb，相当于： s:movsb loop s 可见rep是根据 cx 的值，重复执行后面的串传送指令。 cld 指令：可以将 df 置 0 std 指令：可以将 df 置 1 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:23:2","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"pushf 和 poopf pushf 功能是将标志寄存器的值压栈，popf 是从栈中弹出数据给标志寄存器中。 通过 pushf 和 popf，可以直接访问 flag call 和 ret 指令 call 和 ret 都是转移指令，都修改 IP，或同时修改 CS 和 IP。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:24:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"ret 和 retf ret 指令用栈中数据，修改 IP 的内容，从而实现近转移 retf 指令用栈中数据，修改 CS 和 IP 的内容，从而实现远转移 执行 ret 指令时，cpu 执行以下 2 部操作： ip=ss*10H+sp sp=sp+2 相当于pop ip 执行 retf 指令时，进行下面 4 部操作： ip=ss*10H+sp sp=sp+2 cs=ss*10H+sp sp=sp+2 相当于pop ip ;pop cs ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:24:1","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"call 指令 执行 call 指令时，进行 2 部操作： 将当前 ip 或 cs 和 ip 压栈 转移 call 不能实现短转移，除此之外，call 实现转移的方法和 jmp 相同: call 标号：将当前 ip 压栈后，转到标号处执行,相当于： push ip jmp near ptr 标号 call far ptr 标号：实现段间转移,相当于： push cs push ip jmp far ptr 标号 call 16位寄存器：相当于： push ip jmp 16位寄存器 call word ptr 内存单元地址,相当于： push ip jmp word ptr 内存单元地址 call dword ptr 内存单元地址,相当于： push cs push ip jmp dword ptr 内存单元地址 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:24:2","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"mul 指令 mul 是乘法指令，要注意以下两点： 两个相乘的数：要么都是 8 位，要么都是 16 位。如果是 8 位，一个放在 al，一个放在 8 位寄存器或内存字节单元中；若是 16 位，一个在 ax，一个在 16 位寄存器中。 结果：如果是 8 位乘法，结果默认放在 ax 中；如果是 16 位，结果高位放在 dx，低位放在 ax。 解决除法溢出的方法： X/N = int( H/N)*65536 + [rem( H/N )*65536 + L ] / N X:被除数，N：除数，H：高 16 位，L：低 16 位，int：取商，rem：取余数 标志寄存器 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:24:3","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"ZF 标志（zero flag） flag 第 6 位是 ZF，零标志位。它记录执行相关指令后，其结果是否为 0。为 0 则 zf=1，否则 zf=0。 注意：8086 中，有些指令是影响 flag 的，比如：add、sub、mul、div、inc、or、and 等，它们大多是运算指令（逻辑或算数运算）；有一些则对 flag 没影响，如：mov，push，pop 等，大多是传送指令。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:25:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"PF 标志（Parity flag） flag 第 2 位是 PF，奇偶标志位。看执行结果的所有 bit 位中 1 的个数是否是偶数。是偶数则 pf=1，否则 pf=0。 可以理解成 1 偶标志位。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:26:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"SF 标志位（Sign Flag） flag 第 7 位是 SF，符号标志位。记录相关指令执行后结果是否为负。如果为负，sf=1；否则 sf=0 注意：sg 是 cpu 默认将数据当成有符号运算结果的记录。如果我们将数据当做无符号时，sf 时没有意义的，虽然相关指令可能影响了它的值。是不是有符号运算取决于我们。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:27:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"CF 标志位（Carry Flag） flag 第 0 位是 CF 标志位。一般情况下，在进行无符号数运算时，它记录了运算结果的最高有效位向更高位的进位值，或借位值。 inc 和 loop 指令不影响 cf ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:28:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"OF 标志位（Overflow Flag） flag 第 11 位是 OF，溢出标志位。记录了有符号运算的结果是否溢出。有溢出 of=1，否则 of=0； 注意和 CF 的区别： cf 是对无符号数运算有意义的标志位 of 是对有符号数运算有意义的标志位 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:29:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"adc 指令 adc 是带进位加法指令，它利用了 CF 位上记录的进位值。(add +carry –\u003e adc)如： adc ax,bx实现的功能是ax=ax+bx+cf。 cpu 提供 adc 的目的，就是来进行加法的第二步运算的。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:30:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"sbb 指令 sbb 是带借位减法指令（sub borrow），利用 cf 记录的借位值。 sbb ax,bx实现的功能是ax=ax-bx-cf。 cpu 提供 dbb 的目的，就是来进行减法的第二步运算的。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:31:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"cmp 指令 cmp 是比较指令，相当于减法指令，只是不保留结果。cmp 会对 flag 产生影响。如： cmp ax,ax做ax-ax运算，但并不在 ax 中保存，仅影响 flag。 进行·cmp ax,bx·比较后，通过 flag 可以看出比较结果 zf=1:ax=bx cf=1:ax\u003cbx cf=0:ax\u003e=bx cf=0 且 zf=0:ax\u003ebx cf=1 或 zf=1:ax\u003c=bx 注意：单纯的看 sf 的值不能判断结果的正负，因为可能会发生溢出。 而通过 sf 和 of 的值可以判断。 sf=1，of=0：没发生溢出，实际结果负，则逻辑结果也为负 sf=0，of=0：同上，逻辑结果非负 sf=1，of=1：有溢出，则实际与逻辑相反，逻辑为正。 sf=0，of=1：实际结果非负，又 of=1，则结果非 0，所以实际为正，逻辑结果为负。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:32:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"条件转移指令 通常配合 cmp，由 cmp 先进行比较，改变了 flag 中的值，条件转移指令根据 flag 中的值执行。 下面根据无符号数的比较进行转移的有： | 指令 | 含义 | 条件 | | —- | ———— | ————– | | je | 等于则转移 | 由 zf=1 则转移 | | jne | 不等于则转移 | zf=0 | | jb | 低于则转移 | cf=1 | | jnb | 不低于则转移 | cf=0 | | ja | 高于则转移 | cf=0 且 zf=0 | | jna | 不高于则转移 | cf=1 或 zf=1 | ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:33:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"DF 标志和串传送指令 flag 第 10 位是 DF，方向寄存器。在串处理指令中，控制每次操作后 si、di 的增减 df=0：每次操作后 si、di 递增 df=1：每次操作后 si、di 递减 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:34:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"movsb 指令 格式：movsb 相当于： mov es:[di],byte ptr ds:[si];（8086不支持这样的命令，这里只是描述） if df = 0: inc si inc di elif df = 1: dec si dec di ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:34:1","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"movsw 类似上面，就是 si,di 每次加或减 2 movsb和movsw进行的是串传送的一个步骤，通常配合rep使用,如： rep movsb，相当于： s:movsb loop s 可见rep是根据 cx 的值，重复执行后面的串传送指令。 cld 指令：可以将 df 置 0 std 指令：可以将 df 置 1 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:34:2","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"pushf 和 poopf pushf 功能是将标志寄存器的值压栈，popf 是从栈中弹出数据给标志寄存器中。 通过 pushf 和 popf，可以直接访问 flag ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:35:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"修改源 sudo pacman-mirrors -i -c China -m rank sudo pacman -Syu sudo pacman -S archlinux-keyring ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:1:0","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"设置 archlinuxcn 源。 修改 /etc/pacman.conf 最后增加 [archlinuxcn] SigLevel = Optional TrustedOnly Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:1:1","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"更新系统 sudo pacman -Syu ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:2:0","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"安装archlinuxcn-keyring: sudo pacman -S archlinuxcn-keyring sudo pacman -Syu ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:3:0","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"修改 Home 下的目录为英文： 修改目录映射文件名； gedit ~/.config/user-dirs.dirs 修改为以下内容： XDG_DESKTOP_DIR=\"$HOME/Desktop\" XDG_DOWNLOAD_DIR=\"$HOME/Downloads\" XDG_TEMPLATES_DIR=\"$HOME/Templates\" XDG_PUBLICSHARE_DIR=\"$HOME/Public\" XDG_DOCUMENTS_DIR=\"$HOME/Documents\" XDG_MUSIC_DIR=\"$HOME/Music\" XDG_PICTURES_DIR=\"$HOME/Pictures\" XDG_VIDEOS_DIR=\"$HOME/Videos\" 将 Home 目录下的中文目录名改为对应的中文名； cd ~ mv 公共 Public mv 模板 Templates mv 视频 Videos mv 图片 Pictures mv 文档 Documents mv 下载 Downloads mv 音乐 Music mv 桌面 Desktop 重启系统。 ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:4:0","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"安装 chrome sudo pacman -S google-chrome ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:5:0","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"安装和使用 oh-my-zsh ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:6:0","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"安装 oh-my-zsh 的配置 查看本地有哪几种 shell cat /etc/shells manjaro 默认已经安装了 zsh ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:6:1","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"安装 oh-my-zsh 的配置文件 #via curl sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" #或者 via wget sh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:6:2","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"替换 zsh 的配置文件为 oh-my-zsh cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:6:3","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"安装插件 安装 zsh-autosuggestions git clone https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/plugins/zsh-autosuggestions 安装 zsh-syntax-highlighting git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ~/.oh-my-zsh/plugins/zsh-syntax-highlighting 安装 zsh-nvm git clone https://github.com/lukechilds/zsh-nvm ~/.oh-my-zsh/custom/plugins/zsh-nvm 安装 autojump sudo pacman -S autojump 在~/.zshrc中找到 plugins=( git ) 在括号中 git 的下一行添加插件名称使其生效 plugins=( git zsh-syntax-highlighting zsh-autosuggestions autojump zsh-nvm ) ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:6:4","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"更改主题\u0026\u0026lazyload nvm gedit ~/.zshrc ZSH_THEME=\"agnoster\" export NVM_LAZY_LOAD=true 刷新配置，使之生效 source ~/.zshrc ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:6:5","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"油酸乳 下载 脚本文件 wget http://www.djangoz.com/ssr#//github.com/the0demiurge/CharlesScripts/blob/master/charles/bin/ssr ssr 是一个 shell 脚本 执行脚本 sudo mv ssr /usr/local/bin sudo chmod 766 /usr/local/bin/ssr ssr install ssr config 然后在系统设置里设置网络代理为手动 ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:6:6","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"开机自启动 在/usr/lib/systemd/system/中加入ssr.service [Unit] Description=AutoRunSSR [Service] Type=forking ExecStart=ssr start [Install] WantedBy=multi-user.target 然后输入命令 systemctl enable ssr.service systemctl start ssr.service 可以查看状态 systemctl status ssr.service ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:6:7","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"设置 chrome 为默认浏览器: 在设置中把 html 关联类型设置为用 chrome 打开 ","date":"2019-01-10","objectID":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/:6:8","tags":["Manjaro"],"title":"Manjaro安装后配置","uri":"/2019/01/manjaro%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"每元素都有一个外在盒子和容器盒子(内在盒子) 外在盒子负责元素是否一行显示 容器盒子负责元素的宽高、内容呈现 块级元素 外在盒子是 block 的元素 都有主块级盒子 list-item 还有一个附加盒子(IE 伪元素不支持附加盒子) ","date":"2018-08-11","objectID":"/2018/08/css%E7%AC%94%E8%AE%B0/:0:0","tags":["CSS"],"title":"CSS笔记","uri":"/2018/08/css%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"width : auto 充分利用可用空间，块级元素默认 100% 收缩与包裹。代表是浮动、绝对定位、inline-block、table 元素 收缩到最小 超出容器限制。内容很长的连续英文和数字，或者设置了 white-space:nowrap （除了第一个是外部尺寸，其余都是内部尺寸。分别对应以下的外部尺寸和内部尺寸） 外部尺寸 正常 width 是 100% 格式化宽度 出现在 position 为 absolute 和 fixed 元素中。 默认绝对定位元素宽度是由内部尺寸决定，除了当 left 和 right 或 top 和 bottom 同时出现时，其宽度相对于最近的具有定位特性的祖先元素计算 内部尺寸 包裹性 顾名思义，尺寸由内部元素决定，单永远小于包含块容器尺寸 首选最小宽度 当外部容器盒子宽度为 0，内部的内联盒子就是首选最小宽度 中文，为单个汉子宽度 西文遇到空格、-、?、其他非英文字符，就会换行 类似图片这样的替换元素，就是元素本身的宽度 最大宽度 等同于 包裹性 元素设置 white-sapce:nowrap 后的宽度 是最大的连续内联盒子的宽度 height 如何让元素支持 height:100% 效果？ 设置父元素高度 使用绝对定位 绝对定位的宽高百分比是相对于 padding box，其他是相对于 content box min-width/height 和 max-width/height min-width/min-height 初始值是 auto，max-* 是 none max-width 会覆盖width，即使是width:xpx !important min-width会覆盖max-width 内联元素 外在盒子是内联盒子的元素 ","date":"2018-08-11","objectID":"/2018/08/css%E7%AC%94%E8%AE%B0/:1:0","tags":["CSS"],"title":"CSS笔记","uri":"/2018/08/css%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"内联盒子模型 内容区域 围绕文字的盒子 内联盒子 是元素外在盒子 行框盒子 每一行就是一个行框盒子 包含盒子（包含块） 由一行一行的行框盒子组成，是父元素外面的盒子 ","date":"2018-08-11","objectID":"/2018/08/css%E7%AC%94%E8%AE%B0/:1:1","tags":["CSS"],"title":"CSS笔记","uri":"/2018/08/css%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"幽灵空白节点（strut） 内联元素的解析就像每个行框盒子前面都有一个空白节点，宽度为 0 ","date":"2018-08-11","objectID":"/2018/08/css%E7%AC%94%E8%AE%B0/:1:2","tags":["CSS"],"title":"CSS笔记","uri":"/2018/08/css%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"替换元素 内容可替换的元素，如： \u003cimg\u003e,\u003cobject\u003e,\u003cvideo\u003e,\u003ciframe\u003e,\u003cinput\u003e,\u003ctextarea\u003e,\u003cselect\u003e 有如下特性： 外观不受 css 影响 有自己的尺寸 很多 css 属性有自己的一套表现规则。如 vertical-align ，替换元素的baseline是元素的下边缘，非替换元素是x的下边缘 替换元素默认 dispay 值 都是inline或inline-block 主要记: \u003cimg\u003e是inline \u003cinput\u003e是inline-block_（火狐是 inline）_ \u003cinput\u003e和\u003cbutton\u003e区别： 前者white-space是 pre，后者是 normal white-space: normal (默认) 连续的空白符会被合并，换行符会被当作空白符来处理。填充 line 盒子时，必要的话会换行 nowrap 和 normal 一样，连续的空白符会被合并。但文本内的换行无效 pre 连续的空白符会被保留。在遇到换行符或者\u003cbr\u003e元素时才会换行。 pre-wrap 连续的空白符会被保留。在遇到换行符或者\u003cbr\u003e元素，或者需要为了填充 line 盒子时才会换行。 pre-line 连续的空白符会被合并。在遇到换行符或者\u003cbr\u003e元素，或者需要为了填充 line 盒子时会换行。 换行符 空格和 tap 文字转行 normal 空白符 合并 yes nowrap 空白符 合并 no pre 换行 保留 no pre-wrap 换行 保留 yes pre-line 换行 合并 yes ","date":"2018-08-11","objectID":"/2018/08/css%E7%AC%94%E8%AE%B0/:1:3","tags":["CSS"],"title":"CSS笔记","uri":"/2018/08/css%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"替换元素尺寸 固有尺寸 原本尺寸，无法改变 HTML 尺寸 通过 HTML 属性改变的尺寸，如： img的width,height input的size属性 textarea的cols和rows CSS 尺寸 通过 CSS 改变的尺寸 从下都上，优先级递减 Firefox 中没有src属性的img元素是inline元素 css 之所以可以改变图片的大小，是因为图片中的 comtent 默认的object-fit是fill ","date":"2018-08-11","objectID":"/2018/08/css%E7%AC%94%E8%AE%B0/:1:4","tags":["CSS"],"title":"CSS笔记","uri":"/2018/08/css%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"替换元素离非替换元素有多远？ 只隔了一个src Firefox 直接就行，Chrome 要有一个不为空的 alt 值 只隔了一个content属性 counter:url('...') ","date":"2018-08-11","objectID":"/2018/08/css%E7%AC%94%E8%AE%B0/:1:5","tags":["CSS"],"title":"CSS笔记","uri":"/2018/08/css%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"content 计数器 counter-reset 给计数器起名，和从那个数字开始计数 .xxx{ counter-reset:name 2} 名字就是 name ，从 2 开始，默认 0，数字不合符当 0 处理 可以多个计数器同时命名 .xxx{ counter-reset:name 2 name2 3} counter-increment key 为 counter-reset 的名字，值是每次增加的值，没有则默认 1，也可以有多个 key 用空格如同 counter-reset .counter { counter-reset: szx 2; counter-increment: szx 1; } .counter::before { content: counter(szx); } counter-increment 在父元素或子元素都有效 方法counter( ) / counters( ) counter(name[,style]) style 支持的值就是list-style-type支持的值，作用是增减可以是英文字母或罗马文 一个 content 可以有多个 content( )方法 counters(name,string[,style]) string 必须，表示子序号的链接字符,style 同上 reset 不要和 counter 同级 ","date":"2018-08-11","objectID":"/2018/08/css%E7%AC%94%E8%AE%B0/:2:0","tags":["CSS"],"title":"CSS笔记","uri":"/2018/08/css%E7%AC%94%E8%AE%B0/"}]