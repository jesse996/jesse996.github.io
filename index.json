[{"categories":["算法"],"content":"0-1 背包 有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 cost[i]， 价值是 value[i]。求解将哪些物品装入背包可使价值总和最大 //初始化 letv=2;//背包体积 letn=4;//物品个数,必须等于cost和value的长度 letcost=vec![1,2,3,4];//物品花费 letvalue=vec![1,3,5,7];//物品价值 letmutf=vec![0;v+1];// 0 \u003c= i \u003c n foriin0..n{zoro_one_pack(\u0026mutf,cost[i],value[i],v);}//最后价值总和最大的值就是f[v] fn zoro_one_pack(f: \u0026mutVec\u003cusize\u003e,cost: usize,value: usize,v: usize){forjin(cost..=v).rev(){f[j]=std::cmp::max(f[j],f[j-cost]+value);}} 注意： 如果题目要求 恰好装满背包 ,则除了f[0]设为 0，其余都设为 $-∞$，如果不要求恰好装满，则f全初始化为 0。 ","date":"2020-08-10","objectID":"/2020/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:0:0","tags":["算法","背包问题"],"title":"背包问题","uri":"/2020/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"一个常数优化 //伪代码 foriin0..n{forjin(cpm::max(cost[i],v-(cost[i]+..+cost[n-1]))..=v).rev(){f[j]=std::cmp::max(f[j],f[j-cost[i]]+value[i]);}} 完全背包 有 N 种物品和一个容量为V 的背包，每种物品都有无限件可用。放入第 i 种物品的费用是 cost[i]，价值是 value[i]。求解：将哪些物品装入背包，可使这些物品的耗费的费用总 和不超过背包容量，且价值总和最大 思路是转化成0-1 背包：将一种物品拆成多件只能选 0 件或 1 件的 01 背包中的物品。 //初始化 letv=2;//背包体积 letn=4;//物品个数,必须等于cost和value的长度 letcost=vec![1,2,3,4];//物品花费 letvalue=vec![1,3,5,7];//物品价值 letmutf=vec![0;v+1];// 0 \u003c= i \u003c n foriin0..n{zoro_one_pack(\u0026mutf,cost[i],value[i],v);}//最后价值总和最大的值就是f[v] fn complete_pack(f: \u0026mutVec\u003cusize\u003e,cost: usize,value: usize,v: usize){//就是将0-1背包中内层循环次序反转 forjincost..=v{f[j]=std::cmp::max(f[j],f[j-cost]+value);}} 多重背包 有 N 种物品和一个容量为 V 的背包。第 i 种物品最多有 M[i] 件可用，每件耗费的空间是 cost[i]，价值是 value[i]。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超 过背包容量，且价值总和最大 fn multiple_pack(f: \u0026mutVec\u003cusize\u003e,cost: usize,value: usize,v: usize,mutm: usize){ifcost*m\u003e=v{complete_pack(f,cost,value,v);return;}letmutk=1;whilek\u003cm{zoro_one_pack(f,k*cost,k*value,v);m-=k;k*=2;}zoro_one_pack(f,m*cost,m*value,v)} ","date":"2020-08-10","objectID":"/2020/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:0:1","tags":["算法","背包问题"],"title":"背包问题","uri":"/2020/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"可行性问题 当问题是“每种有若干件的物品能否填满给定容量的背包”，只须考虑填满背包的可行性，不需考虑每件物品的价值时，多重背包问题同样有 O(VN) 复杂度的算法 fn multiple_pack_ok(){//也可以用硬币模型来理解。v代表硬币的总价值，n代表硬币的种类， //m是每个硬币的数量，cost代表每种硬币的价值 letv=2;letn=4;letcost=vec![5,4,9,3];letm=vec![2,1,4,6];letmutf=vec![-1;v+1];f[0]=0;foriin0..n{forjin0..=v{iff[j]\u003e=0{f[j]=m[i];}//else { // f[j] = -1; 应为默认初始化就是-1 //} }ifv\u003ccost[i]{break;}forjin0..=(v-cost[i]){iff[j]\u003e=0{f[j+cost[i]]=std::cmp::max(f[j+cost[i]],f[j]-1);}}}} f[i][j]表示使用前i个物品，填充容量为j的背包，第i个物品最多能够剩余多少个，如果无法填充容量为j的背包，则值为-1 首先，f[i - 1][j] 代表前 i - 1 件物品凑面值 j，如果其值大于等于 0 即状态合法可以凑出j，就说明接下来不需要第i种硬币就能凑出j，所以剩余的硬币数就是m[i]了。 如果f[i - 1][j]小于0，说明前i-1种凑不出来j。加上第i个硬币可能面值太大，也可能正好，所以先取 -1待定。 f[i][j + cost[i]] = std::cmp::max(f[i][j + cost[i]], f[i][j] - 1); 如果能凑成j+cost[i],那么就把硬币数量-1，如果不行，就维持-1的状态。 然后把二维数组改为一位数组。 混合背包 就是上面三种背包混合在一起 //伪代码： foriin0..n{ifi是01背包{zero_one_pack(..);}elseifi是完全背包{complete_pack(..);}elseifi是多重背包{multiple_pack(..);}} 男人八题之多重背包问题 二维背包 对于每件物品，具有两种不同的费用，选择这件物品必须同时付出这两种费用。对于每种费用都有一个可付出的最大值（背包容量）。问怎样 选择物品可以得到最大的价值。 设第 i 件物品所需的两种费用分别为 Ci 和 Di。两种费用可付出的最大值（也即两种背包容量）分别为 V 和 U。物品的价值为 Wi 状态转移方程如下： F[i, v, u] = max{F[i − 1, v, u], F[i − 1, v − Ci, u − Di] +Wi} 有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取 U 件物品。 这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为 1，可以 付出的最大件数费用为 U 分组背包 有 N 件物品和一个容量为 V 的背包。第 i 件物品的费用是 Ci，价值是 Wi。这些物品被划分为 K 组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包 可使这些物品的费用总和不超过背包容量，且价值总和最大 设 F[k, v] 表示前 k 组物品花费费用 v 能取得的最大权值，则有： F[k, v] = max{F[k − 1, v], F[k − 1, v − Ci] + Wi | item i ∈ group k} fn group_pack(f: \u0026mutVec\u003cusize\u003e,v: usize,cost: \u0026Vec\u003cusize\u003e,value: \u0026Vec\u003cusize\u003e){letgroup=cost.len();forjin(0..=v).rev(){forkin0..group{ifj\u003ccost[k]{break;}f[j]=cmp::max(f[j],f[j-cost[k]]+value[k]);}}}fn test_group(){letv=4;letn=3;letcost=vec![vec![1,2],vec![3,4],vec![5,6]];//三组 letvalue=vec![vec![3,2],vec![1,5],vec![2,4]];// letmutf=vec![0;v+1];foriin0..n{group_pack(\u0026mutf,v,\u0026cost[i],\u0026value[i]);}dbg!(\u0026f[v]);} 有依赖的背包问题 也就是说，物品 i 依赖于物品 j，表示若选物品 i，则必须选物品 j。 可以对主件 k 的“附件集合”先进行一次 01 背包，得到费用依次为 0. . .V − Ck 所有这些值时相应的最 大价值 Fk[0 . . . V − Ck]。那么，这个主件及它的附件集合相当于 V − Ck + 1 个物品的 物品组，其中费用为 v 的物品的价值为 Fk[v −Ck] +Wk，v 的取值范围是 Ck ≤ v ≤ V。 也就是说，原来指数级的策略中，有很多策略都是冗余的，通过一次 01 背包后，将主件 k 及其附件转化为 V −Ck + 1 个物品的物品组，就可以直接应用分组背包的算法解决问题了 背包问题总结（下） 1 /* 2 即物品间存在依赖，比如i依赖于j，表示若选物品i，则必须选物品j 3 http://acm.hdu.edu.cn/showproblem.php?pid=3449 4 有很多个箱子，想买箱子中的物品必须先买下箱子，典型的依赖背包 5 将不依赖其他物品的物品称为主件，依赖其他物品的物品称为附件 6 我们有n个箱子，箱子里面的物品个数为cnt[i] 7 那么箱子称为主件，箱子里面的物品称为附件 8 那么考虑一个主件和它附件的集合，那么有2^n+1种策略，每种策略都是互斥的。所以它是分组背包问题。 9 但是不能像一般的分组背包那样处理，因为组内有2^n+1种。 10 但是考虑到费用相同时，只选择价值最大的。所以可以对组内的附件进行01背包，得到费用依次为v-c[i]...0的最大价值 11 dp2[v-c[i]...0] 12 13 */ 14 #include \u003cstdio.h\u003e 15 #include \u003cstring.h\u003e 16 int dp[100000+10],dp2[100000+10]; 17 int box[55],cnt[55],price[55][11],value[55][11]; 18 inline int max(const int \u0026a, const int \u0026b) 19 { 20 return a \u003c b ? b : a; 21 } 22 int main() 23 { 24 int n,v,i,j,k; 25 while(scanf(\"%d%d\",\u0026n,\u0026v)!=EOF) 26 { 27 memset(dp,0,sizeof(dp)); 28 for(i=1; i\u003c=n; ++i) 29 { 30 scanf(\"%d%d\",\u0026box[i],\u0026cnt[i]); 31 memcpy(dp2,dp,sizeof(dp)); 32 for(j=1; j\u003c=cnt[i]; ++j) 33 { 34 scanf(\"%d%d\",\u0026price[i][j],\u0026value[i][j]); 35 for(k=v-box[i]; k\u003e=price[i][j]; --k)//附件进行01背包，每个dp2[k]对于组内的一种策略 36 dp2[k] = max(dp2[k],dp2[k-price[i][j]]+value[i][j]); 37 } 38 for(k=box[i];k\u003c=v; ++k) 39 dp[k] = max(dp[k],dp2[k-box[i]]);//当容量为k时，取第i组的物品时得到的最大值和不取比较哪个大 40 } 41 printf(\"%d\\n\",dp[v]); 42 } 43 return 0; 44 } ","date":"2020-08-10","objectID":"/2020/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:0:2","tags":["算法","背包问题"],"title":"背包问题","uri":"/2020/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["汇编"],"content":"基础知识 汇编语言，有 3 类指令组成： 汇编指令：机器码的助记符，有对应的机器码。 伪指令：没有对应机器码，由编译器执行，计算机并不执行。 其他符号：如+、-、*、\\，由编译器识别，没有对应机器码。 核心是编译指令。每一种 cpu 都有自己的汇编指令集。 存储器就是内存，存储器被划分为多个存储单元，从 0 开始顺序编号，一个存储单元就是一个字节（Byte）。存储器中指令和数据没有任何区别，都是二进制信息。 cpu 有 3 类总线：地址总线、数据总线、控制总线。 一个 cpu 有 n 根地址总线，则可以寻找 2 的 n 次方个内存单元。 n 根数据总线一次能传输 n 位，即 n bit。 控制总线是一些不同控制线的集合，有多少根控制总线，就意味着 cpu 提供了对外部器件的多少种控制。 内存地址空间：对 cpu 来说，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受 cpu 寻址能力的限制。这个逻辑存储器即是所说的内存地址空间。 寄存器 一个典型的 cpu 由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。前一章说的总线，相对于 cpu 内部来说是外部总线。 不同 cpu，寄存器的个数、结构都不同。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"通用寄存器 8086cpu 所有寄存器都是 16 位。AX、BX、CX、DX 这 4 个寄存器通常用来存放一般性数据，被称为通用寄存器。都可分为类似 AH 和 AL，BH 和 BL… 由于 8086 有 20 位地址总线，但 8086 是 16 位的，即在内部一次性处理、传输、暂时存储的地址只有 16 位，所以 8086 采用在内部用 2 个 16 位地址合成的方法来形成一个 20 位的物理地址。 地址加法器采用 物理地址=段地址x16+偏移地址 来合成物理地址。（也即左移 4 位，也即 x10H）。本质就是基础地址+偏移地址=物理地址。 cpu 可以用不同的段地址和偏移地址形成同一个物理地址。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"段寄存器 段地址存放在段寄存器中，8086 有 4 个段寄存器：CS、DS、SS、ES CS 和 IP 是 8086 中两个最关键的寄存器，它们共同表示了 cpu 当前要读取指令的地址。CS 为代码段寄存器，IP 为指令指针寄存器。 问：cpu 根据什么将内存中的信息看做是指令？ 答：cpu 将 CS:IP 指向的内存单元中的内容看做是指令。 在 cpu 中，程序员能用指令读写的部件只有寄存器。8086 大部分寄存器的值，都可以用mov来修改，mov称为传送指令。但不能用来设置 CS、IP 的值。 若想修改 CS、IP，可以用jmp指令，形如jmp 段地址：偏移地址。 若仅想修改 IP 的内容，可用形如jmp 某一合法寄存器，如jmp ax，可修改 IP 为 ax 中的值。 mov 可以操作的有：寄存器和寄存器，立即数到寄存器，寄存器和段寄存器，寄存器和内存单元，段寄存器和内存单元 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:2","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"代码段 我们可以根据需要，将一组内存单元定义为一个段。我们可以将长度为 N（N\u003c=64KB，因是 16 位）的一组代码，存在一组地址连续、起始地址为 16 的倍数的内存单元中，从而定义了一个代码段。那么代码段是如何被执行呢？只要将 CS：IP 指向代码段中第一条指令的首地址。 debug 用法 1.查看、修改 cpu 中寄存器的内容：R 2.查看内存中的内容：D 3.修改内存中的内容：E（可以写入数据、命令，无区别） 4.将内存中的内容解释为机器指令和对应的汇编指令：U 5.执行 CS：IP 指向的内存单元的指令：T 6.以汇编指令的形式向内存中写入命令：A 7.G 命令可以直接让 IP 跳到指定位置，如g 0012,会使 IP 跳到 0012 的位置。 8.用 p 命令可以从循环中一次循环完。也可以用 g 命令，直接跳到指定位置。 （T 命令在执行修改寄存器 SS 的指令时，下一条指令也紧接着执行） 寄存器（内存访问） 字单元：存放一个字型数据（16 位）的内存单元，由两个地址连续的内存单元组成。高地址存高位字节，低地址存地位字节。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:3","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"DS 和[address] DS 通常用来存放要访问数据的段地址。 将 10000H 中的数据读到 al 中 : mov bx,1000H mov ds,bx mov al,[0] mov 指令中的[]说明操作对象是一个内存单元,[]中的 0 说明偏移地址是 0，段地址默认是 ds。8086cpu 不支持将数据直接送入段寄存器，而是要用一个寄存器中转，即mov ds,1000H是非法的。 add、sub对段寄存器都是非法的，即add ds,ax,add ds,1,add, ds,[1]都是非法的。 综上，段寄存器的相关操作有: mov 段寄存器，寄存器 mov 寄存器，段寄存器 mov 段寄存器，内存单元 mov 内存单元，段寄存器 即段寄存器可以用 mov 与寄存器和内存单元进行操作（不能与数据），不能用add、sub ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"栈 push入栈，pop 出栈，如push ax,pop ax， SS:SP用来指向栈顶元素。 如图，8086 入栈时，栈顶从高地址向低地址方向增长。因为任意时刻SS：SP指向栈顶，所以当栈为空时，SS：SP指向栈的最底部单元下面的单元。 pop 与 push 相反 8086 不保证我们对栈的操作不会过界，我们只能自己注意。 push 和 pop 操作形式有如下几种: push 寄存器/段寄存器/内存单元 pop 寄存器/段寄存器/内存单元 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"段 段是我们人为规定的。 数据段：段地址放在 DS 中，用 mov、add、sub 等访问内存单元的指令时，cpu 就将我们单一的数据段中的内容当成数据来看。 代码段：段地址放在 CS 中，段中第一条指令的偏移地址放在 IP 中，cpu 将执行指令。 栈段：段地址放在 SS 中，栈顶元素的偏移地址放在 SP 中，cpu 进行站操作如 push、pop 时将栈段当做栈空间操作。 一段内存可以既是代码段又是数据段，又是栈段，也可以都不是。这取决于 CS、IP、SS、SP、DS 的指向。 第一个程序 汇编语言源程序包含两种指令： 1.汇编指令：有对应机器码，可以被编译为机器指令，最终被 cpu 执行。 2.伪指令：没有对应机器码，不被 cpu 执行，由编译器来执行。 assume cs:abc abc segment mov ax,2 add ax,ax add ax,ax mov ax,4c00H int 21H abc ends end segment segment和 ends是一对成对使用的伪指令，是必须要用到的一对伪指令，用来定义一个段，使用格式为： 段名 segment .. 段名 ends 一个汇编程序由多个段组成，这些段用来存放代码、数据或当做栈空间。一个有意义的汇编程序必须要有一个代码段。 end end是会变程序结束的标记，不要搞混end和ends，ends是和segment成对使用的。 assume 这条伪指令含义是“假设”，它假设某一段寄存器和程序的某一个用segment...ends定义的段相关联。只要记住 assume 是将有特定用途的段和相关联的段寄存器关联起来即可。 比如，用cname segment... cname ends定义了一个名为cname的段，在程序开头，用assume cs:cname将cname段和cs联系起来。 程序返回需要使用以下 2 条语句： mov ax,4c00H int 21H ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"loop 作用是循环，cpu 执行 loop 的时候，进行 2 部操作： 1.（cx）=（cx）-1 2.判断 cx 中的值，不为 0 则转到标号处执行，否则向下执行 在汇编源程序中，数据不能以字母开头，所以要在前面加 0。如，9100h 可以直接写为9100h，而 A000h 则要写为0A000h 程序加载后，ds 中存放着程序所在内存的段地址，偏移地址是 0。这个内存区前 256 个字节存放着的是 PSP，DOS 用来和程序进行通信，所以程序的地址可以表示为DS+10H:0 and 是逻辑与命令，or 是逻辑或命令。 大小写转换：一个字母，无论是大小写，将它的第 5 位置 0，就变成大写，第 5 位置 1，就变成小写。 si 和 di 是 8086 中与 bx 功能相近的寄存器，si 和 di 不能分成 2 个 8 位寄存器。 一般来说，在需要暂存数据的时候，我们都应该使用栈。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"bx，si，di，bp 在 8086 中，只有这 4 个寄存器可以用在[...]中来进行内存单元的寻址。 在[...]中，这 4 个寄存器可以单独出现，或只能以 4 种组合出现： 1.bx 和 si 2.bx 和 di 3.bp 和 si 4.bp 和 di 只要在[...]中使用 bp，而指令中没有显性给出段地址，那么段地址就默认在ss中。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"数据在什么地方？ 1.立即数：在 CPU 的指令缓存器中，如：mov ax,1 2.寄存器：在寄存器中，如：mov ax,bx 3.段地址（SA）和偏移地址（EA），如：mov ax,[0]（段地址默认是ds），mov ax,[bp]（段地址默认是ss） ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"数据有多长？ 数据有 2 种尺寸：byte和word 1.通过寄存器名指明要处理的数据的尺寸。 如指明进行字操作： mov ax,1 mov ds:[0],ax 指明进行字节操作： mov al,1 mov ds:[0],al 2.在没有寄存器名的情况下，用操作符X ptr指明内存单元的长度，X 可以为word或byte。如： 用word ptr指明了指令访问的内存单元是一个字单元： mov word ptr ds:[0],1 inc word ptr [bx] 用byte ptr指明是一个字节单元： mov byte ptr ds:[0],1 inc byte ptr [bx] 3.有些指令默认了访问的是字单元还是字节单元，如，push [1000H]，push 只进行字操作。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"div div 是除指令，要注意一下问题： 除数：8 位和 16 位两种，在一个寄存器或内存单元中。 被除数：默认放在 AX 或 DX 和 AX 中，如果除数为 8 位，被除数位 16 位，默认放在 AX 中；如果除数为 16 位，被除数为 32 位，在 DX 和 AX 中存放，DX 存高 16 位，AX 存低 16 位。 结果：如果除数为 8 位，则 AL 存储除法操作的商，AH 存储除法操作的余数；如果除数为 16 位，则 AX 存放商，DX 存放余数。 格式： div 寄存器 div 内存单元 div byte ptr ds:[0] 含义：（al）=（ax）/（（ds）*16+0）的商 (ah）=（ax）/（（ds）*16+0）的余数 div word ptr es:[0] 含义：（ax）= [（dx）*10000H+（ax）] /（（es））*16+0）的商 （dx）= [（dx）*10000H+（ax）] /（（es））*16+0）的余数 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"伪指令 dd db：用来定义字节型数据 dw：用来定义字型数据 dd：用来定义双字（define double word）型数据 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"dup dup 是一个操作符，它是和 db，dw，dd 配合使用的。如： db 3 dup (0) 定义了 3 个字节，值都是 0，相当于db 0,0,0 使用格式： db 重复的次数 dup （重复的字节型数据） dw 重复的次数 dup （重复的字型数据） dd 重复的次数 dup （重复的双字型数据） 转移指令的原理 可以修改 IP，或同时修改 CS 和 IP 的指令统称为转移指令。转移指令就是可以控制 cpu 执行内存中某处代码的指令。 8086 的转移行为有以下几类： 只修改 IP，称为段内转移，如：jmp ax 同时修改 CS 和 IP，称为段间转移，如：jmp 1000:0 段内转移又分为短转移和近转移： 短转移 IP 的修改范围为-128~127 近转移 IP 的修改分为为-32768~32767 转移指令有以下几类： 无条件转移（如：jmp） 条件转移 循环转移（如：loop） 过程 中断 这些转移的前提条件可能不同，但原理都相同。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"offset 由编译器处理，功能是取得标号的偏移地址。 start: mov ax,offset start ;相当于 mov ax,0（0是start的偏移地址） s: mov ax,offset s ;相当于 mov ax,3（3是s的偏移地址） ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:10:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"jmp 指令 jmp 可以只修改 IP，也可以修改同时 CS 和 IP jmp 指令要给出两种信息： 1.转移的目的地址 2.转移的距离 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"依据位移进行转移的 jmp 指令 jmp short 标号（转到标号处），short 指明是段内短转移（8 位位移），所对应的机器码并不包含转移的目的地址，而是包含的转移的位移 cpu 在指令 jmp 指令的时候，并不需要知道转移的目标地址。 类似的，有jmp near ptr 标号，实现的是段内近转移（16 位位移）。 位移 = 标号处的地址 - jmp 指令后的第一个字节的地址。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:1","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"依据转移的目的地址进行转移的 jmp 指令 jmp far ptr 标号实现的是段间转移，又称远转移 功能：（cs）= 标号所在段地址，（ip）= 标号在段中的偏移地址 机器码中有转移的目的地址 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:2","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"转移地址在寄存器中的 jmp 指令 格式：jmp 16 位寄存器 功能：（ip）= （16 位寄存器） ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:3","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"转移地址在内存中的 jmp 指令 有两种： jmp word ptr 内存单元地址(段内地址) 功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。 如： mov ax,0123H mov [bx],ax jmp word ptr [bx] 执行后，（IP）= 0123H 2.jmp dword ptr 内存单元地址(段内地址) 功能：从内存单元地址处开始存放着两个字，高地址是转移的目的段地址，低地址是转移的目的偏移地址。 如： mov ax,0123H mov [bx],ax mov word ptr [bx+2],0 jmp dword ptr [bx] 执行后，（CS）= 0，（IP）= 0123H 注意：形如 jmp 2000:1000的转移指令，是在 Debug 中使用的汇编指令，汇编编译器并不认识，如在源程序中使用，将编译报错。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:4","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"jcxz 指令 为有条件转移指令，所有的有条件转移指令都是短转移，相应机器码都是包含的位移，而不是目的地址。 格式： jcxz 标号（如果（cx）=0，转移到标号处执行） 操作： 当（cx）=0时，（ip）=（ip）+8位位移 相当于 if (cx==0) jmp short 标号 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:12:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"loop 指令 为循环指令，所有的循环指令都是短转移。 格式： loop 标号（（cx）= （cx）-1），如果（cx）!= 0，转移到标号处执行 操作： 1.（cx）=（cx）-1 2.如果（cx）!= 0 ，（ip）=（ip）+8 位位移 相当于： cx--; if (cx!=0) jmp short 标号; call 和 ret 指令 call 和 ret 都是转移指令，都修改 IP，或同时修改 CS 和 IP。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:13:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"ret 和 retf ret 指令用栈中数据，修改 IP 的内容，从而实现近转移 retf 指令用栈中数据，修改 CS 和 IP 的内容，从而实现远转移 执行 ret 指令时，cpu 执行以下 2 部操作： ip=ss*10H+sp sp=sp+2 相当于pop ip 执行 retf 指令时，进行下面 4 部操作： ip=ss*10H+sp sp=sp+2 cs=ss*10H+sp sp=sp+2 相当于pop ip ;pop cs ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:13:1","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"call 指令 执行 call 指令时，进行 2 部操作： 将当前 ip 或 cs 和 ip 压栈 转移 call 不能实现短转移，除此之外，call 实现转移的方法和 jmp 相同: call 标号：将当前 ip 压栈后，转到标号处执行,相当于： push ip jmp near ptr 标号 call far ptr 标号：实现段间转移,相当于： push cs push ip jmp far ptr 标号 call 16位寄存器：相当于： push ip jmp 16位寄存器 call word ptr 内存单元地址,相当于： push ip jmp word ptr 内存单元地址 call dword ptr 内存单元地址,相当于： push cs push ip jmp dword ptr 内存单元地址 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:13:2","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"mul 指令 mul 是乘法指令，要注意以下两点： 两个相乘的数：要么都是 8 位，要么都是 16 位。如果是 8 位，一个放在 al，一个放在 8 位寄存器或内存字节单元中；若是 16 位，一个在 ax，一个在 16 位寄存器中。 结果：如果是 8 位乘法，结果默认放在 ax 中；如果是 16 位，结果高位放在 dx，低位放在 ax。 解决除法溢出的方法： X/N = int( H/N)*65536 + [rem( H/N )*65536 + L ] / N X:被除数，N：除数，H：高 16 位，L：低 16 位，int：取商，rem：取余数 标志寄存器 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:13:3","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"ZF 标志（zero flag） flag 第 6 位是 ZF，零标志位。它记录执行相关指令后，其结果是否为 0。为 0 则 zf=1，否则 zf=0。 注意：8086 中，有些指令是影响 flag 的，比如：add、sub、mul、div、inc、or、and 等，它们大多是运算指令（逻辑或算数运算）；有一些则对 flag 没影响，如：mov，push，pop 等，大多是传送指令。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:14:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"PF 标志（Parity flag） flag 第 2 位是 PF，奇偶标志位。看执行结果的所有 bit 位中 1 的个数是否是偶数。是偶数则 pf=1，否则 pf=0。 可以理解成 1 偶标志位。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:15:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"SF 标志位（Sign Flag） flag 第 7 位是 SF，符号标志位。记录相关指令执行后结果是否为负。如果为负，sf=1；否则 sf=0 注意：sg 是 cpu 默认将数据当成有符号运算结果的记录。如果我们将数据当做无符号时，sf 时没有意义的，虽然相关指令可能影响了它的值。是不是有符号运算取决于我们。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:16:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"CF 标志位（Carry Flag） flag 第 0 位是 CF 标志位。一般情况下，在进行无符号数运算时，它记录了运算结果的最高有效位向更高位的进位值，或借位值。 inc 和 loop 指令不影响 cf ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:17:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"OF 标志位（Overflow Flag） flag 第 11 位是 OF，溢出标志位。记录了有符号运算的结果是否溢出。有溢出 of=1，否则 of=0； 注意和 CF 的区别： cf 是对无符号数运算有意义的标志位 of 是对有符号数运算有意义的标志位 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:18:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"adc 指令 adc 是带进位加法指令，它利用了 CF 位上记录的进位值。(add +carry –\u003e adc)如： adc ax,bx实现的功能是ax=ax+bx+cf。 cpu 提供 adc 的目的，就是来进行加法的第二步运算的。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:19:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"sbb 指令 sbb 是带借位减法指令（sub borrow），利用 cf 记录的借位值。 sbb ax,bx实现的功能是ax=ax-bx-cf。 cpu 提供 dbb 的目的，就是来进行减法的第二步运算的。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:20:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"cmp 指令 cmp 是比较指令，相当于减法指令，只是不保留结果。cmp 会对 flag 产生影响。如： cmp ax,ax做ax-ax运算，但并不在 ax 中保存，仅影响 flag。 进行·cmp ax,bx·比较后，通过 flag 可以看出比较结果 zf=1:ax=bx cf=1:ax\u003cbx cf=0:ax\u003e=bx cf=0 且 zf=0:ax\u003ebx cf=1 或 zf=1:ax\u003c=bx 注意：单纯的看 sf 的值不能判断结果的正负，因为可能会发生溢出。 而通过 sf 和 of 的值可以判断。 sf=1，of=0：没发生溢出，实际结果负，则逻辑结果也为负 sf=0，of=0：同上，逻辑结果非负 sf=1，of=1：有溢出，则实际与逻辑相反，逻辑为正。 sf=0，of=1：实际结果非负，又 of=1，则结果非 0，所以实际为正，逻辑结果为负。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:21:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"条件转移指令 通常配合 cmp，由 cmp 先进行比较，改变了 flag 中的值，条件转移指令根据 flag 中的值执行。 下面根据无符号数的比较进行转移的有： | 指令 | 含义 | 条件 | | —- | ———— | ————– | | je | 等于则转移 | 由 zf=1 则转移 | | jne | 不等于则转移 | zf=0 | | jb | 低于则转移 | cf=1 | | jnb | 不低于则转移 | cf=0 | | ja | 高于则转移 | cf=0 且 zf=0 | | jna | 不高于则转移 | cf=1 或 zf=1 | ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:22:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"DF 标志和串传送指令 flag 第 10 位是 DF，方向寄存器。在串处理指令中，控制每次操作后 si、di 的增减 df=0：每次操作后 si、di 递增 df=1：每次操作后 si、di 递减 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:23:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"movsb 指令 格式：movsb 相当于： mov es:[di],byte ptr ds:[si];（8086不支持这样的命令，这里只是描述） if df = 0: inc si inc di elif df = 1: dec si dec di ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:23:1","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"movsw 类似上面，就是 si,di 每次加或减 2 movsb和movsw进行的是串传送的一个步骤，通常配合rep使用,如： rep movsb，相当于： s:movsb loop s 可见rep是根据 cx 的值，重复执行后面的串传送指令。 cld 指令：可以将 df 置 0 std 指令：可以将 df 置 1 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:23:2","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"pushf 和 poopf pushf 功能是将标志寄存器的值压栈，popf 是从栈中弹出数据给标志寄存器中。 通过 pushf 和 popf，可以直接访问 flag call 和 ret 指令 call 和 ret 都是转移指令，都修改 IP，或同时修改 CS 和 IP。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:24:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"ret 和 retf ret 指令用栈中数据，修改 IP 的内容，从而实现近转移 retf 指令用栈中数据，修改 CS 和 IP 的内容，从而实现远转移 执行 ret 指令时，cpu 执行以下 2 部操作： ip=ss*10H+sp sp=sp+2 相当于pop ip 执行 retf 指令时，进行下面 4 部操作： ip=ss*10H+sp sp=sp+2 cs=ss*10H+sp sp=sp+2 相当于pop ip ;pop cs ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:24:1","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"call 指令 执行 call 指令时，进行 2 部操作： 将当前 ip 或 cs 和 ip 压栈 转移 call 不能实现短转移，除此之外，call 实现转移的方法和 jmp 相同: call 标号：将当前 ip 压栈后，转到标号处执行,相当于： push ip jmp near ptr 标号 call far ptr 标号：实现段间转移,相当于： push cs push ip jmp far ptr 标号 call 16位寄存器：相当于： push ip jmp 16位寄存器 call word ptr 内存单元地址,相当于： push ip jmp word ptr 内存单元地址 call dword ptr 内存单元地址,相当于： push cs push ip jmp dword ptr 内存单元地址 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:24:2","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"mul 指令 mul 是乘法指令，要注意以下两点： 两个相乘的数：要么都是 8 位，要么都是 16 位。如果是 8 位，一个放在 al，一个放在 8 位寄存器或内存字节单元中；若是 16 位，一个在 ax，一个在 16 位寄存器中。 结果：如果是 8 位乘法，结果默认放在 ax 中；如果是 16 位，结果高位放在 dx，低位放在 ax。 解决除法溢出的方法： X/N = int( H/N)*65536 + [rem( H/N )*65536 + L ] / N X:被除数，N：除数，H：高 16 位，L：低 16 位，int：取商，rem：取余数 标志寄存器 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:24:3","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"ZF 标志（zero flag） flag 第 6 位是 ZF，零标志位。它记录执行相关指令后，其结果是否为 0。为 0 则 zf=1，否则 zf=0。 注意：8086 中，有些指令是影响 flag 的，比如：add、sub、mul、div、inc、or、and 等，它们大多是运算指令（逻辑或算数运算）；有一些则对 flag 没影响，如：mov，push，pop 等，大多是传送指令。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:25:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"PF 标志（Parity flag） flag 第 2 位是 PF，奇偶标志位。看执行结果的所有 bit 位中 1 的个数是否是偶数。是偶数则 pf=1，否则 pf=0。 可以理解成 1 偶标志位。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:26:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"SF 标志位（Sign Flag） flag 第 7 位是 SF，符号标志位。记录相关指令执行后结果是否为负。如果为负，sf=1；否则 sf=0 注意：sg 是 cpu 默认将数据当成有符号运算结果的记录。如果我们将数据当做无符号时，sf 时没有意义的，虽然相关指令可能影响了它的值。是不是有符号运算取决于我们。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:27:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"CF 标志位（Carry Flag） flag 第 0 位是 CF 标志位。一般情况下，在进行无符号数运算时，它记录了运算结果的最高有效位向更高位的进位值，或借位值。 inc 和 loop 指令不影响 cf ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:28:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"OF 标志位（Overflow Flag） flag 第 11 位是 OF，溢出标志位。记录了有符号运算的结果是否溢出。有溢出 of=1，否则 of=0； 注意和 CF 的区别： cf 是对无符号数运算有意义的标志位 of 是对有符号数运算有意义的标志位 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:29:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"adc 指令 adc 是带进位加法指令，它利用了 CF 位上记录的进位值。(add +carry –\u003e adc)如： adc ax,bx实现的功能是ax=ax+bx+cf。 cpu 提供 adc 的目的，就是来进行加法的第二步运算的。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:30:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"sbb 指令 sbb 是带借位减法指令（sub borrow），利用 cf 记录的借位值。 sbb ax,bx实现的功能是ax=ax-bx-cf。 cpu 提供 dbb 的目的，就是来进行减法的第二步运算的。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:31:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"cmp 指令 cmp 是比较指令，相当于减法指令，只是不保留结果。cmp 会对 flag 产生影响。如： cmp ax,ax做ax-ax运算，但并不在 ax 中保存，仅影响 flag。 进行·cmp ax,bx·比较后，通过 flag 可以看出比较结果 zf=1:ax=bx cf=1:ax\u003cbx cf=0:ax\u003e=bx cf=0 且 zf=0:ax\u003ebx cf=1 或 zf=1:ax\u003c=bx 注意：单纯的看 sf 的值不能判断结果的正负，因为可能会发生溢出。 而通过 sf 和 of 的值可以判断。 sf=1，of=0：没发生溢出，实际结果负，则逻辑结果也为负 sf=0，of=0：同上，逻辑结果非负 sf=1，of=1：有溢出，则实际与逻辑相反，逻辑为正。 sf=0，of=1：实际结果非负，又 of=1，则结果非 0，所以实际为正，逻辑结果为负。 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:32:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"条件转移指令 通常配合 cmp，由 cmp 先进行比较，改变了 flag 中的值，条件转移指令根据 flag 中的值执行。 下面根据无符号数的比较进行转移的有： | 指令 | 含义 | 条件 | | —- | ———— | ————– | | je | 等于则转移 | 由 zf=1 则转移 | | jne | 不等于则转移 | zf=0 | | jb | 低于则转移 | cf=1 | | jnb | 不低于则转移 | cf=0 | | ja | 高于则转移 | cf=0 且 zf=0 | | jna | 不高于则转移 | cf=1 或 zf=1 | ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:33:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"DF 标志和串传送指令 flag 第 10 位是 DF，方向寄存器。在串处理指令中，控制每次操作后 si、di 的增减 df=0：每次操作后 si、di 递增 df=1：每次操作后 si、di 递减 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:34:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"movsb 指令 格式：movsb 相当于： mov es:[di],byte ptr ds:[si];（8086不支持这样的命令，这里只是描述） if df = 0: inc si inc di elif df = 1: dec si dec di ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:34:1","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"movsw 类似上面，就是 si,di 每次加或减 2 movsb和movsw进行的是串传送的一个步骤，通常配合rep使用,如： rep movsb，相当于： s:movsb loop s 可见rep是根据 cx 的值，重复执行后面的串传送指令。 cld 指令：可以将 df 置 0 std 指令：可以将 df 置 1 ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:34:2","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["汇编"],"content":"pushf 和 poopf pushf 功能是将标志寄存器的值压栈，popf 是从栈中弹出数据给标志寄存器中。 通过 pushf 和 popf，可以直接访问 flag ","date":"2019-12-25","objectID":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:35:0","tags":["汇编"],"title":"汇编学习笔记","uri":"/2019/12/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]