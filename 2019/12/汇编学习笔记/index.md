# 汇编学习笔记


# 基础知识

汇编语言，有 3 类指令组成：

1. 汇编指令：机器码的助记符，有对应的机器码。
2. 伪指令：没有对应机器码，由编译器执行，计算机并不执行。
3. 其他符号：如+、-、\*、\，由编译器识别，没有对应机器码。

核心是编译指令。每一种 cpu 都有自己的汇编指令集。

存储器就是内存，存储器被划分为多个存储单元，从 0 开始顺序编号，一个存储单元就是一个字节（Byte）。存储器中指令和数据没有任何区别，都是二进制信息。

cpu 有 3 类总线：地址总线、数据总线、控制总线。

一个 cpu 有 n 根地址总线，则可以寻找 2 的 n 次方个内存单元。  
n 根数据总线一次能传输 n 位，即 n bit。

控制总线是一些不同控制线的集合，有多少根控制总线，就意味着 cpu 提供了对外部器件的多少种控制。

内存地址空间：对 cpu 来说，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受 cpu 寻址能力的限制。这个逻辑存储器即是所说的内存地址空间。

# 寄存器

一个典型的 cpu 由`运算器、控制器、寄存器`等器件构成，这些器件靠*内部总线*相连。前一章说的总线，相对于 cpu 内部来说是外部总线。

不同 cpu，寄存器的个数、结构都不同。

### 通用寄存器

8086cpu 所有寄存器都是 16 位。AX、BX、CX、DX 这 4 个寄存器通常用来存放一般性数据，被称为通用寄存器。都可分为类似 AH 和 AL，BH 和 BL...

由于 8086 有 20 位地址总线，但 8086 是 16 位的，即在内部一次性处理、传输、暂时存储的地址只有 16 位，所以 8086 采用在内部用 2 个 16 位地址合成的方法来形成一个 20 位的物理地址。

地址加法器采用 `物理地址=段地址x16+偏移地址` 来合成物理地址。（也即左移 4 位，也即 x10H）。本质就是`基础地址+偏移地址=物理地址`。

cpu 可以用不同的段地址和偏移地址形成同一个物理地址。

### 段寄存器

段地址存放在段寄存器中，8086 有 4 个段寄存器：CS、DS、SS、ES

CS 和 IP 是 8086 中两个最关键的寄存器，它们共同表示了 cpu 当前要读取指令的地址。CS 为代码段寄存器，IP 为指令指针寄存器。

问：cpu 根据什么将内存中的信息看做是指令？  
答：cpu 将 CS:IP 指向的内存单元中的内容看做是指令。

在 cpu 中，程序员能用指令读写的部件只有寄存器。8086 大部分寄存器的值，都可以用`mov`来修改，`mov`称为传送指令。但不能用来设置 CS、IP 的值。
若想修改 CS、IP，可以用`jmp`指令，形如`jmp 段地址：偏移地址`。  
若仅想修改 IP 的内容，可用形如`jmp 某一合法寄存器`，如`jmp ax`，可修改 IP 为 ax 中的值。
mov 可以操作的有：寄存器和寄存器，立即数到寄存器，寄存器和段寄存器，寄存器和内存单元，段寄存器和内存单元

### 代码段

我们可以根据需要，将一组内存单元定义为一个段。我们可以将长度为 N（N<=64KB，因是 16 位）的一组代码，存在一组地址连续、起始地址为 16 的倍数的内存单元中，从而定义了一个代码段。那么代码段是如何被执行呢？只要将 CS：IP 指向代码段中第一条指令的首地址。

# debug 用法

1.查看、修改 cpu 中寄存器的内容：R  
2.查看内存中的内容：D  
3.修改内存中的内容：E（可以写入数据、命令，无区别）  
4.将内存中的内容解释为机器指令和对应的汇编指令：U  
5.执行 CS：IP 指向的内存单元的指令：T  
6.以汇编指令的形式向内存中写入命令：A
7.G 命令可以直接让 IP 跳到指定位置，如`g 0012`,会使 IP 跳到 0012 的位置。 8.用 p 命令可以从循环中一次循环完。也可以用 g 命令，直接跳到指定位置。

（T 命令在执行修改寄存器 SS 的指令时，下一条指令也紧接着执行）

# 寄存器（内存访问）

**字单元**：存放一个字型数据（16 位）的内存单元，由两个地址连续的内存单元组成。高地址存高位字节，低地址存地位字节。

## DS 和[address]

DS 通常用来存放要访问数据的段地址。

将 10000H 中的数据读到 al 中 :

```
mov bx,1000H
mov ds,bx
mov al,[0]
```

mov 指令中的`[]`说明操作对象是一个内存单元,`[]`中的 `0` 说明偏移地址是 0，段地址默认是 `ds`。8086cpu 不支持将数据直接送入段寄存器，而是要用一个寄存器中转，即`mov ds,1000H`是非法的。

`add`、`sub`对段寄存器都是非法的，即`add ds,ax`,`add ds,1`,`add, ds,[1]`都是非法的。

综上，段寄存器的相关操作有:

> mov 段寄存器，寄存器  
> mov 寄存器，段寄存器  
> mov 段寄存器，内存单元  
> mov 内存单元，段寄存器

即段寄存器可以用 mov 与寄存器和内存单元进行操作（不能与数据），不能用`add`、`sub`

## 栈

`push`入栈，`pop` 出栈，如`push ax`,`pop ax`，  
`SS:SP`用来指向栈顶元素。
![入栈过程](https://upload-images.jianshu.io/upload_images/3378977-0b1a242fd61a2b76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
如图，8086 入栈时，栈顶从高地址向低地址方向增长。因为任意时刻`SS：SP`指向栈顶，所以当栈为空时，`SS：SP`指向栈的最底部单元下面的单元。

pop 与 push 相反
![出栈过程](https://upload-images.jianshu.io/upload_images/3378977-3327c4d48a4dc5a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

8086 不保证我们对栈的操作不会过界，我们只能自己注意。
push 和 pop 操作形式有如下几种:

> push 寄存器/段寄存器/内存单元
> pop 寄存器/段寄存器/内存单元

## 段

段是我们人为规定的。

-   数据段：段地址放在 DS 中，用 mov、add、sub 等访问内存单元的指令时，cpu 就将我们单一的数据段中的内容当成数据来看。
-   代码段：段地址放在 CS 中，段中第一条指令的偏移地址放在 IP 中，cpu 将执行指令。
-   栈段：段地址放在 SS 中，栈顶元素的偏移地址放在 SP 中，cpu 进行站操作如 push、pop 时将栈段当做栈空间操作。

一段内存可以既是代码段又是数据段，又是栈段，也可以都不是。这取决于 CS、IP、SS、SP、DS 的指向。

# 第一个程序

汇编语言源程序包含两种指令： 1.汇编指令：有对应机器码，可以被编译为机器指令，最终被 cpu 执行。 2.伪指令：没有对应机器码，不被 cpu 执行，由编译器来执行。

```asm
assume cs:abc
abc segment
    mov ax,2
    add ax,ax
    add ax,ax
    mov ax,4c00H
    int 21H
abc ends
end
```

#### segment

`segment`和 `ends`是一对成对使用的伪指令，是必须要用到的一对伪指令，用来定义一个段，使用格式为：

```
段名 segment
..
段名 ends
```

一个汇编程序由多个段组成，这些段用来存放代码、数据或当做栈空间。一个有意义的汇编程序必须要有一个代码段。

#### end

`end`是会变程序结束的标记，不要搞混`end`和`ends`，`ends`是和`segment`成对使用的。

#### assume

这条伪指令含义是“假设”，它假设某一段寄存器和程序的某一个用`segment...ends`定义的段相关联。只要记住 assume 是将有特定用途的段和相关联的段寄存器关联起来即可。
比如，用`cname segment... cname ends`定义了一个名为`cname`的段，在程序开头，用`assume cs:cname`将`cname`段和`cs`联系起来。

程序返回需要使用以下 2 条语句：

```
mov ax,4c00H
int 21H
```

### loop

作用是循环，cpu 执行 loop 的时候，进行 2 部操作： 1.（cx）=（cx）-1 2.判断 cx 中的值，不为 0 则转到标号处执行，否则向下执行

在汇编源程序中，数据不能以字母开头，所以要在前面加 0。如，9100h 可以直接写为`9100h`，而 A000h 则要写为`0A000h`
程序加载后，ds 中存放着程序所在内存的段地址，偏移地址是 0。这个内存区前 256 个字节存放着的是 PSP，DOS 用来和程序进行通信，所以程序的地址可以表示为`DS+10H:0`

and 是逻辑与命令，or 是逻辑或命令。

大小写转换：一个字母，无论是大小写，将它的第 5 位置 0，就变成大写，第 5 位置 1，就变成小写。

si 和 di 是 8086 中与 bx 功能相近的寄存器，si 和 di 不能分成 2 个 8 位寄存器。

一般来说，在需要暂存数据的时候，我们都应该使用栈。

## bx，si，di，bp

-   在 8086 中，**只有**这 4 个寄存器可以用在`[...]`中来进行内存单元的寻址。
-   在`[...]`中，这 4 个寄存器可以单独出现，或只能以 4 种组合出现：
    1.bx 和 si
    2.bx 和 di
    3.bp 和 si
    4.bp 和 di
-   只要在`[...]`中使用 bp，而指令中没有显性给出段地址，那么段地址就默认在`ss`中。

## 数据在什么地方？

1.立即数：在 CPU 的指令缓存器中，如：`mov ax,1` 2.寄存器：在寄存器中，如：`mov ax,bx` 3.段地址（SA）和偏移地址（EA），如：`mov ax,[0]`（段地址默认是**ds**），`mov ax,[bp]`（段地址默认是**ss**）

## 数据有多长？

数据有 2 种尺寸：**byte**和**word** 1.通过寄存器名指明要处理的数据的尺寸。
如指明进行字操作：
`mov ax,1`
`mov ds:[0],ax`
指明进行字节操作：
`mov al,1`
`mov ds:[0],al` 2.在没有寄存器名的情况下，用操作符`X ptr`指明内存单元的长度，X 可以为`word`或`byte`。如：
用`word ptr`指明了指令访问的内存单元是一个字单元：
`mov word ptr ds:[0],1`
`inc word ptr [bx]`
用`byte ptr`指明是一个字节单元：
`mov byte ptr ds:[0],1`
`inc byte ptr [bx]` 3.有些指令默认了访问的是字单元还是字节单元，如，`push [1000H]`，push 只进行字操作。

## div

div 是除指令，要注意一下问题：

1. 除数：8 位和 16 位两种，在一个寄存器或内存单元中。
2. 被除数：默认放在 AX 或 DX 和 AX 中，如果除数为 8 位，被除数位 16 位，默认放在 AX 中；如果除数为 16 位，被除数为 32 位，在 DX 和 AX 中存放，DX 存高 16 位，AX 存低 16 位。
3. 结果：如果除数为 8 位，则 AL 存储除法操作的商，AH 存储除法操作的余数；如果除数为 16 位，则 AX 存放商，DX 存放余数。
   格式：

```
div 寄存器
div 内存单元
```

> `div byte ptr ds:[0]`
> 含义：（al）=（ax）/（（ds）\*16+0）的商
> (ah）=（ax）/（（ds）\*16+0）的余数

> `div word ptr es:[0]`
> 含义：（ax）= [（dx）\*10000H+（ax）] /（（es））\*16+0）的商
> （dx）= [（dx）\*10000H+（ax）] /（（es））\*16+0）的余数

## 伪指令 dd

-   db：用来定义字节型数据
-   dw：用来定义字型数据
-   dd：用来定义双字（define double word）型数据

## dup

dup 是一个操作符，它是和 db，dw，dd 配合使用的。如：

> `db 3 dup (0)`
> 定义了 3 个字节，值都是 0，相当于`db 0,0,0`

使用格式：

> db 重复的次数 dup （重复的字节型数据）
> dw 重复的次数 dup （重复的字型数据）
> dd 重复的次数 dup （重复的双字型数据）

# 转移指令的原理

**可以修改 IP，或同时修改 CS 和 IP 的指令统称为转移指令**。转移指令就是可以控制 cpu 执行内存中某处代码的指令。

8086 的转移行为有以下几类：

-   只修改 IP，称为段内转移，如：`jmp ax`
-   同时修改 CS 和 IP，称为段间转移，如：`jmp 1000:0`

段内转移又分为短转移和近转移：

-   短转移 IP 的修改范围为-128~127
-   近转移 IP 的修改分为为-32768~32767

转移指令有以下几类：

-   无条件转移（如：jmp）
-   条件转移
-   循环转移（如：loop）
-   过程
-   中断

这些转移的前提条件可能不同，但原理都相同。

## offset

由编译器处理，功能是取得标号的偏移地址。

```
 start: mov ax,offset start    ;相当于 mov ax,0（0是start的偏移地址）
     s: mov ax,offset s        ;相当于 mov ax,3（3是s的偏移地址）
```

## jmp 指令

jmp 可以只修改 IP，也可以修改同时 CS 和 IP
jmp 指令要给出两种信息： 1.转移的目的地址 2.转移的距离

### 依据位移进行转移的 jmp 指令

`jmp short 标号`（转到标号处），short 指明是段内短转移（8 位位移），所对应的机器码并不包含转移的目的地址，而是包含的转移的位移
cpu 在指令 jmp 指令的时候，并不需要知道转移的目标地址。
类似的，有`jmp near ptr 标号`，实现的是段内近转移（16 位位移）。
位移 = 标号处的地址 - jmp 指令**后**的第一个字节的地址。

### 依据转移的目的地址进行转移的 jmp 指令

`jmp far ptr 标号`实现的是段间转移，又称远转移
功能：（cs）= 标号所在段地址，（ip）= 标号在段中的偏移地址
机器码中有转移的目的地址

### 转移地址在寄存器中的 jmp 指令

格式：jmp 16 位寄存器
功能：（ip）= （16 位寄存器）

### 转移地址在内存中的 jmp 指令

有两种：

1. `jmp word ptr 内存单元地址(段内地址)`
   功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。
   如：

```
mov ax,0123H
mov [bx],ax
jmp word ptr [bx]
```

执行后，（IP）= 0123H 2.`jmp dword ptr 内存单元地址(段内地址)`
功能：从内存单元地址处开始存放着两个字，高地址是转移的目的段地址，低地址是转移的目的偏移地址。
如：

```
mov ax,0123H
mov [bx],ax
mov word ptr [bx+2],0
jmp dword ptr [bx]
```

执行后，（CS）= 0，（IP）= 0123H

> 注意：形如 `jmp 2000:1000`的转移指令，是在 Debug 中使用的汇编指令，汇编编译器并不认识，如在源程序中使用，将编译报错。

## jcxz 指令

为有条件转移指令，所有的有条件转移指令都是短转移，相应机器码都是包含的位移，而不是目的地址。
格式：
`jcxz 标号（如果（cx）=0，转移到标号处执行）`
操作：
`当（cx）=0时，（ip）=（ip）+8位位移`
相当于

```
if (cx==0)
  jmp short 标号
```

## loop 指令

为循环指令，所有的循环指令都是短转移。
格式：
`loop 标号（（cx）= （cx）-1），如果（cx）!= 0，转移到标号处执行`
操作： 1.（cx）=（cx）-1 2.如果（cx）!= 0 ，（ip）=（ip）+8 位位移
相当于：

```
cx--;
if (cx!=0)
  jmp short 标号;
```

# call 和 ret 指令

call 和 ret 都是转移指令，都修改 IP，或同时修改 CS 和 IP。

### ret 和 retf

-   ret 指令用栈中数据，修改 IP 的内容，从而实现近转移
-   retf 指令用栈中数据，修改 CS 和 IP 的内容，从而实现远转移

执行 ret 指令时，cpu 执行以下 2 部操作：

1. ip=ss\*10H+sp
2. sp=sp+2

_相当于`pop ip`_

执行 retf 指令时，进行下面 4 部操作：

1. ip=ss\*10H+sp
2. sp=sp+2
3. cs=ss\*10H+sp
4. sp=sp+2

_相当于`pop ip ;pop cs`_

### call 指令

执行 call 指令时，进行 2 部操作：

1. 将当前 ip 或 cs 和 ip 压栈
2. 转移

call 不能实现短转移，除此之外，call 实现转移的方法和 jmp 相同:

-   `call 标号`：将当前 ip 压栈后，转到标号处执行,相当于：

```
push ip
jmp near ptr 标号
```

-   `call far ptr 标号`：实现段间转移,相当于：

```
push cs
push ip
jmp far ptr 标号
```

-   `call 16位寄存器`：相当于：

```
push ip
jmp 16位寄存器
```

-   `call word ptr 内存单元地址`,相当于：

```
push ip
jmp word ptr 内存单元地址
```

-   `call dword ptr 内存单元地址`,相当于：

```
push cs
push ip
jmp dword ptr 内存单元地址
```

### mul 指令

mul 是乘法指令，要注意以下两点：

1. 两个相乘的数：要么都是 8 位，要么都是 16 位。如果是 8 位，一个放在 al，一个放在 8 位寄存器或内存字节单元中；若是 16 位，一个在 ax，一个在 16 位寄存器中。
2. 结果：如果是 8 位乘法，结果默认放在 ax 中；如果是 16 位，结果高位放在 dx，低位放在 ax。

解决除法溢出的方法：

> X/N = int( H/N)*65536 + [rem( H/N )*65536 + L ] / N
> X:被除数，N：除数，H：高 16 位，L：低 16 位，int：取商，rem：取余数

# 标志寄存器

## ZF 标志（zero flag）

flag 第 6 位是 ZF，零标志位。它记录执行相关指令后，其结果是否为 0。为 0 则 zf=1，否则 zf=0。
注意：8086 中，有些指令是影响 flag 的，比如：add、sub、mul、div、inc、or、and 等，它们大多是运算指令（逻辑或算数运算）；有一些则对 flag 没影响，如：mov，push，pop 等，大多是传送指令。

## PF 标志（Parity flag）

flag 第 2 位是 PF，奇偶标志位。看执行结果的所有 bit 位中 1 的个数是否是偶数。是偶数则 pf=1，否则 pf=0。
可以理解成 1 偶标志位。

## SF 标志位（Sign Flag）

flag 第 7 位是 SF，符号标志位。记录相关指令执行后结果是否为负。如果为负，sf=1；否则 sf=0
注意：sg 是 cpu 默认将数据当成**有符号**运算结果的记录。如果我们将数据当做无符号时，sf 时没有意义的，虽然相关指令可能影响了它的值。是不是有符号运算取决于我们。

## CF 标志位（Carry Flag）

flag 第 0 位是 CF 标志位。一般情况下，在进行**无符号数**运算时，它记录了运算结果的最高有效位向更高位的进位值，或借位值。
inc 和 loop 指令不影响 cf

## OF 标志位（Overflow Flag）

flag 第 11 位是 OF，溢出标志位。记录了**有符号**运算的结果是否溢出。有溢出 of=1，否则 of=0；

> 注意和 CF 的区别：
> cf 是对**无**符号数运算有意义的标志位
> of 是对**有**符号数运算有意义的标志位

## adc 指令

adc 是带进位加法指令，它利用了 CF 位上记录的进位值。(add +carry --> adc)如：
`adc ax,bx`实现的功能是`ax=ax+bx+cf`。
cpu 提供 adc 的目的，就是来进行加法的第二步运算的。

## sbb 指令

sbb 是带借位减法指令（sub borrow），利用 cf 记录的借位值。
`sbb ax,bx`实现的功能是`ax=ax-bx-cf`。
cpu 提供 dbb 的目的，就是来进行减法的第二步运算的。

## cmp 指令

cmp 是比较指令，相当于减法指令，只是不保留结果。cmp 会对 flag 产生影响。如：
`cmp ax,ax`做`ax-ax`运算，但并不在 ax 中保存，仅影响 flag。
进行·cmp ax,bx·比较后，通过 flag 可以看出比较结果

-   zf=1:ax=bx
-   cf=1:ax<bx
-   cf=0:ax>=bx
-   cf=0 且 zf=0:ax>bx
-   cf=1 或 zf=1:ax<=bx

注意：单纯的看 sf 的值不能判断结果的正负，因为可能会发生溢出。
而通过 sf 和 of 的值可以判断。

1. sf=1，of=0：没发生溢出，实际结果负，则逻辑结果也为负
2. sf=0，of=0：同上，逻辑结果非负
3. sf=1，of=1：有溢出，则实际与逻辑相反，逻辑为正。
4. sf=0，of=1：实际结果非负，又 of=1，则结果非 0，所以实际为正，逻辑结果为负。

## 条件转移指令

通常配合 cmp，由 cmp 先进行比较，改变了 flag 中的值，条件转移指令根据 flag 中的值执行。
下面根据**无符号**数的比较进行转移的有：
| 指令 | 含义 | 条件 |
| ---- | ------------ | -------------- |
| je | 等于则转移 | 由 zf=1 则转移 |
| jne | 不等于则转移 | zf=0 |
| jb | 低于则转移 | cf=1 |
| jnb | 不低于则转移 | cf=0 |
| ja | 高于则转移 | cf=0 且 zf=0 |
| jna | 不高于则转移 | cf=1 或 zf=1 |

## DF 标志和串传送指令

flag 第 10 位是 DF，方向寄存器。在串处理指令中，控制每次操作后 si、di 的增减

-   df=0：每次操作后 si、di 递增
-   df=1：每次操作后 si、di 递减

### movsb 指令

格式：movsb
相当于：

```
mov es:[di],byte ptr ds:[si];（8086不支持这样的命令，这里只是描述）
if df = 0:
  inc si
  inc di
elif df = 1:
  dec si
  dec di
```

### movsw

类似上面，就是 si,di 每次加或减 2

`movsb`和`movsw`进行的是串传送的一个步骤，通常配合`rep`使用,如：
`rep movsb`，相当于：

```
s:movsb
  loop s
```

可见`rep`是根据 cx 的值，重复执行后面的串传送指令。

-   cld 指令：可以将 df 置 0
-   std 指令：可以将 df 置 1

## pushf 和 poopf

pushf 功能是将标志寄存器的值压栈，popf 是从栈中弹出数据给标志寄存器中。
通过 pushf 和 popf，可以直接访问 flag

# call 和 ret 指令

call 和 ret 都是转移指令，都修改 IP，或同时修改 CS 和 IP。

### ret 和 retf

-   ret 指令用栈中数据，修改 IP 的内容，从而实现近转移
-   retf 指令用栈中数据，修改 CS 和 IP 的内容，从而实现远转移

执行 ret 指令时，cpu 执行以下 2 部操作：

1. ip=ss\*10H+sp
2. sp=sp+2

_相当于`pop ip`_

执行 retf 指令时，进行下面 4 部操作：

1. ip=ss\*10H+sp
2. sp=sp+2
3. cs=ss\*10H+sp
4. sp=sp+2

_相当于`pop ip ;pop cs`_

### call 指令

执行 call 指令时，进行 2 部操作：

1. 将当前 ip 或 cs 和 ip 压栈
2. 转移

call 不能实现短转移，除此之外，call 实现转移的方法和 jmp 相同:

-   `call 标号`：将当前 ip 压栈后，转到标号处执行,相当于：

```
push ip
jmp near ptr 标号
```

-   `call far ptr 标号`：实现段间转移,相当于：

```
push cs
push ip
jmp far ptr 标号
```

-   `call 16位寄存器`：相当于：

```
push ip
jmp 16位寄存器
```

-   `call word ptr 内存单元地址`,相当于：

```
push ip
jmp word ptr 内存单元地址
```

-   `call dword ptr 内存单元地址`,相当于：

```
push cs
push ip
jmp dword ptr 内存单元地址
```

### mul 指令

mul 是乘法指令，要注意以下两点：

1. 两个相乘的数：要么都是 8 位，要么都是 16 位。如果是 8 位，一个放在 al，一个放在 8 位寄存器或内存字节单元中；若是 16 位，一个在 ax，一个在 16 位寄存器中。
2. 结果：如果是 8 位乘法，结果默认放在 ax 中；如果是 16 位，结果高位放在 dx，低位放在 ax。

解决除法溢出的方法：

> X/N = int( H/N)*65536 + [rem( H/N )*65536 + L ] / N
> X:被除数，N：除数，H：高 16 位，L：低 16 位，int：取商，rem：取余数

# 标志寄存器

## ZF 标志（zero flag）

flag 第 6 位是 ZF，零标志位。它记录执行相关指令后，其结果是否为 0。为 0 则 zf=1，否则 zf=0。
注意：8086 中，有些指令是影响 flag 的，比如：add、sub、mul、div、inc、or、and 等，它们大多是运算指令（逻辑或算数运算）；有一些则对 flag 没影响，如：mov，push，pop 等，大多是传送指令。

## PF 标志（Parity flag）

flag 第 2 位是 PF，奇偶标志位。看执行结果的所有 bit 位中 1 的个数是否是偶数。是偶数则 pf=1，否则 pf=0。
可以理解成 1 偶标志位。

## SF 标志位（Sign Flag）

flag 第 7 位是 SF，符号标志位。记录相关指令执行后结果是否为负。如果为负，sf=1；否则 sf=0
注意：sg 是 cpu 默认将数据当成**有符号**运算结果的记录。如果我们将数据当做无符号时，sf 时没有意义的，虽然相关指令可能影响了它的值。是不是有符号运算取决于我们。

## CF 标志位（Carry Flag）

flag 第 0 位是 CF 标志位。一般情况下，在进行**无符号数**运算时，它记录了运算结果的最高有效位向更高位的进位值，或借位值。
inc 和 loop 指令不影响 cf

## OF 标志位（Overflow Flag）

flag 第 11 位是 OF，溢出标志位。记录了**有符号**运算的结果是否溢出。有溢出 of=1，否则 of=0；

> 注意和 CF 的区别：
> cf 是对**无**符号数运算有意义的标志位
> of 是对**有**符号数运算有意义的标志位

## adc 指令

adc 是带进位加法指令，它利用了 CF 位上记录的进位值。(add +carry --> adc)如：
`adc ax,bx`实现的功能是`ax=ax+bx+cf`。
cpu 提供 adc 的目的，就是来进行加法的第二步运算的。

## sbb 指令

sbb 是带借位减法指令（sub borrow），利用 cf 记录的借位值。
`sbb ax,bx`实现的功能是`ax=ax-bx-cf`。
cpu 提供 dbb 的目的，就是来进行减法的第二步运算的。

## cmp 指令

cmp 是比较指令，相当于减法指令，只是不保留结果。cmp 会对 flag 产生影响。如：
`cmp ax,ax`做`ax-ax`运算，但并不在 ax 中保存，仅影响 flag。
进行·cmp ax,bx·比较后，通过 flag 可以看出比较结果

-   zf=1:ax=bx
-   cf=1:ax<bx
-   cf=0:ax>=bx
-   cf=0 且 zf=0:ax>bx
-   cf=1 或 zf=1:ax<=bx

注意：单纯的看 sf 的值不能判断结果的正负，因为可能会发生溢出。
而通过 sf 和 of 的值可以判断。

1. sf=1，of=0：没发生溢出，实际结果负，则逻辑结果也为负
2. sf=0，of=0：同上，逻辑结果非负
3. sf=1，of=1：有溢出，则实际与逻辑相反，逻辑为正。
4. sf=0，of=1：实际结果非负，又 of=1，则结果非 0，所以实际为正，逻辑结果为负。

## 条件转移指令

通常配合 cmp，由 cmp 先进行比较，改变了 flag 中的值，条件转移指令根据 flag 中的值执行。
下面根据**无符号**数的比较进行转移的有：
| 指令 | 含义 | 条件 |
| ---- | ------------ | -------------- |
| je | 等于则转移 | 由 zf=1 则转移 |
| jne | 不等于则转移 | zf=0 |
| jb | 低于则转移 | cf=1 |
| jnb | 不低于则转移 | cf=0 |
| ja | 高于则转移 | cf=0 且 zf=0 |
| jna | 不高于则转移 | cf=1 或 zf=1 |

## DF 标志和串传送指令

flag 第 10 位是 DF，方向寄存器。在串处理指令中，控制每次操作后 si、di 的增减

-   df=0：每次操作后 si、di 递增
-   df=1：每次操作后 si、di 递减

### movsb 指令

格式：movsb
相当于：

```
mov es:[di],byte ptr ds:[si];（8086不支持这样的命令，这里只是描述）
if df = 0:
  inc si
  inc di
elif df = 1:
  dec si
  dec di
```

### movsw

类似上面，就是 si,di 每次加或减 2

`movsb`和`movsw`进行的是串传送的一个步骤，通常配合`rep`使用,如：
`rep movsb`，相当于：

```
s:movsb
  loop s
```

可见`rep`是根据 cx 的值，重复执行后面的串传送指令。

-   cld 指令：可以将 df 置 0
-   std 指令：可以将 df 置 1

## pushf 和 poopf

pushf 功能是将标志寄存器的值压栈，popf 是从栈中弹出数据给标志寄存器中。
通过 pushf 和 popf，可以直接访问 flag

